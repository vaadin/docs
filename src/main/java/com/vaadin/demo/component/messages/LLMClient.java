package com.vaadin.demo.component.messages;

import java.time.Duration;
import java.util.List;
import org.jspecify.annotations.NonNull;

import com.vaadin.flow.component.messages.MessageList;

import reactor.core.publisher.Flux;

public class LLMClient {

    // This content is used by MessageListMarkdown.java.
    // See LLMChatService.ts for the equivalent used by
    // message-list-markdown.tsx and message-list-markdown.ts.
    private static final String answerMarkdown = """
            _(Please note: This is just a placeholder message and not generated by a real language model.)_

            I can help you with:

            1. **Answering questions** ‚Äì from quick facts to in-depth explanations.
            2. **Explaining concepts** ‚Äì breaking down complex ideas into clear, step-by-step logic.
            3. **Brainstorming & creativity** ‚Äì generating outlines, stories, code snippets, or design ideas.
            4. **Guidance & troubleshooting** ‚Äì walking you through processes or helping debug issues.

            ---

            ### How to get the most out of me üõ†Ô∏è

            | Step | What to do | Why it matters |
            |------|------------|----------------|
            | 1Ô∏è‚É£ | **State your goal clearly.** | A precise prompt yields a precise answer. |
            | 2Ô∏è‚É£ | **Add constraints or context.** <br>*(e.g., audience, length, tone)* | Tailors the response to your needs. |
            | 3Ô∏è‚É£ | **Ask follow-ups.** | We can iterate until you're satisfied. |

            Need anything else? Just let me know, and I'll jump right in! ‚ú®
            """;

    public static Flux<String> stream(String chatId, String userMessage) {
        // Simulate a call to an LLM API
        // In a real-world scenario, you would replace this with actual API
        // calls
        var answerTokens = answerMarkdown.split(" ");
        return Flux.fromArray(answerTokens)
                .delaySubscription(Duration.ofSeconds(1))
                .delayElements(Duration.ofMillis(100))
                .map(token -> token + " ");
    }

    public static List<Message> getHistory(String chatId) {
        return List.of(new Message(true, "Hello! How can I assist you today?"));
    }

    record Message(@NonNull boolean assistant, @NonNull String text) {
    }

    public static void initPolling(MessageList list) {
        // Since push is not in use in docs and poll interval isn't an option
        // (can't be safely cleared),
        // we use a custom polling mechanism for the example.
        list.getElement().addEventListener("poll", e -> {
        });
        list.getElement().executeJs(
                """
                            let previousMutation;
                            let interval;

                            const observer = new MutationObserver(() => {
                                previousMutation = Date.now();

                                // Clear existing interval before creating a new one
                                clearInterval(interval);
                                interval = setInterval(() => {
                                    if (!this.isConnected || previousMutation < Date.now() - 4000) {
                                        // It's been over 4 seconds since the last mutation, stop polling
                                        clearInterval(interval);
                                    } else {
                                        this.dispatchEvent(new Event('poll'));
                                    }
                                }, 200);
                            });

                            observer.observe(this, { childList: true, subtree: true });
                        """);
    }
}
