---
title: Docker Deployment
description: Deploy your Vaadin application using Docker
order: 55
---

= Deploying Using Docker

A https://docs.docker.com/get-started/overview/[Docker container] is a standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries, and settings.
Building a Docker image requires creating a Dockerfile, a text document containing all the commands needed to assemble and run that image.

== Creating a Dockerfile for New Vaadin Applications

For a Vaadin application, you can easily generate a [filename]#Dockerfile# by selecting the `Docker` option in https://start.vaadin.com/[Vaadin Start].
This makes building and running your container as simple as running the following two commands:

. To build your container (assuming your project name is `myapp`), run
+
`docker build . -t myapp:latest`

. To run your container on localhost.
+
`docker run -p 8080:8080 myapp:latest`

== Adding a Dockerfile to Existing Vaadin Applications

If your Vaadin project was not generated with a [filename]#Dockerfile#, you can copy and paste the Dockerfile from a fresh Vaadin Start project into your project.

While we will not cover all of the commands that you can use in a [filename]#Dockerfile# here, let us quickly inspect the Dockerfile generated by Vaadin Start to help you customize it in your application.

A typical Dockerfile from Vaadin Start should look similar to the content below.

.`Dockerfile`
[source,dockerfile]
—---
# Stage that builds the application, a prerequisite for the running stage
# <1>
FROM maven:3-openjdk-17-slim as build
# <2>
RUN curl -sL https://deb.nodesource.com/setup_14.x | bash -
# <3>
RUN apt-get update -qq && apt-get install -qq --no-install-recommends nodejs
# Stop running as root at this point
# <4>
RUN useradd -m myuser
# <5>
WORKDIR /usr/src/app/
# <6>
RUN chown myuser:myuser /usr/src/app/
# <7>
USER myuser
# Copy pom.xml and prefetch dependencies so a repeated build can continue from the next step with existing dependencies
# <8>
COPY --chown=myuser pom.xml ./
# <9>
RUN mvn dependency:go-offline -Pproduction
# Copy all needed project files to a folder
# <10>
COPY --chown=myuser:myuser src src
# <11>
COPY --chown=myuser:myuser frontend frontend
# <12>
COPY --chown=myuser:myuser package.json ./
# Using * after the files that are autogenerated so that so build won't fail if they are not yet created
# <13>
COPY --chown=myuser:myuser package-lock.json* pnpm-lock.yaml* webpack.config.js* ./
# Build the production package, assuming that we validated the version before so no need for running tests again
# <14>
RUN mvn clean package -DskipTests -Pproduction
# Running stage: the part that is used for running the application
# <15>
FROM openjdk:17-jdk-slim
# <16>
COPY --from=build /usr/src/app/target/*.jar /usr/app/app.jar
# <17>
RUN useradd -m myuser
# <18>
USER myuser
# <19>
EXPOSE 8080
# <20>
CMD java -jar /usr/app/app.jar
—---

<1> Use the https://hub.docker.com/_/maven[official Maven image] as the base image. The variant used is the slim version as specified by the `maven:<version>-slim` syntax.
<2> Runs the `curl` command to download the Node.js binary.
<3> Updates apt and installs the Node.js binary downloaded in the previous step.
<4> Adds a new user called `myuser`.
<5> Changes the current working directory using the `WORKDIR` instruction.
<6> Modifies the ownership of the directory `/usr/src/app/` in the container volume.
<7> Switches to the `myuser` unix user.
<8> Copy the `pom.xml` file with the optional `chown` feature.
<9> Runs `maven`.
<10> Coping files.
<11> Coping files.
<12> Coping files.
<13> Coping files.
<14> Using `mvn` to build the production package.
<15> Sets the image for running the application
<16> Copying the generated jar file.
<17> Adds `myuser`.
<18> Switches to `myuser`.
<19> Opens port 8080 using the Dockerfile `EXPOSE` instruction.
<20> Runs the packaged jar file.

[NOTE]
Dockerfile instructions can be found at https://docs.docker.com/engine/reference/builder/
