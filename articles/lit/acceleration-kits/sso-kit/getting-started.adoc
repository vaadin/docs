---
title: Getting Started
description: Step-by-step guide showing how to use SSO Kit in your application.
order: 100
---
:lit:
// tag::content[]

== Getting Started with SSO Kit
:sectnums:

SSO Kit builds upon https://spring.io/projects/spring-boot[Spring Boot] and https://spring.io/projects/spring-security[Spring Security]. It comes with a starter module that configures the security settings needed to authenticate with your identity provider.

== Create a Hilla Application without Authentication

You can create a Hilla application by entering the following from the command-line:

ifdef::lit[]
[source,bash]
----
npx @hilla/cli init <your-project-name>
----
endif::[]

ifdef::react[]
[source,bash]
----
npx @hilla/cli init --react <your-project-name>
----
endif::[]

== Backend

=== Add the SSO Kit Dependency

Add the `sso-kit-starter` module and other required dependencies to the [filename]`pom.xml` of your Vaadin application like so:

.[filename]`pom.xml`
[source,xml]
----
<dependency>
    <groupId>dev.hilla</groupId>
    <artifactId>sso-kit-starter</artifactId>
    <version>2.0.0.beta1</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----

[NOTE]
Check the https://github.com/vaadin/sso-kit/releases[SSO Kit releases] page for the latest or a different version of the `sso-kit-starter` dependency.

=== Configure the SSO Provider in Spring

Next, you need to set some configuration properties to connect SSO Kit to your OpenID Connect provider. These properties can be added to your [filename]`application.properties` file where you define the provider URL and the client registration details, such as credentials and scope.

Provider definition is configured within the `spring.security.oauth2.provider` namespace where you define a key to identify your provider, such as `keycloak`. Then you can use the same key to register the client for that provider within the `spring.security.oauth2.registration` namespace, where you specify client credentials and the requested scope.

The scope is a list of keywords to request the provider for a specific set of information, such as user `profile`, `email` or `roles`. The following is an example of the properties to set to enable a Keycloak instance to perform authentication:

[.example]
--
.[filename]`application.properties`
[source,properties]
----
hilla.sso.login-route=/oauth2/authorization/keycloak
spring.security.oauth2.client.registration.keycloak.scope=profile,openid,email,roles
# Customize the values of the following properties according to your Keycloak configuration
spring.security.oauth2.client.provider.keycloak.issuer-uri=https://my-keycloak.io/realms/my-realm
spring.security.oauth2.client.registration.keycloak.client-id=my-client
spring.security.oauth2.client.registration.keycloak.client-secret=very-secret-value
----
.[filename]`application.yaml`
[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: https://my-keycloak.io/realms/my-realm
        registration:
          keycloak:
            client-id: my-client
            client-secret: very-secret-value
            scope:
            - profile
            - openid
            - email
            - roles
hilla:
  sso:
    login-route: /oauth2/authorization/keycloak
----
--

By default, the package name in generated Hilla projects is `com.example.application`. Unless you use the same package name as for your application, you have to whitelist your package in Spring Boot for Hilla to be able to find the Endpoint. Open your [filename]`Application.java` and add the package to the annotation like this:

.[filename]`Application.java`
[source,java]
----
@SpringBootApplication(scanBasePackages = {
  "com.example.application", // Application package
  "dev.hilla.sso.starter" // SSO Kit
})
public class Application // ...
----

=== Secure the application

A Hilla application includes front-end code and back-end endpoints. Both of them can (and should) benefit from authentication protection.

=== Protect the example endpoint

Hilla allows fine-grained authorization on Endpoints and Endpoint methods. You can use annotations like `@PermitAll` or `@RolesAllowed(...)` to declare who can access what.

To try this feature, replace the `@AnonymousAllowed` annotation in [filename]`HelloWorldEndpoint.java` with `@PermitAll`, so that unauthenticated users will be unable to access all endpoint methods. You could also apply the same annotation at the method level for more fine-grained control.

Start the application using the `./mvnw` command (`.\mvnw` on Windows) and try the application in the browser. It should work correctly, except that when you click on the `Say hello` button, nothing happens. This is because the Endpoint is no longer accessible without authentication.

== Frontend

=== Implement authentication state

ifdef::lit[]
All the essential authentication state is already available in a global variable and can be added to the application state, which is inside the `AppStore` class in [filename]`app-store.ts`:

.frontend/stores/app-store.ts
[source,typescript]
----
import SingleSignOnData from 'Frontend/generated/dev/hilla/sso/starter/SingleSignOnData';

// All the data we need is already loaded in the Hilla global variable
authInfo = (window as any).Hilla.SSO as SingleSignOnData;
----
endif::[]

ifdef::react[]
All the essential authentication state is already available in a global variable and can be used as application state. Create a new file named `useAuth.tsx` and define a React Context:

.frontend/useAuth.tsx
[source,typescript]
----
import { createContext, Dispatch, SetStateAction } from "react";
import SingleSignOnData from "./generated/dev/hilla/sso/starter/SingleSignOnData";

// Used for access control
export type AccessProps = Readonly<{
    requiresLogin?: boolean;
}>;

// The context type
export type Authentication = Readonly<{
    state: SingleSignOnData;
    hasAccess: (route: AccessProps) => boolean;
    clearAuthInfo: () => void;
}>;

// All the data we need is already loaded in the Hilla global variable
export const initialState = (window as any).Hilla.SSO as SingleSignOnData;

// The context itself
export const AuthContext = createContext<Authentication>({
    state: initialState,
    hasAccess: () => false,
    clearAuthInfo: () => { },
});

// The hook to use the context
export const useAuth = (
    state: SingleSignOnData,
    setState: Dispatch<SetStateAction<SingleSignOnData>>
): Authentication => {
    return {
        state,
        hasAccess: (route: AccessProps) => {
            return !route.requiresLogin || state.authenticated;
        },
        clearAuthInfo: () => {
            setState({
                ...state,
                authenticated: false,
                backChannelLogoutEnabled: false,
                logoutLink: undefined,
                roles: [],
            });
        }
    }
};
----

Then add the state and the context to `App.tsx` and wrap the `RouterProvider`:

.frontend/App.tsx
[source,typescript]
----
import router from 'Frontend/routes.js';
import { useState } from 'react';
import { RouterProvider } from 'react-router-dom';
import { AuthContext, initialState, useAuth } from './useAuth';

export default function App() {
  const [state, setState] = useState(initialState);

  return <AuthContext.Provider value={useAuth(state, setState)}>
    <RouterProvider router={router} />
  </AuthContext.Provider >;
}
----
endif::[]

=== Add log-in and log-out buttons

As an example, add two buttons to the drawer footer, one to sign in and another to sign out. When signing out, it is important to invoke the `logout` function provided by Hilla to perform logout on the server. Then, load the SSO provider logout page.

ifdef::lit[]
.frontend/views/main-layout.ts
[source,typescript]
----
import { logout } from '@hilla/frontend';

// Replace the `footer` in the rendered `html`
<footer slot="drawer">
  ${appStore.authInfo.authenticated
    ? html`<vaadin-button @click="${this.signOut}">Sign out</vaadin-button>`
    : html`<vaadin-button @click="${this.signIn}">Sign in</vaadin-button>`
  }
</footer>

// Add the needed functions inside the class
private signOut = async () => {
  await logout(); // Logout on the server
  location.href = appStore.authInfo.logoutLink!;
};

private signIn = () => {
  location.href = appStore.authInfo.loginLink;
};
----
endif::[]

ifdef::react[]
.frontend/views/MainLayout.tsx
[source,typescript]
----
import { logout } from '@hilla/frontend';
import { Button } from '@hilla/react-components/Button.js';
import { AuthContext } from 'Frontend/useAuth';
import { Suspense, useContext } from 'react';

// Use the AuthContext
const { state } = useContext(AuthContext);

// Define button event handlers
async function signOut() {
  await logout(); // Logout on the server
  location.href = state.logoutLink!;
};

function signIn() {
  location.href = state.loginLink;
};

// Add the buttons to the footer
<footer slot="drawer">
  {state.authenticated
    ? <Button onClick={signOut}>Sign out</Button>
    : <Button onClick={signIn}>Sign in</Button>
  }
</footer>
----
endif::[]

=== Add Access Control

You can protect your views one by one by verifying that authentication has happened before loading the view.

ifdef::lit[]

In [filename]`app-store.ts`, add a new type definition and a function to check access rights using that type:

.frontend/app-store.ts
[source,typescript]
----
export type AccessProps = {
  requiresLogin?: boolean;
};

// put this function inside the AppStore class
hasAccess = (route: AccessProps) => {
  return !route.requiresLogin || this.authInfo.authenticated;
};
----

In the [filename]`frontend/routes.ts` file, use the `AccessProps` type and protect the About view:

.frontend/routes.ts
[source,typescript]
----
import { AccessProps } from './stores/app-store';

// Add AccessProps to the ViewRoute type
export type ViewRoute = Route & AccessProps & {
  // ...
}

// Add the requiresLogin attribute to the About view
{
  path: 'about',
  // ...
  requiresLogin: true,
},
----

Then, filter the menu excluding unauthorized views by amending the view filter in [filename]`main-layout.ts`:

.frontend/views/main-layout.ts
[source,typescript]
----
// Add a new condition in the getMenuRoutes that checks for authentication
private getMenuRoutes(): RouteInfo[] {
  return views.filter((route) => route.title).filter(appStore.hasAccess) as RouteInfo[];
}
----
endif::[]

ifdef::react[]
Open the [filename]`frontend/routes.tsx` and add the `requiredLogin` parameter to a view:

.frontend/routes.tsx
[source,typescript]
----
import { AccessProps } from './useAuth';

// Enrich the ViewRouteObject type with AccessProps
export type ViewRouteObject = (IndexViewRouteObject | NonIndexViewRouteObject) & AccessProps;

// Add requiresLogin to the About View
{
  path: '/about',
  element: <AboutView />,
  handle: { icon: 'la la-file', title: 'About' },
  requiresLogin: true,
},
----

Then, in the main layout, filter the menu:

.frontend/views/MainLayout.tsx
[source,typescript]
----
// Gather the hasAccess function
const { state, hasAccess } = useContext(AuthContext);

// Filter the menu when rendering
{menuRoutes.filter(hasAccess).map(({ path, handle: { icon, title } }) => (
  // ...
----
endif::[]

Now the `About` item in the menu only appears when authenticated.

=== Show user information

The SSO Kit provides a default endpoint to get information about the authenticated user. You can implement your one if you want to customize the returned object and its fields.

As the About page is now protected, that's a perfect place to show some information about the current user:

ifdef::lit[]

.frontend/views/helloworld/about-view.ts
[source,typescript]
----
import User from 'Frontend/generated/dev/hilla/sso/starter/endpoint/User';
import { UserEndpoint } from 'Frontend/generated/endpoints';
import { property } from 'lit/decorators.js';

// Add a property for the user
@property()
user: User | undefined;

// Add the `async` keyword to connectedCallback and then load the user inside the function
async connectedCallback() {
  // ...
  this.user = await UserEndpoint.getAuthenticatedUser();
}

// Add some output
<p>Username: ${this.user?.preferredUsername}</p>
<p>Full name: ${this.user?.fullName}</p>
<p>Email: ${this.user?.email}</p>
----
endif::[]

ifdef::react[]

.frontend/views/about/AboutView.tsx
[source,typescript]
----
import User from "Frontend/generated/dev/hilla/sso/starter/endpoint/User";
import { UserEndpoint } from "Frontend/generated/endpoints";
import { useEffect, useState } from "react";

// Store the authenticated user
const [user, setUser] = useState<User | undefined>();

// Fetch the authenticated user from the server
useEffect(() => {
  UserEndpoint.getAuthenticatedUser().then(setUser);
}, []);

// Add some output
<p>Username: {user?.preferredUsername}</p>
<p>Full name: {user?.fullName}</p>
<p>Email: {user?.email}</p>
----
endif::[]

== Single Sign-Off

SSO Kit provides two methods for logging out the user. It's defined by the OpenID Connect specification like so:

- https://openid.net/specs/openid-connect-rpinitiated-1_0.html[RP-Initiated Logout]
- https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel Logout]

=== RP-Initiated Logout

RP-Initiated Logout (i.e., Relaying Party, the application) enables the user to logout from the application itself, ensuring the connected provider session is terminated.

=== Back-Channel Logout

Back-Channel Logout is a feature that enables the provider to close user sessions from outside the application. For example, it can be done from the provider's user dashboard or from another application.

==== Enable the Feature

To enable the feature in the application, you need to set the `hilla.sso.back-channel-logout` property to `true`. You would do this like you see here:

[.example]
--
.[filename]`application.properties`
[source,properties]
----
hilla.sso.back-channel-logout=true
----
.[filename]`application.yaml`
[source,yaml]
----
hilla:
  sso:
    back-channel-logout: true
----
--

The client should then be configured on the provider's dashboard to send logout requests to a specific application URL: `/logout/back-channel/{registration-key}`, where `{registration-key}` is the provider key.

==== Modify the frontend

ifdef::lit[]
State about back-channel logout can be added to [filename]`app-store.ts`:

.frontend/stores/app-store.ts
[source,typescript]
----
import { BackChannelLogoutEndpoint } from 'Frontend/generated/endpoints';

// Will become true when back-channel logout happens
backChannelLogoutHappened = false;

constructor() {
  makeAutoObservable(this);

  // Add this to the constructor to subscribe to back-channel logout events
  if (this.authInfo.backChannelLogoutEnabled) {
    const subscription = BackChannelLogoutEndpoint.subscribe();
    subscription.onNext(() => {
      this.backChannelLogoutHappened = true;
      subscription.cancel();
    });
  }
}

// Clears authInfo without reloading the page
clearAuthInfo() {
  this.authInfo = {
      ... this.authInfo,
      authenticated: false,
      backChannelLogoutEnabled: false,
      logoutLink: undefined,
      roles: [],
  };
}
----

Then, a dialog can be added to the application layout to notify the user:

.frontend/views/main-layout.ts
[source,typescript]
----
import '@vaadin/confirm-dialog';

// Add the dialog to the rendered html
<vaadin-confirm-dialog
  header="Logged out"
  cancel-button-visible
  @confirm="${this.loginAgain}"
  @cancel="${this.stayOnPage}"
  .opened="${appStore.backChannelLogoutHappened}"
>
  <p>You have been logged out. Do you want to log in again?</p>
</vaadin-confirm-dialog>

// Then add the event handlers
private async stayOnPage() {
  await logout(); // Logout on the server
  appStore.clearAuthInfo(); // Logout on the client
}

private async loginAgain() {
  await logout(); // Logout on the server
  location.href = appStore.authInfo.loginLink!;
}
----
endif::[]

ifdef::react[]
As an example, let's show a dialog when the user is logged out from outside the application. We can do that in the main layout file:

.frontend/views/MainLayout.tsx
[source,typescript]
----
import { ConfirmDialog } from '@hilla/react-components/ConfirmDialog.js';
import { BackChannelLogoutEndpoint } from 'Frontend/generated/endpoints';
import { Suspense, useContext, useEffect, useState } from 'react';

// Add a state that is modified when the log-out event happens
const [backChannelLogout, setBackChannelLogout] = useState(false);

// Gather the clearAuthInfo function from the AuthContext
const { state, hasAccess, clearAuthInfo } = useContext(AuthContext);

// Subscribe to the endpoint and update the state accordingly
useEffect(() => {
  if (state.backChannelLogoutEnabled) {
    const subscription = BackChannelLogoutEndpoint.subscribe();
    subscription.onNext(() => {
      setBackChannelLogout(true);
      subscription.cancel();
    });
  }
}, []);

// Add the click event handlers
async function loginAgain() { 
  await logout(); // Logout on the server
  location.href = state.loginLink;
}

async function stayOnPage() { 
  setBackChannelLogout(false);
  await logout(); // Logout on the server
  clearAuthInfo(); // Clear the user info on the client
}

// Finally, add the dialog
<ConfirmDialog header='Logged out' cancelButtonVisible opened={backChannelLogout}
  onConfirm={loginAgain} onCancel={stayOnPage}>
  <p>You have been logged out. Do you want to log in again?</p>
</ConfirmDialog>
----
endif::[]

You can trigger a logout externally using the provider tools. For Keycloak, you can sign out a session from the admin console or visit the page `https://my-keycloak.io/realms/my-realm/protocol/openid-connect/logout`.
