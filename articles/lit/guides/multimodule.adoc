---
title: Multi-module support
description: Multi-module support allows you to split your application project into smaller sub-projects, making maintenance easier. You can also implement your endpoints using any JVM language, like Kotlin or Scala.
order:
section-nav: experimental
---

= [since:dev.hilla:hilla@v1.2]#Multi-module support#

.Experimental feature
[CAUTION]
Multi-module support is an experimental feature. This means that its behavior, API, and look and feel might change.
To enable multi-module support, it must be explicitly enabled with a feature flag.
See the <<feature-flag>> section for how to do this.

Hilla ships with an engine that takes care of parsing Java code and generating the corresponding TypeScript, with the following benefits:

- Support for multi-module projects: you can use standard Maven modules in your application, or even external dependencies, as there is no need for endpoints and entity classes to be in the same project as the Hilla application;
- Hilla is designed to be flexible. All parts of the Hilla generator are pluggable, which allows you to alter the default behavior or add a new one;
- Support for JVM languages other than Java: you can create classes with Kotlin, for example, and have them translated to TypeScript.

== Architecture

The Hilla generator consists of three parts:

- *Java Bytecode Parser*.
It reads the Java bytecode and generates an OpenAPI scheme.

- *TypeScript Abstract Syntax Tree (AST) Generator*.
It reads the OpenAPI scheme and generates TypeScript endpoints that could be used in further front-end development.

- *Runtime Controller*.
This provides runtime communication between the server and the client.

== Usage example

To showcase the new features, let's convert a standard Hilla project to a multi-module one and then also add some Kotlin to it.
The project we're going to create is available https://github.com/vaadin/hilla-multi-module[on GitHub].

=== Create a Hilla application

Create a folder named [filename]`hilla-multi-module`. Then, inside that folder, create an application as usual:

[source,terminal]
----
npx @vaadin/cli init --hilla application
----

Now enter the [filename]`application` folder and run the generated application, as usual.

Don't enable the multi-module generator for now: we'll do that when it's necessary.

=== Add a JAR Maven module

Let's now create a new JAR module that will become a dependency for the Hilla application. It will contain the endpoint used in the example.
Create a basic Java library module and name it [filename]`library`.

The library's [filename]`pom.xml` must contain a dependency to Hilla, since we want to create some Hilla-related classes inside:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>dev.hilla</groupId>
        <artifactId>hilla</artifactId>
        <version>1.2.3</version>
    </dependency>
</dependencies>
----

To allow the generator to use the correct parameter names when building TypeScript files, let's configure the Java compiler not to omit them by enabling the `parameters` option:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.10.1</version>
            <configuration>
                <encoding>UTF-8</encoding>
                <parameters>true</parameters>
            </configuration>
        </plugin>
    </plugins>
</build>
----

This is the https://github.com/vaadin/hilla-multi-module/tree/96ef912fb844edf27c20d6d2101fdb2985567598[corresponding commit] on GitHub.

=== Move the endpoint to the library

At this point, the easiest way to test a Hilla multi-module project is to move the example endpoint to the JAR library: move the [classname]`HelloWorldEndpoint` class to the other project and make the application project depend on the library, like in https://github.com/vaadin/hilla-multi-module/tree/b499cd9a22cb96567e675b7f72d3a048c9552585[this commit]:

[source,xml]
----
<dependency>
    <groupId>com.example.application</groupId>
    <artifactId>library</artifactId>
    <version>${project.version}</version>
</dependency>
----

Now, if you try to run the Hilla application again, it will complain about the missing class, as it cannot be found in a JAR dependency.

=== Enable the multi-module generator

Follow the steps described in the <<feature-flag>> section to enable the multi-module support. Then run the application again and verify that it works as expected: the endpoint will be available as before, even if it's now part of a dependency.

=== Advanced plugin configuration

Engine plugins can be configured and extended.
As a basic example, let's define a custom [classname]`NonNull` annotation and use it in our code instead of the default ones.

The configuration parameters are specific to the plugin.
In this case, the simplest way is to `<disable>` the default configuration of the [classname]`NonnullPlugin` and `<use>` a detailed custom configuration, like in this example:

[source,xml]
----
<configuration>
    <parser>
        <plugins>
            <use>
                <plugin>
                    <name>dev.hilla.parser.plugins.nonnull.NonnullPlugin</name>
                    <configuration implementation="dev.hilla.parser.plugins.nonnull.NonnullPluginConfig">
                        <use>
                            <annotation>
                                <name>com.example.application.annotations.NeverNull</name>
                                <makesNullable>false</makesNullable>
                                <score>50</score>
                            </annotation>
                        </use>
                    </configuration>
                </plugin>
            </use>
            <disable>
                <plugin>
                    <name>dev.hilla.parser.plugins.nonnull.NonnullPlugin</name>
                </plugin>
            </disable>
        </plugins>
    </parser>
</configuration>
----

You'll need to create the custom annotation and update the endpoint to use it:

[source,java]
----
package com.example.application.annotations;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE_USE })
public @interface NeverNull {
}
----

[source,java]
----
@NeverNull
public String sayHello(@NeverNull String name) {
    if (name.isEmpty()) {
        return "Hello stranger";
    } else {
        return "Hello " + name;
    }
}
----

The plugin configuration is modelled on the configuration classes defined for each plugin. For example, see the https://github.com/vaadin/hilla/blob/main/packages/java/parser-jvm-plugin-nonnull/src/main/java/dev/hilla/parser/plugins/nonnull/NonnullPluginConfig.java[Nonnull plugin configuration].

=== Use Kotlin

The library project `pom.xml` file must be modified to enable Kotlin.
In the GitHub example application the changes have been performed by IntelliJ IDEA, but you can follow the https://kotlinlang.org/docs/maven.html[Kotlin documentation] if you want to do that yourself.
Otherwise, this is the https://github.com/vaadin/hilla-multi-module/tree/119e6ce7c14abfd876fe696373f941a7d46f467a[corresponding commit].
As we did in Java, the `javaParameters` tag has been added to preserve parameter names in compiled code.

Then, convert the [classname]`HelloWorldEndpoint` to Kotlin and modify the returned message to make the change stand out when running the application:

[source,kotlin]
----
@Endpoint
@AnonymousAllowed
class HelloWorldEndpoint {
    fun sayHello(name: String): String {
        return if (name.isEmpty()) {
            "Hello stranger from Kotlin"
        } else {
            "Hello $name from Kotlin"
        }
    }
}
----

The [classname]`@Nonnull` annotation has been removed. As in Kotlin, this is the default.

Run the application and verify that the new message is shown when clicking on the button.

[[feature-flag]]
== Feature flag

To enable multi-module support, you must enable it with a feature flag.
You can do it in two ways:

=== Using Vaadin Developer Tools

. Click on the Vaadin Developer Tools icon button in your running application.
. Open the [guilabel]*Experimental Features* tab.
. Enable the [guilabel]*Multi-module engine in Hilla* feature.
. Restart the application.

=== Adding a feature flags properties file

. Find or create the [filename]`src/main/resources/vaadin-featureflags.properties` file in your application folder.
. Add the following line: `com.vaadin.experimental.hillaEngine=true`
. Restart the application.
