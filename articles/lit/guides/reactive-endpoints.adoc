---
title: Reactive endpoints
description: Reactive endpoints allow you to stream data to the client without the traditional HTTP request-response pattern.
order: 35
---
// tag::content[]

= [since:dev.hilla:hilla@v1.2]#Reactive endpoints#

ifdef::react[]
.This guide has not been revised for React
[WARNING]
Some of the code examples in this guide have not been revised to use React. They are still using Lit-based templating and web components instead of JSX and React components.
endif::react[]

.Preview feature
[IMPORTANT]
You need to enable the <<../reference/feature-flags#,`hillaPush` feature flag>> to use reactive endpoints.

Although traditional server calls work fine in most cases, sometimes you need different tools for your job.
https://projectreactor.io/[Reactor] is one of these.
It can help you in streaming data to clients and fits well into a non-blocking application.
Whenever the simple request-response pattern doesn't suit your needs, you might want to consider Reactor.
Multi-user applications, infinite data streaming, and retries, are all good examples of what you can do with it.

If you want to pick up on Reactor, they have a curated https://projectreactor.io/learn[learn page].

Although getting comfortable with creation of streaming, non-blocking applications requires some effort, Hilla allows you to take advantage of Reactor in minutes.
You can read the excellent https://hilla.dev/blog/interactive-applications-with-server-push/[blog article on reactive endpoints] to get the basics.

== Example

Before looking at the API details, you can get to know the basics of reactive endpoints by writing a basic application that can stream the current time of the server to the client.
The purpose of this example is to send the server time to all subscribed clients, with an interval of one second between each message.

Start by creating a Hilla application as usual:

[source,terminal]
----
npx @hilla/cli init --push flux-clock
----

Note the presence of the `--push` flag; this enables support for push / reactive endpoints.

Now, start your new application as usual:

:change-dir-command: cd flux-clock
include::{articles}/lit/start/quick.adoc[tag=run]

Then, when the application opens in the browser, click on the [guilabel]*Dev Tools* icon in the bottom-right corner and then on [guilabel]*Experimental features*.
Double-check that [guilabel]*Push support in Hilla* is enabled, or enable it if necessary.

=== Create a server-side endpoint

Open your application in your favorite IDE or editor.

First, create a new endpoint and name it `ReactiveEndpoint`.
You can put it inside [filename]`HelloWorldEndpoint.java` or in a package of your choice.
This new endpoint contains these two methods:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/reactive/ReactiveEndpoint.java[tags=snippet,indent=0]
----

You can click on the expand icon above the code snippet to get the whole file.

The first method, [methodname]`getClock()`, creates a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] that streams the server time each second.
It uses https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--[onBackpressureDrop()] to avoid saturation in case some messages cannot be sent to the client in real time.
In this use case, it's okay to lose some messages.

The second method, [methodname]`getClockCancellable()`, returns the same [classname]`Flux`, but wrapped in an [classname]`EndpointSubscription`, a Hilla-specific [classname]`Flux` wrapper which allows you to execute something on the server side if the subscription is cancelled by the client.
In this example, a log message is produced.

=== Create a view to shows the messages

Now you get to use these methods in our client views.
Create the [filename]`frontend/views/reactive/reactive-view.ts` file to add a new view.
This looks like the default "Hello world" example, customized with the code that follows.
Again, you can expand it if you prefer to get the whole file.
You might have to fix some imports.

[source,typescript]
----
include::{root}/frontend/demo/fusion/reactive/reactive-view.ts[tags=snippet,indent=0]
----

Then, add the new view to the router (`frontend/routes.ts`), by importing it with:

[source,typescript]
----
import './views/reactive/reactive-view';
----

and declaring it with:

[source,typescript]
----
  {
    path: 'reactive-clock',
    component: 'reactive-view',
    icon: 'la la-clock',
    title: 'Server Clock',
  },
----

right after the `hello` path.

You new view should now be available in the application.
When the `Toggle server clock` button is clicked, the time will appear in the text field and will update each second.
You can stop it by clicking again.




== API overview

The generated TypeScript endpoint methods return a [classname]`Subscription<T>` object, which offers these methods:

[methodname]`cancel()`::
Cancel the subscription.

[methodname]`onNext()`::
Get the next message in the Flux.

[methodname]`onError()`::
Get errors that can happen in the Flux.

[methodname]`onComplete()`::
Be informed when the Flux has no more messages to send.

[methodname]`context()`::
Bind to the context, which allows the application to automatically close it when the view is detached.




// end::content[]
