---
title: Accessing Java Backend
description: Using Hilla to call the Java backend from a TypeScript frontend in a type-checkable way.
order: 60
layout: page
---


= Accessing the Java Backend

A server-side Java endpoint is a backend method that is exposed for calling from client-side TypeScript code.
An endpoint in Hilla is a class that defines one or more public methods.

Hilla bridges Java backend endpoints and a TypeScript frontend.
It generates TypeScript clients to call the Java backend in a type-checkable way.

.Hilla endpoints depend on Spring Boot auto-configuration.
[WARNING]
They do not work if auto-configuration is disabled, for example when you use `@EnableWebMvc`.
As a workaround, remove the `@EnableWebMvc` annotation, as described in link:https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration[Spring Boot documentation].
If you have an idea for how to make it more useful for you, please share it on link:https://github.com/vaadin/flow/issues/new/[GitHub^].

== Creating an Endpoint

An endpoint is a Java class annotated with `@Endpoint`:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/CounterEndpoint.java[tags=snippet]
----

When the application starts, Hilla scans the classpath for `@Endpoint`-annotated classes.
For each request to access a public method in a Hilla endpoint, a permission check is carried out.
`@AnonymousAllowed` means that Hilla permits anyone to call the method from the client side.

Refer to the <<../security#, Security>> article for details of configuring endpoint access.

== TypeScript Modules

In JavaScript and TypeScript, modules are files that follow the module syntax.
This syntax has the following properties:

- Top-level declarations (variables, functions, classes, etc.) are scoped inside the module, meaning that, by default, they are not available outside it.

- A module supports top-level `export` statements, which make declarations available to other modules.

- A module supports top-level `import` statements, which load and execute other modules, and can bring exported declarations.

The following example demonstrates the [filename]#city.ts# module:

.`city.ts`
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-info/city.d.ts[]
----

.`index.ts`
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-info/index.ts[]
----

In Hilla applications, the [filename]#index.ts# (or, optionally, [filename]#index.js#) file is also a module.

== Modules Generated From Hilla Endpoints

Hilla generates a TypeScript module for every Hilla endpoint on the backend.
Each such module exports all the methods in the endpoint.

You can import an entire module from the https://basarat.gitbook.io/typescript/main-1/barrel[barrel] file, import all methods as a module from the endpoint file, or select individual endpoint methods.
For example, the [filename]#CounterEndpoint.ts# could be used, as in the following snippets:

.`index.ts` (import the whole endpoint module object from the barrel file)
[[index.ts]]
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/barrel.ts[]
----

[NOTE]
The barrel file exports all the endpoints at once, so you can import multiple endpoints using a single import.

.`index.ts` (import all imports as an endpoint object)
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/asterisk.ts[]
----

.`index.ts` (import a single endpoint method)
[source,typescript]
----
include::{root}/frontend/demo/fusion/application/accessing-backend/ts-imports/method.ts[]
----

.The “Frontend” directory alias
[NOTE]
====
The `'Frontend/'` path prefix is an alias for the `{project.basedir}/frontend` directory in your application project.

Hilla has this path alias in <<basics#Configuring TypeScript Compiler,the default TypeScript compiler configuration>> ([filename]#tsconfig.json#); the webpack configuration file ([filename]#webpack.generated.js#) respects the `tsconfig` aliases by default.

Using this path alias is recommended, as it allows for absolute import paths, rather than traversing the directory hierarchy in relative imports.
====

Hilla generates the TypeScript modules automatically when you compile the application, as well as when the application is running in development mode.

By default, the generated files are located under `{project.basedir}/frontend/generated`.
You can change the folder by providing the path for the generator in the `generatedFrontendDirectory` property for the Hilla Maven plugin.

Hilla takes care of type conversion between Java and TypeScript types.
For more information about supported types, see <<../advanced/type-conversion#, Type Conversion>>.

== Example TypeScript Module Contents

For example, the generated TypeScript module for the Java endpoint defined in
<<accessing-backend#how-to-create-vaadin-endpoint,CounterEndpoint.java>> would look as follows:

.`CounterEndpoint.ts`
[source,typescript]
----
include::{root}/frontend/generated/CounterEndpoint.ts[]
----

== Entities

An endpoint method can return or receive a parameter as an entity (non-primitive type).
In this case, the generator also creates a TypeScript interface for the entity.

An entity can be defined in the following ways:

- In a separate class that belongs to the project.

- In a class that belongs to the project dependency.

- In an inner class (of an endpoint or any other class).

.`City.java`
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/City.java[]
----

.`CountryEndpoint.java`
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/accessingbackend/CountryEndpoint.java[]
----

The TypeScript output is the following:

.`City.ts`
[source,typescript]
----
include::{root}/frontend/generated/com/vaadin/demo/fusion/accessingbackend/City.ts[]
----

.`Query.ts`
[source,typescript]
----
include::{root}/frontend/generated/com/vaadin/demo/fusion/accessingbackend/CountryEndpoint/Query.ts[]
----

.`CountryEndpoint.ts`
[source,typescript]
----
include::{root}/frontend/generated/CountryEndpoint.ts[]
----

=== Nullable and Non-Nullable Types

Please refer to <<../advanced/endpoints-generator#Type Nullability, Type Nullability>> for more information about how the nullability algorithm works and how to make types non-nullable.

== Code Completion in IDEs

As you can see in the previous [filename]#CounterEndpoint.ts# example, the Javadoc for the `@Endpoint` class is copied to the generated TypeScript file, and the type definitions are maintained.
This helps code completion to work, at least in Visual Studio Code and IntelliJ IDEA Ultimate Edition.

.Code Completion in Visual Studio Code
image:images/codecompletion.gif[Code-completion]
