---
title: Clustering Support
order: 20
layout: page
---

[[ce.backend]]
= Implementing support for clustered environments
:experimental:

.Experimental Feature
[IMPORTANT]
====
This is currently considered an experimental feature, which means that its behavior, API, and look and feel might still change.
In order to use the Backend API, it must be explicitly enabled with a feature flag.
See the <<Feature Flag>> section for how to do this.
====

Using Collaboration Engine in an application running in a clustered environment would result in users being able to collaborate only with others connected to the same app instance.
To properly run clustered application deployments, Collaboration Engine provides the [classname]`Backend` superclass that can be extended to support such multi-instance environments.

In this article we will show how to implement a custom backend to support clustering based on the https://hazelcast.com[Hazelcast] platform.

== Understanding the concept of Event Log

A custom [classname]`Backend` implementation is the gateway Collaboration Engine uses to obtain access to Event Logs.
An Event Log is a strictly ordered log of submitted events involving Topic data, such as newly added items or value changes.
The [classname]`EventLog` API provides methods to submit new events to the log and to add a subscriber to receive all past and future events.
All events are marked by a unique identifier and the API provides a method to remove all events in the log before a given identifier.

=== Implementing an Event Log for Hazelcast

Let's start implementing the [classname]`EvengLog` interface for our reference Hazelcast platform.
Hazelcast provides a very straightforward streaming API based on shared maps and lists.
The Event Log can be easily implemented making use of an Hazelcast [classname]`IList`, but first we need a class to store both the event identifier and payload.

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/ce/hazelcast/HazelcastBackend.java[tags=id-payload,indent=0]
----

Once we have that, we can start implementing the interface methods.
The [methodname]`submitEvent` takes the event identifier and payload, so we can simply store them in a new [classname]`IdAndPayload` object and add it to the Hazelcast list for this Event Log.

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/ce/hazelcast/HazelcastBackend.java[tags=event-log;submit-event;!*,indent=0]
----

To implement subscriptions to events, we're going to add an item listener to the Hazelcast list.
The subscriber receives all past and future events for this Event Log.
A newly added subscriber should initially receive all previous event in the log based on their original order so that it can catch up with the latest state.
New events should be delivered (in order) only after all previous events have been delivered.
It is not allowed to invoke the subscriber again until the previous invocation has returned.

The [methodname]`subscribe` method optionally takes the identifier of the last known event, so that only newer events will be notified to the subscriber.
If the provided identifier is provided and not found in the Event Log, a [classname]`EventIdNotFoundException` should be thrown.

.Exception handling
[TIP]
When the exception is caught by the code calling this method, it may want to re-attempt the subscription with another identifier.

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/ce/hazelcast/HazelcastBackend.java[tags=subscribe,indent=0]
----
<1> Only a single subscriber is allowed, so we throw if one's already set.
<2> If an event identifier is provided, we check if it exists in the list otherwise we throw a [classname]`EventIdNotFoundException`.
<3> We add an item listener to the Hazelcast list to handle new items and removed ones.
<4> Then all past events are initially delivered.
<5> Finally we return a [classname]`Registration` that can be used to remove the subscriber.

Let's now dive in into the custom method that effectively deliver the events, the [methodname]`deliverEvents` method.
This is a `synchronized` method to prevent it to be invoked by multiple threads simultaneously and avoid duplicate event to be notified to the subscriber.
The method keeps track of the Hazelcast list index to identify the next event and increments this index until all the events are delivered.
If an event identifier has been set as the starting point, no events are delivered until that identifier is reached.

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/ce/hazelcast/HazelcastBackend.java[tags=deliver-events,indent=0]
----

Finally, the last method to implement for the [classname]`EventLog` interface is the [methodname]`truncate` method.
This method serves the purpose to limit the number of events contained in the log, to avoid it to grow infinitely.
It takes the identifier of the older know event that should be preserved, or—if a null identifier is provided—it empties the whole log.

To implement this behavior for Hazelcast, we create a simple [classname]`Predicate` and pass it to the list [methodname]`removeIf` method.

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/ce/hazelcast/HazelcastBackend.java[tags=truncate,indent=0]
----

== Snapshots

== Membership

== Feature Flag

In order to use the Backend API, it must be explicitly enabled with a feature flag:

1. Create a [filename]#src/main/resources/vaadin-featureflags.properties# file in your application folder
2. Add the following content: `com.vaadin.experimental.collaborationEngineBackend=true`
3. Restart the application.