---
title: Data Binding
page-title: How to bind data to Grid using data providers
description: Binding and displaying data in Grid
order: 50
section-nav: badge-flow
---

= Binding Data to Grid [badge-flow]#Flow#
:toclevels: 2

Grid supports connecting to various types of data sources through data providers. A data provider is a class that implements the [interfacename]`DataProvider` interface and encapsulates the logic for fetching items from a specific data source, with support for pagination, sorting, and filtering. Grid provides convenience methods to simplify common binding cases where a full data provider setup isn't needed, and also supports fully custom data providers for more complex scenarios.

== Binding Items via `setItems`

The `setItems` method in Grid is a convenience API that allows you to bind and display data from in-memory collections and simple lazy-loaded data sources without explicitly creating a data provider. This method offers several overloads for different use cases, returning either a `GridListDataView` or `GridLazyDataView` instance, which you can then use to apply filtering, sorting, and other options to the displayed items.

.Example: Binding a collection of items
[source,java]
----
GridListDataView dataView = grid.setItems(
    new Person("George Washington", 1732),
    new Person("John Adams", 1735),
    new Person("Thomas Jefferson", 1743),
    new Person("James Madison", 1751)
);
----

.Example: Binding items from a data service with lazy loading
[source,java]
----
GridLazyDataView dataView = grid.setItems(
    // Callback for fetching items, returns a Stream<Person>
    query -> personService.fetch(query.getOffset(), query.getLimit()),
    // Callback for counting items, returns an Integer
    query -> personService.count()
);
----

.Example: Filtering and sorting the resulting data view
[source,java]
----
dataView
    .addFilter(person -> person.getAge() >= 18)
    .setSortOrder(Comparator.comparing(Person::getName));
----

For more documentation and examples, see the <<{articles}/flow/binding-data/data-provider#,Binding Items To Components>> article.

== Custom Data Providers

Alternatively, you can provide a custom data provider via the `setDataProvider(DataProvider<T, ?>)` method, passing your own class that implements the [interfacename]`DataProvider` interface.

For convenience, Flow provides an abstract base class `AbstractDataProvider`, which you can extend to create a custom data provider.

[.example]
--

[source,java]
.PersonDataProvider.java
----
public class PersonDataProvider extends AbstractDataProvider<Person, PersonFilter> {
    // In a real application, data would come from a database or backend service.
    // This example uses a static list for demonstration purposes only.
    private final List<Person> DATABASE = Arrays.asList(
            new Person("Michael Chen", "Engineering"),
            new Person("Sarah Johnson", "Engineering"),
            new Person("David Rodriguez", "Marketing"),
            new Person("Emma Wilson", "HR"),
            new Person("James Patterson", "Marketing"));

    @Override
    public boolean isInMemory() {
        return false;
    }

    @Override
    public Stream<Person> fetch(Query<Person, PersonFilter> query) {
        // SQL equivalent: SELECT ... FROM ...
        Stream<Person> stream = DATABASE.stream();

        // SQL equivalent: WHERE ...
        stream = stream.filter(createPredicate(query.getFilter()));

        // SQL equivalent: ORDER BY ...
        stream = stream.sorted(createComparator(query.getSortOrders()));

        // SQL equivalent: OFFSET ... LIMIT ...
        stream = stream.skip(query.getOffset()).limit(query.getLimit());

        return stream;
    }

    @Override
    public int size(Query<Person, PersonFilter> query) {
        // SQL equivalent: SELECT COUNT(*) FROM ...
        Stream<Person> stream = DATABASE.stream();

        // SQL equivalent: WHERE ...
        stream = stream.filter(createPredicate(query.getFilter()));

        return (int) stream.count();
    }

    /**
     * Creates a filter function (predicate) based on the filter object from the Grid.
     *
     * This is for demonstration purposes only. In a real application, you should do
     * filtering in the database query e.g. by using SQL WHERE if you are using a
     * relational database.
     */
    private Predicate<Person> createPredicate(Optional<PersonFilter> filter) {
        return filter.map(f -> (Predicate<Person>) f::test).orElse(p -> true);
    }

    /**
     * Creates a sorting function (comparator) based on the sort orders from the Grid.
     *
     * This is for demonstration purposes only. In a real application, you should do
     * sorting in the database query e.g. by using SQL ORDER BY if you are using a
     * relational database.
     */
    private Comparator<Person> createComparator(List<QuerySortOrder> sortOrders) {
        return sortOrders.stream().map(sortOrder -> {
            Comparator<Person> comparator = switch (sortOrder.getSorted()) {
                case "name" -> Comparator.comparing(Person::name);
                case "department" -> Comparator.comparing(Person::department);
                default -> (p0, p1) -> 0;
            };

            return sortOrder.getDirection().equals(SortDirection.ASCENDING)
                    ? comparator
                    : comparator.reversed();
        }).reduce((p0, p1) -> 0, Comparator::thenComparing);
    }
}
----

[source,java]
.PersonFilter.java
----
public record PersonFilter(String nameFilter, String departmentFilter) {
    public boolean test(Person person) {
        boolean matches = true;
        if (nameFilter != null && !nameFilter.isEmpty()) {
            matches &= person.name().toLowerCase().contains(nameFilter.toLowerCase());
        }
        if (departmentFilter != null && !departmentFilter.isEmpty()) {
            matches &= person.department().equals(departmentFilter);
        }
        return matches;
    }
}
----

[source,java]
.Person.java
----
public record Person(String name, String department) {
}
----

[source,java]
.PeopleView.java
----
public class PeopleView extends VerticalLayout {
    private TextField nameFilter;
    private Select<String> departmentFilter;
    private ConfigurableFilterDataProvider<Person, Void, PersonFilter> dataProvider;

    public PeopleView() {
        Grid<Person> grid = new Grid<>(Person.class);

        // Enable sorting for the columns
        grid.setSortableColumns("name", "department");

        // Create a data provider instance with a configurable filter.
        // The returned wrapper allows setting the filter dynamically
        // using the ConfigurableFilterDataProvider#setFilter() method
        dataProvider = new PersonDataProvider().withConfigurableFilter();
        grid.setDataProvider(dataProvider);

        // Create filter components
        nameFilter = new TextField("Search by name", event -> updateFilter());
        departmentFilter = new Select<>("Department", event -> updateFilter());
        departmentFilter.setItems("", "Engineering", "Marketing", "HR");

        add(nameFilter, departmentFilter, grid);
    }

    private void updateFilter() {
        dataProvider.setFilter(
                new PersonFilter(nameFilter.getValue(), departmentFilter.getValue()));
    }
}
----

--
