---
title: Overview
order: 0
layout: page
---

:vaadin-version: {moduleMavenVersion:com.vaadin:vaadin}
pass:[<!-- vale Vaadin.Versions = NO -->]

= Upgrading From Vaadin 15 To {vaadin-version}

Upgrading from a Vaadin 15+ version to the latest is in general straightforward, nevertheless, a few breaking changes need to take into account when upgrading:

[role="since:com.vaadin:vaadin@V19"]
== Generated @Id Field Is Now Optional In TypeScript
A field with `@Id` annotation in Java is now optional in the generated TypeScript code. 
Given an entity with an `id` field:

.Entity.java
[source,java]
----
public class Entity {
    @Id
    private int id;
}
----

Now in the TypeScript files, instead of using `endpoint.getEntity(entity.id)`, you might need to change to `endpoint.getEntity(entity.id!)` or `endpoint.getEntity(entity.id?)`.

== Spring Security

The Spring Security configuration requires some changes for the service worker related files.

[role="since:com.vaadin:vaadin@V19"]
=== Ignore One More Service Worker Related Static File
You need to ignore one more static file `/sw-runtime-resources-precache.js` if you use `HttpSecurity.authorizeRequests()` to do role-based authorization in your security configuration as follows:

.SecurityConfiguration.java
[source,java]
----
@Override
protected void configure(HttpSecurity http) throws Exception {
    ...
    http.authorizeRequests().anyRequest().hasAnyAuthority(Role.getAllRoles());
    ...
}
----

In such case you would have configured Spring Security to bypass the static resources as below:

.SecurityConfiguration.java
[source,java]
----
@Override
public void configure(WebSecurity web) {
    web.ignoring().antMatchers(
            // client-side JS code
            "/VAADIN/**",
            ...
            // web application manifest
            "/manifest.webmanifest",
            "/sw.js",
            "/offline-page.html",
            ...
    );
}
----

You need to add one more file `/sw-runtime-resources-precache.js` to the list:

.SecurityConfiguration.java
[source,java]
----
@Override
public void configure(WebSecurity web) {
    web.ignoring().antMatchers(
            // client-side JS code
            "/VAADIN/**",
            ...
            // web application manifest
            "/manifest.webmanifest",
            "/sw.js",
            "/offline-page.html",
            "/sw-runtime-resources-precache.js",
            ...
    );
}
----


[role="since:com.vaadin:vaadin@V19"]
=== Ignore the Service Worker Initiated Requests
Another potential Spring Security related breaking change is about using `HttpSecurity.requestCache()` to redirect the user to the intended page after login. 

An example of using `HttpSecurity.requestCache()`:

.SecurityConfiguration.java
[source,java]
----
@Override
protected void configure(HttpSecurity http) throws Exception {
    ...
    http

    // Register our CustomRequestCache, that saves unauthorized access attempts, so
    // the user is redirected after login.
    .requestCache().requestCache(new CustomRequestCache())
    
    // Restrict access to our application.
    .and().authorizeRequests()

    // Allow all flow internal requests.
    .requestMatchers(SecurityUtils::isFrameworkInternalRequest).permitAll()
    ...
}
----

Now you need to ignore the service worker initiated requests, otherwise the access attempts will be overridden by the service worker requests and Spring cannot redirect you to the intended page. 

The `SecurityUtils::isFrameworkInternalRequest()` can be updated as follows to also include the service worker initiated requests:

.SecurityUtils.java
[source,java]
----
static boolean isFrameworkInternalRequest(HttpServletRequest request) {
    final String parameterValue = request
        .getParameter(ApplicationConstants.REQUEST_TYPE_PARAMETER);
    // Use Referer in header to check if it is a sevice worker
    // initiated request
    String referer = request.getHeader("Referer");
    boolean isServiceWorkInitiated = (referer != null && referer.endsWith("sw.js"));
    return isServiceWorkInitiated 
            || parameterValue != null
            && Stream.of(RequestType.values())
                .anyMatch(r -> r.getIdentifier().equals(parameterValue));
}
----
