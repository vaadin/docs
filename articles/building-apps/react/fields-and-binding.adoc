---
title: Hilla
page-title: How to use fields and data binding in Hilla | Vaadin
meta-description: Learn how to build forms in Vaadin Hilla using layout components, input fields, and the useForm hook to bind data with Java-based FDOs.
order: 10
---


= Fields and Binding in Hilla
:toclevels: 2


This guide introduces the fundamentals of building forms and binding fields in Hilla. It covers how to lay out form fields, choose the appropriate input components, and use the `useForm` hook to connect those components to your application's data model. For more in-depth information about forms in Hilla, see the <<{articles}/hilla/guides/forms#,Hilla Reference Guide>>.

.Part of a Series
[TIP]
This is part 1 of the *Add a Form* series. You should also read the <<.#,Overview>>.


== Laying Out the Fields

In Hilla, you build forms visually by *adding input components to a layout component*. The most common layout components for forms are <</components/form-layout#,Form Layout>>, <</components/vertical-layout#,Vertical Layout>>, and an ordinary `<div>` (with some CSS). The Form Layout component supports multiple columns, whereas Vertical Layout lays out the components in a single column.

.Layout or <div>?
[TIP]
If you are used to working with Flow, you can continue to work with the familiar layout components in Hilla. If you have a background in React or some other client-side framework, you may feel more comfortable working with `<div>`.

The following example shows how to build a two-column project proposal form with various input components:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
import ProposalType from "Frontend/generated/com/example/application/domain/ProposalType";

export default function ProposalForm() {
    return (
        <FormLayout>
            <TextField label="Title"/>
            <ComboBox label="Proposal Type" items={Object.values(ProposalType)}/> {/* <1> */}
            <TextArea label="Description" data-colspan="2"/> {/* <2> */}
            <DatePicker label="Start Date"/>
            <DatePicker label="End Date"/>
        </FormLayout>
    );
}
----
<1> `ProposalType` is an `enum` in this example.
<2> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::../images/example-form.png[A screenshot of a form]

Form Layout is responsive -- when space is limited, it automatically adjusts to a single-column layout, placing each input on its own row. It also includes additional features not covered in this example. For
more information see the <<{articles}/components/form-layout#,Form Layout>> documentation.


== Common Field Components

Vaadin provides a set of *built-in field components* that you can use in your forms:

* *Text Input Components*
  - <<{articles}/components/text-field#,Text Field>> -- For standard single-line text input
  - <<{articles}/components/text-area#,Text Area>> -- For multi-line text input
  - <<{articles}/components/email-field#,Email Field>> -- Specialized field for email addresses
  - <<{articles}/components/password-field#,Password Field>> - Secure field for password entry
  - <<{articles}/components/rich-text-editor#,Rich Text Editor>> - Advanced text editing with formatting options
* *Selection Components*
  - <<{articles}/components/checkbox#,Checkbox>> -- For binary (true/false) selections
  - <<{articles}/components/radio-button#,Radio Button Group>> -- For selecting a single option from a visible list
  - <<{articles}/components/combo-box#,Combo Box>> -- Drop-down for selecting a single option
  - <<{articles}/components/multi-select-combo-box#,Multi-Select Combo Box>> -- Drop-down for selecting multiple options
  - <<{articles}/components/select#,Select>> -- Simple drop-down menu
  - <<{articles}/components/list-box#,List Box>> -- Scrollable list of options
* *Date and Time Components*
  - <<{articles}/components/date-picker#,Date Picker>> -- For selecting a date
  - <<{articles}/components/time-picker#,Time Picker>> -- For selecting a time
  - <<{articles}/components/date-time-picker#,Date Time Picker>> -- For selecting both date and time
* *Numeric Components*
  - <<{articles}/components/number-field#,Number Field>> -- For numeric input


== FDOs and Form Models

In Hilla, FDOs are fetched from and submitted to a *browser-callable application service* for further processing. 
FDOs are implemented in Java, typically as records, although JavaBeans are also possible. 

Hilla automatically *generates the necessary TypeScript interfaces* and handles the serialization between Java and JSON. Hilla also generates a *form model*, which is a description of the FDO in TypeScript. This form model is then used by the Hilla binder.

Continuing with the earlier *Project Proposal* form example, you can create a record to represent the FDO:

[source,java]
----
public record Proposal(
    @Nullable Long proposalId,
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

To get Hilla to find this FDO, you have to create a browser-callable service that either returns it or accepts it as a parameter:

[source,java]
----
@BrowserCallable
@AnonymousAllowed
public class ProposalService {

    public void save(Proposal proposal) {
        // Will be implemented later
    }
}
----

For more information about browser-callable services, see the <<../../../business-logic/add-service#,Add a Service>> guide.


== The `useForm` Hook

Hilla provides a `useForm` hook that binds fields to form model properties, ensuring that changes made in the form update the FDO. When you implement your form as its own component, you should initialize it outside the form and pass the result in as a prop.

For example, here is a form component that accepts the result of `useForm` as a required prop:

.ProposalForm.tsx
[source,tsx]
----
import { UseFormResult } from "@vaadin/hilla-react-form";
import ProposalModel from "Frontend/generated/com/example/application/tutorial/service/ProposalModel";
// (Other imports omitted for brevity)

export type ProposalFormProps = {
    form: UseFormResult<ProposalModel> // <1>
}

export default function ProposalForm({form}: ProposalFormProps) {
    return (
        <FormLayout>
            ...
        </FormLayout>
    );
}
----
<1> `ProposalModel` is a Hilla form model generated from the `Proposal` FDO.

A parent component that uses the form could look something like this:

.ProposalDrawer.tsx
[source,tsx]
----
import { useForm } from "@vaadin/hilla-react-form";
// (Other imports omitted for brevity)

export default function ProposalDrawer() {
    const form = useForm(ProposalModel);
    return (
        <section>
            <h2>Edit Proposal</h2>
            <ProposalForm form={form}/>
        </section>
    );
}
----

== Binding Fields

To bind a field to a form model property, use the `field` method from the `useForm` hook. This method generates an object containing all necessary props (like value, event handlers, and validation state) for the field component. You then use React's spread syntax (`{...}`) to apply these props to the component.

When using the `field()` method, you need to specify which property from the form model you want to bind by passing it as an argument. These properties are available in the `model` object returned by the `useForm` hook.

Here is an example that binds each field in the project proposal form to the corresponding form model property:

.ProposalForm.tsx
[source,tsx]
----
// (Imports omitted for brevity)

export type ProposalFormProps = {
    form: UseFormResult<ProposalModel>
}

export default function ProposalForm({form}: ProposalFormProps) {
    return (
        <FormLayout>
            <TextField label="Title" 
                       {...form.field(form.model.title)}/>
            <ComboBox label="Proposal Type" 
                      items={Object.values(ProposalType)} 
                      {...form.field(form.model.type)}/>
            <TextArea label="Description" 
                      data-colspan="2" 
                      {...form.field(form.model.description)}/>
            <DatePicker label="Start Date" 
                        {...form.field(form.model.startDate)}/>
            <DatePicker label="End Date" 
                        {...form.field(form.model.endDate)}/>
        </FormLayout>
    );
}
----


== Accessing the FDO

To access the FDO itself, use the `value` variable returned by the `useForm` hook:

[source,java]
----
const form = useForm(ProposalModel);

useEffect(() => {
    // Do something whenever the user selects a different type.
}, [form.value.type]);
----

In the example above, `value` is an instance of type `Proposal`. Hilla makes sure the FDO and the form are always in sync.

[NOTE]
In Hilla, there is always an FDO. If you haven't initialized your form with an existing FDO, Hilla creates a new, empty one.

== Clearing the Form

To clear the form, the `useForm` hook provides a `clear()` method:

.ProposalDrawer.tsx
[source,tsx]
----
// (Imports omitted for brevity)

export default function ProposalDrawer() {
    const form = useForm(ProposalModel);
    return (
        <section>
            <h2>Edit Proposal</h2>
            <ProposalForm form={form}/>
            <Button onClick={form.clear}>Clear Form</Button>
        </section>
    );
}
----

Clearing the form also clears the FDO, including unbound properties.


== Reading from an FDO

To populate a form with data from an existing FDO, the `useForm` hook provides a `read()` method:

.ProposalDrawer.tsx
[source,tsx]
----
// (Imports omitted for brevity)

export type ProposalDrawerProps = {
    proposal?: Proposal
}

export default function ProposalDrawer({proposal}: ProposalDrawerProps) {
    const form = useForm(ProposalModel);

    useEffect(() => {
        form.read(proposal);
    }, [proposal]);

    return (
        <section>
            <h2>Edit Proposal</h2>
            <ProposalForm form={form}/>
        </section>
    );
}
----

Reading an `undefined` or `null` value clears the form.
