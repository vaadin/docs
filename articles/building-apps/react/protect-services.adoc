---
title: Hilla
page-title: How to protect browser callable services in a Vaadin application
meta-description: Secure browser-callable services in Hilla with this guide - authentication, authorization, and best practices for protecting services.
order: 10
---


= Protect Browser-Callable Services
:toclevels: 2

// This assumes @BrowserCallable services have been covered somewhere else
In a Vaadin application using Hilla views, securing [annotationname]`@BrowserCallable` services is crucial to prevent unauthorized access. In this guide, you'll learn how to control access to specific browser-callable services.

.Browser-callable services don't use Spring method security
[CAUTION]
Vaadin handles the protection of browser-callable services *outside Spring Security*. This means that if you inject a browser-callable service into another Java service or Flow view, it *will not be protected by default*.


== Securing the Services

Vaadin protects browser-callable services in the same way as it protects <<../protect-views/flow#,Flow views>> -- with annotations.

[IMPORTANT]
All browser-callable services are *inaccessible by default* and require explicit annotations to grant access.

You can annotate both *service classes* and individual *service methods*. An annotation placed on the class applies to *all public methods* of the class. An annotation placed on a method *overrides any annotation on the class*.

The following annotations are supported:

* [annotationname]`@AnonymousAllowed` allows access to *unauthenticated* users.
* [annotationname]`@PermitAll` allows any *authenticated* user to call the service or method.
* [annotationname]`@RolesAllowed` allows users *having the roles* specified in the annotation value to call the service or method.
* [annotationname]`@DenyAll` prevents *everyone* from calling the service or method.

[NOTE]
The [annotationname]`@AnonymousAllowed` annotation is a Vaadin-specific annotation; the others are Jakarta annotations (JSR-250).

The following example uses [annotationname]`@AnonymousAllowed` to allow *all users* -- both authenticated and unauthenticated -- to call the service:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@AnonymousAllowed
// end::snippet[]
public class PublicService {

    public void doSomething() {
        //...
    }
}
----

The following example combines [annotationname]`@PermitAll` and [annotationname]`@RolesAllowed` to allow *all authenticated users* to call the service, except for one method that can be called only by *administrators*:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@PermitAll
// end::snippet[]
public class ProtectedService {

    public void callableByAllUsers() { // <1>
    }

// tag::snippet[]
    @RolesAllowed(Roles.ADMIN) // <2>
// end::snippet[]
    public void callableByAdminsOnly() {
    }
}
----
<1> Inherits its access permissions from the [annotationname]`@PermitAll` annotation on the class.
<2> Overrides the [annotationname]`@PermitAll` annotation on the class, limiting the access.

You can also do the other way around. This example allows *only administrators* to call the service, except for one method that can be called by *all authenticated users*:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@RolesAllowed(Roles.ADMIN)
// end::snippet[]
public class ProtectedService {

// tag::snippet[]
    @PermitAll
// end::snippet[]
    public void callableByAllUsers() {
    }

    public void callableByAdminsOnly() {
    }
}
----


== Using Spring Method Security for Browser-Callable Services

<<flow#,Flow services>> are protected by Spring method security. If you have a *protected Flow service* that you want to *make available for Hilla views*, you can do that with some tweaking.

[NOTE]
The following assumes you have already set up Spring method security. For details, see the <<flow#,Protect Flow Services>> guide.

By default, requests coming in from the browser are denied by Vaadin before the service is even called. This applies even when the service is proxied and protected by Spring Security.

To *bypass Vaadin's security check and rely on Spring Security instead*, you have to add [annotationname]`@AnonymousAllowed` to the service, like this:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@AnonymousAllowed // <1>
@PreAuthorize("isAuthenticated()") // <2>
// end::snippet[]
public class ProtectedService {

    public MyData callableByAllUsers() {
    }

// tag::snippet[]
    @PreAuthorize("hasRole('" + Roles.ADMIN + "')")
// end::snippet[]
    public void callableByAdminsOnly(MyData data) {
    }
}
----
<1> Bypass Vaadin's security check.
<2> Enable Spring method security instead.

[NOTE]
Better support for Spring Security is planned for a future version of Vaadin Hilla. See https://github.com/vaadin/hilla/issues/3271[this ticket] for more information.

.Don't configure Spring Security to use JSR-250 annotations
[WARNING]
Spring method security has support for the JSR-250 annotations that Vaadin uses to protect browser-callable services. However, *Vaadin treats [annotationname]`@PermitAll` differently than Spring Security*. Whereas Vaadin allows access to _authenticated_ users only, Spring Security allows access to _all_ users.

