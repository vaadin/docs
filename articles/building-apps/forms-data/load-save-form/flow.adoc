---
title: Flow
page-title: TODO Write page-title
description: TODO Write description
meta-description: TODO Write meta-description
order: 5
---


= Load and Save a Form in Flow
:toclevels: 2

In this guide, you'll learn how to design an application service for loading and saving a form model in Flow. You'll also learn how to integrate this services into your form.


== Application Service Design

Vaadin applications use an <<../../business-logic/add-service#,application service>> to load and save form models. The application service's API depends on several aspects:

* the choice of JavaBean or record as a form model
* whether you're using entities or dedicated classes as form models
* entity ID assignment strategy
* how you store the entities in a database

This section covers the basics of designing an application service for loading and saving a JavaBean form model, and a record form model, respectively. The implementation of the service is not covered in this guide, but it assumes an unsaved form model lacks an ID, whereas an existing form model has an ID.


=== Using JavaBean Form Models

A JavaBean form model typically contains the ID of the corresponding entity. If unsaved, this ID is `null`. Because of this, you can use a single `save()` method instead of separate `insert()` and `update()` methods. The implementation should check whether the ID exists to decide whether to perform an update or an insert.

You also need a method for retrieving a form model by its corresponding entity ID. This method should return an empty `Optional` if the entity does not exist.

This is an example of an application service that retrieves and saves a `ProposalBean` form model:

.ProposalService.java
[source,java]
----
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW) // <1>
// Security annotations omitted
public class ProposalService {

    public Optional<ProposalBean> findById(long proposalId) {
        // ...
    }

    public ProposalBean save(ProposalBean proposal) {
        // ...
    }
}
----
<1> Always use transactions when saving and loading data.

Ideally, the `save()` method returns an instance of the form model. This allows the service implementation to either set the ID directly on the original form model object, or return a new object with the ID.

[NOTE]
This approach also works when you use the entity itself as a form model.


=== Using Record Form Models

Record form models require binding every record component to a field. This presents challenges with IDs, as they are typically not bound. To work around this limitation, you can create another record that wraps the form model and includes the ID. The wrapper record can also include other meta-data like an optimistic locking version number, last modified timestamp, and so on.

In the following example, `ProposalRecord` is the form model:

.PersistentProposalRecord.java
[source,java]
----
public record PersistentProposalRecord(
    long proposalId,
    ProposalRecord data
) {    
    public PersistentProposalRecord withData(ProposalRecord data) { // <1>
        return new PersistentProposalRecord(proposalId, data);
    }
}
----
<1> Helper method that makes it easier to perform updates.

Separate `insert()` and `update()` methods are appropriate due to distinct data types used for saved versus unsaved records. You also need a method for retrieving a form model by its corresponding entity ID. 

Here is an example of an application service with the three methods:

.ProposalService.java
[source,java]
----
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
// Security annotations omitted
public class ProposalService {

    public Optional<PersistentProposalRecord> findById(long proposalId) {
        // ...
    }

    public PersistentProposalRecord insert(ProposalRecord proposal) {
        // ...
    }

    public PersistentProposalRecord update(PersistentProposalRecord proposal) {
        // ...
    }
}
----

Both `insert()` and `update()` return new instances of `PersistentProposalRecord`, allowing them to return updated meta-data to the UI.


== Loading a Form

Separating form implementation from application service interaction helps in reusing forms across different scenarios. For example, you might want to use a dialog for adding new items, and a drawer for editing existing items, while still using the same form.

Loading existing data involves handling situations where data may not exist. Sometimes, you may want to show an error message:

[source,java]
----
private final ProposalService service;
// ...

public void editProposal(long proposalId) {
    service.findById(proposalId).ifPresentOrElse(
        this::editProposal, 
        this::showProposalNotFound
    );
}

private void editProposal(Proposal proposal) {
    // ...
}

private void showProposalNotFound() {
    // ...
}
----

Other times, you may want to show the form for adding a new item:

[source,java]
----
private final ProposalService service;
// ...

public void editProposal(long proposalId) {
    service.findById(proposalId).ifPresentOrElse(
        this::editProposal, 
        this::newProposal
    );
}

private void editProposal(Proposal proposal) {
    // ...
}

private void newProposal() {
    // ...
}
----

The code is easier to read if you design the methods so that they can be passed as method references to the `Optional` returned by the application service.


=== Using JavaBean Form Models 

In *buffered mode*, you use the form model to populate the form with existing data. Since the form model also contains the ID, you should store it in a local field for future reference, as demonstrated in the following example:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private ProposalBean proposal;
// end::snippet[]
// ...

private void editProposal(ProposalBean proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.read(proposal);
// end::snippet[]
    title.setText("Edit Proposal");
}

private void newProposal() {
// tag::snippet[]
    this.proposal = new ProposalBean(); // <1>
    form.clear();
// end::snippet[]
    title.setText("New Proposal");
}
----
<1> Storing an empty `ProposalBean` instead of `null` makes the code for saving the form simpler.

*Write-through mode* requires a form model for both existing data and creating new entries. Again, since the form model contains the ID, you should store it in a local field:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private ProposalBean proposal;
// end::snippet[]
// ...

private void editProposal(ProposalBean proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.bind(proposal);
// end::snippet[]
    if (proposal.getProposalId() == null) {
        title.setText("New Proposal");
    } else {
        title.setText("Edit Proposal");
    }
}

private void newProposal() {
    editProposal(new ProposalBean());
}
----


=== Using Record Form Models

For record form models, you need to store the wrapper record in a local field to access its ID:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private PersistentProposalRecord proposal;
// end::snippet[]
// ...

private void editProposal(PersistentProposalRecord proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.read(proposal.data());
// end::snippet[]
    title.setText("Edit Proposal");
}

private void newProposal() {
// tag::snippet[]
    this.proposal = null; // <1>
    form.clear();
// end::snippet[]
    title.setText("New Proposal");
}
----
<1> As the wrapper ID cannot have a `null` ID, you have to set the local field to `null` when adding new items.


== Saving a Form

Saving forms typically follows the same pattern regardless of the form model:

1. Validate the form.
2. Update the form model.
3. Call the application service to save the form model.
4. Re-initialize the form with the form model returned by the service.


=== Using JavaBean Form Models

In *buffered mode*, the form explicitly updates the form model. This operation includes validation, as explained in the <<../add-form/flow#writing-to-a-bean,Add a Form>> guide:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private ProposalBean proposal;
// ...

private void saveProposal() {
    if (form.write(proposal)) { // <1>
        var savedProposal = service.save(proposal);
        editProposal(savedProposal);
    }
}
----
<1> Validates the form and updates the form model if successful.

In *write-through mode*, only validation is necessary before calling the application service:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private ProposalBean proposal;
// ...

private void saveProposal() {
    if (form.isValid()) {
        var savedProposal = service.save(proposal);
        editProposal(savedProposal);
    }
}
----


=== Using Record Form Models

For record form models, the save operation distinguishes between inserts and updates:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private PersistentProposalRecord proposal;
// ...

private void saveProposal() {
    form.write() // <1>
        .ifPresent(formModel -> { 
            if (proposal == null) {
                editProposal(service.insert(formModel));
            } else {
                editProposal(service.update(proposal.withData(formModel)));
            }
        });
}
----
<1> Validates the form and returns a new form model record if successful.

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.
