---
title: Flow
page-title: TODO Write page-title
meta-description: TODO Write meta-description
order: 5
---


= Load and Save a Form in Flow
:toclevels: 2

In this guide, you'll learn how to design an application service for loading and saving a Form Data Object (FDO) in Flow. You'll also learn how to integrate this services into your form. Application services are covered in more detail in the <<../../business-logic/add-service#,Add a Service>> guide.


== Application Service Design

Vaadin applications use an application service to load and save FDOs. The application service's API depends on several aspects:

* the choice of JavaBean or record as an FDO
* whether you're using entities or dedicated classes as FDOs
* entity ID assignment strategy
* how you store the entities in a database
* what your UI does after it has saved an FDO

This section covers the basics of designing an application service for loading and saving a JavaBean FDO, and a record FDO, respectively. The implementation of the service is not covered in this guide, but it assumes an unsaved FDO lacks an ID, whereas an existing FDO has an ID.


=== Using JavaBean FDOs

A JavaBean FDO typically contains the ID of the corresponding entity. If unsaved, this ID is `null`. Because of this, you can use a single `save()` method instead of separate `insert()` and `update()` methods. The implementation should check whether the ID exists to decide whether to perform an update or an insert.

You also need a method for retrieving an FDO by its corresponding entity ID. This method should return an empty `Optional` if the entity does not exist.

This is an example of an application service that retrieves and saves a `ProposalBean` FDO:

.ProposalService.java
[source,java]
----
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW) // <1>
// Security annotations omitted
public class ProposalService {

    public Optional<ProposalBean> findById(long proposalId) {
        // ...
    }

    public ProposalBean save(ProposalBean proposal) {
        // ...
    }
}
----
<1> Always use transactions when saving and loading data.

Ideally, the `save()` method returns an instance of the FDO. This allows the service implementation to either set the ID directly on the original FDO, or return a new FDO with the ID.

[NOTE]
This approach also works when you use the entity itself as an FDO.


=== Using Record FDOs

Record FDOs require binding every record component to a field. This presents challenges with IDs, as they are typically not bound. To work around this limitation, you can create another record that wraps the FDO and includes the ID. The wrapper record can also include other meta-data like an optimistic locking version number, last modified timestamp, and so on.

In the following example, `ProposalRecord` is the FDO:

.PersistentProposalRecord.java
[source,java]
----
public record PersistentProposalRecord(
    long proposalId,
    ProposalRecord data
) {    
    public PersistentProposalRecord withData(ProposalRecord data) { // <1>
        return new PersistentProposalRecord(proposalId, data);
    }
}
----
<1> Helper method that makes it easier to perform updates.

Separate `insert()` and `update()` methods are appropriate due to distinct data types used for saved versus unsaved records. You also need a method for retrieving an FDO by its corresponding entity ID. 

Here is an example of an application service with the three methods:

.ProposalService.java
[source,java]
----
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
// Security annotations omitted
public class ProposalService {

    public Optional<PersistentProposalRecord> findById(long proposalId) {
        // ...
    }

    public PersistentProposalRecord insert(ProposalRecord proposal) {
        // ...
    }

    public PersistentProposalRecord update(PersistentProposalRecord proposal) {
        // ...
    }
}
----

Both `insert()` and `update()` return new instances of `PersistentProposalRecord`, allowing them to return updated meta-data to the UI.


== Loading a Form

Separating form implementation from application service interaction helps in reusing forms across different scenarios. For example, you might want to use a dialog for adding new items, and a drawer for editing existing items, while still using the same form.

Loading existing data involves handling situations where data may not exist. Sometimes, you may want to show an error message:

[source,java]
----
private final ProposalService service;
// ...

public void editProposal(long proposalId) {
    service.findById(proposalId).ifPresentOrElse(
        this::editProposal, 
        this::showProposalNotFound
    );
}

private void editProposal(Proposal proposal) {
    // ...
}

private void showProposalNotFound() {
    // ...
}
----

Other times, you may want to show the form for adding a new item:

[source,java]
----
private final ProposalService service;
// ...

public void editProposal(long proposalId) {
    service.findById(proposalId).ifPresentOrElse(
        this::editProposal, 
        this::newProposal
    );
}

private void editProposal(Proposal proposal) {
    // ...
}

private void newProposal() {
    // ...
}
----

The code is easier to read if you design the methods so that they can be passed as method references to the `Optional` returned by the application service.


=== Using JavaBean FDOs

In *buffered mode*, you use the FDO to populate the form with existing data. Since the FDO also contains the ID, you should store it in a local field for future reference, as demonstrated in the following example:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private ProposalBean proposal;
// end::snippet[]
// ...

private void editProposal(ProposalBean proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.read(proposal);
// end::snippet[]
    title.setText("Edit Proposal");
}

private void newProposal() {
// tag::snippet[]
    this.proposal = new ProposalBean(); // <1>
    form.clear();
// end::snippet[]
    title.setText("New Proposal");
}
----
<1> Storing an empty `ProposalBean` instead of `null` makes the code for saving the form simpler.

*Write-through mode* requires an FDO for both existing data and creating new entries. Again, since the FDO contains the ID, you should store it in a local field:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private ProposalBean proposal;
// end::snippet[]
// ...

private void editProposal(ProposalBean proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.bind(proposal);
// end::snippet[]
    if (proposal.getProposalId() == null) {
        title.setText("New Proposal");
    } else {
        title.setText("Edit Proposal");
    }
}

private void newProposal() {
    editProposal(new ProposalBean());
}
----


=== Using Record FDOs

For record FDOs, you need to store the wrapper record in a local field to access its ID:

[source,java]
----
private final ProposalForm form;
private final H1 title;
// tag::snippet[]
private PersistentProposalRecord proposal;
// end::snippet[]
// ...

private void editProposal(PersistentProposalRecord proposal) {
// tag::snippet[]
    this.proposal = proposal;
    form.read(proposal.data());
// end::snippet[]
    title.setText("Edit Proposal");
}

private void newProposal() {
// tag::snippet[]
    this.proposal = null; // <1>
    form.clear();
// end::snippet[]
    title.setText("New Proposal");
}
----
<1> As the wrapper ID cannot have a `null` ID, you have to set the local field to `null` when adding new items.


== Saving a Form

Saving forms typically follows the same pattern regardless of the FDO:

1. Validate the form.
2. Update the FDO.
3. Call the application service to save the FDO.
4. Re-initialize the form with the FDO returned by the service.


=== Using JavaBean FDOs

In *buffered mode*, the form explicitly updates the FDO. This operation includes validation, as explained in the <<../add-form/flow#writing-to-a-bean,Add a Form>> guide:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private ProposalBean proposal;
// ...

private void saveProposal() {
    if (form.write(proposal)) { // <1>
        var savedProposal = service.save(proposal);
        editProposal(savedProposal);
    }
}
----
<1> Validates the form and updates the FDO if successful.

In *write-through mode*, only validation is necessary before calling the application service:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private ProposalBean proposal;
// ...

private void saveProposal() {
    if (form.isValid()) {
        var savedProposal = service.save(proposal);
        editProposal(savedProposal);
    }
}
----


=== Using Record FDOs

For record FDOs, the save operation distinguishes between inserts and updates:

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private PersistentProposalRecord proposal;
// ...

private void saveProposal() {
    form.write() // <1>
        .ifPresent(formDataObject -> { 
            if (proposal == null) {
                editProposal(service.insert(formDataObject));
            } else {
                editProposal(service.update(proposal.withData(formDataObject)));
            }
        });
}
----
<1> Validates the form and returns a new FDO record if successful.

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.
