---
title: Flow
page-title: TODO Write page-title
description: TODO Write description
meta-description: TODO Write meta-description
order: 5
---


= Load and Save a Form in Flow
:toclevels: 2

INTRO HERE


== Buffered Mode

The most straight forward way of working with a form in Flow is to use the `Binder` in _buffered mode_. This means that you have to explicitly call a method on the binder to write the data from the form back to form model. The changes are "buffered" in the form until it is time to write them to the form model.

// TODO Why is this recommended?



=== Reading from a JavaBean

To populate a form with data from a JavaBean, use [methodname]`Binder.readBean()`:

[source,java]
----
@Route
public class ProposalFormView extends VerticalLayout {

    private final Binder<ProposalBean> binder;
 
    public ProposalFormView() {
        // Constructor implementation omitted for clarity
    }

// tag::snippet[]
    private void readForm(ProposalBean formModel) {
        binder.readBean(formModel);
    }
// end::snippet[]
}
----


=== Reading from a Record

To populate a form with data from a record, use [methodname]`Binder.readRecord()`:

[source,java]
----
@Route
public class ProposalFormView extends VerticalLayout {

    private final Binder<ProposalRecord> binder;
 
    public ProposalFormView() {
        // Constructor implementation omitted for clarity
    }

// tag::snippet[]
    private void readForm(ProposalRecord formModel) {
        binder.readRecord(formModel);
    }
// end::snippet[]
}
----

=== Writing to a JavaBean

Over the years, several methods of writing data back to a JavaBean has been added to the `Binder`:

[methodname]`writeBean()` :: Writes all form fields to the JavaBean if _all_ validators -- both field and bean level -- pass. If any validator fails, the method throws a `ValidationException`, without updating the bean.

[methodname]`writeBeanAsDraft()` :: Writes _valid_ form fields to the JavaBean, ignoring any invalid fields. This method does not run any bean-level validators.

[methodname]`writeBeanIfValid()` :: Writes all form fields to the JavaBean and returns `true` if _all_ validators -- both field and bean level -- pass. If any validator fails, the method returns `false`, without updating the bean.

[methodname]`writeChangedBindingsToBean()` :: Writes only the form fields that have been modified to the JavaBean if _all validators_ -- both field and bean level -- pass. If any validator fails, the method throws a `ValidationException`, without updating the bean.

[IMPORTANT]
The methods implement bean-level validation by first writing the changes to the JavaBean, then running the validators. If any validator fails, the changes are reverted. Any extra business logic in the setters of the JavaBean must take this into account.

// TODO Which options should we recommend? What kind of example should we include?

=== Writing to a Record


== Write-through Mode


== Application Service Design



=== Using JavaBean Form Models

.ProposalService.java
[source,java]
----
public interface ProposalService {

    Optional<ProposalBean> findById(long proposalId); // <1>

    ProposalBean save(ProposalBean proposal); // <2>
}
----
<1> Foo
<2> Bar


=== Using Record Form Models

.PersistentProposalRecord.java
[source,java]
----
public record PersistentProposalRecord(
    long proposalId, // <1>
    ProposalRecord data // <2>
) {    
}
----
<1> Foo
<2> Bar


.ProposalService.java
[source,java]
----
public interface ProposalService {

    Optional<PersistentProposalRecord> findById(long proposalId); // <1>

    PersistentProposalRecord insert(ProposalRecord proposal); // <2>

    PersistentProposalRecord update(PersistentProposalRecord proposal); // <3>
}
----
<1> Foo
<2> Bar


== Application Service Interaction

=== Using JavaBean Form Models

=== Using Record Form Models

[source,java]
----
@Route
public class ProposalFormView extends VerticalLayout 
// tag::snippet[]
        implements HasUrlParameter<Long> {
// end::snippet[]

    private final ProposalService proposalService;
    private final Binder<ProposalRecord> binder;
// tag::snippet[]
    private Long proposalId;
// end::snippet[]

    public ProposalFormView(ProposalService proposalService) {
        this.proposalService = proposalService;
        // The rest of the constructor omitted for clarity
        // ...
    }

// tag::snippet[]
    private void editProposal(PersistentProposalRecord proposal) {
        this.proposalId = proposal.proposalId();
        binder.readRecord(proposal.data());
        // Perform any other operations such as updating the view title
    }
// end::snippet[]

// tag::snippet[]
    private void createProposal() {
        this.proposalId = null;
        binder.refreshFields();
        // Perform any other operations such as updating the view title
    }
// end::snippet[]

    private void saveProposal() {
        try {
            var data = binder.writeRecord();
            
        } catch (ValidationException ex) {
            // Handle the exception or rely on the field validation errors
        }
    }

// tag::snippet[]
    @Override
    public void setParameter(BeforeEvent beforeEvent, 
            @OptionalParameter Long propsalId) {
        Optional.ofNullable(proposalId)
                .flatMap(proposalService::findById)
                .ifPresentOrElse(this::editProposal, this::createProposal);
    }
// end::snippet[]
}
----

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.