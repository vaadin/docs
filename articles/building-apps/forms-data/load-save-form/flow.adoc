---
title: Flow
page-title: How to load and save a form in Flow | Vaadin
meta-description: Learn how to load and save forms in Vaadin Flow using either in-memory selection or service-based fetching, and handle both single or split save operations.
order: 5
---


= Load and Save a Form in Flow
:toclevels: 2

This guide covers two core tasks in Vaadin Flow: loading a form with a Form Data Object (FDO), and saving it back to an application service. You'll explore two common loading strategies — *Load from Selection* and *Fetch and Load* — as well as different save strategies, including single-save and sinsert/update operations.


== Loading a Form

There are two common approaches to loading forms in a Vaadin application, each suited to different use cases.

* *Load from Selection* -- A UI component, such as a grid, displays a list of FDOs. When the user selects an item, the form is populated directly with the selected object.
* *Fetch and Load* -- The application receives the ID of the FDO to edit, either through a method call or a <<../../views/pass-data#,URL parameter>>. It then fetches the object from an application service before populating the form.


=== Load from Selection

This approach is straightforward and requires no extra service call. However, this can result in “stale data,” where the grid *displays values that appear saved but haven't been persisted* to the backend. Stale data can occur when the following conditions are met:

* The FDOs are mutable,
* Your form uses *write-through mode*, and
* The user cancels or gets an error when trying to save.

The stale FDO remains in memory until you refresh the grid. To avoid this, you should do one of the following:

* Use immutable FDOs.
* Use *buffered mode* in your form. This ensures no data is written to the FDO until the user saves the form. However, it can *still lead to stale data if the save operation itself fails*.
* Copy the FDO before passing it to the form. Copying ensures that the original object shown in the grid remains unchanged if the user cancels or validation fails.
* Refresh the grid both after saving and canceling. This replaces any stale objects with fresh ones.

Here's an example of the Fetch and Load approach in practice:

[source,java]
----
@Route("proposals")
public class ProposalView extends Main {
    private final Grid<Proposal> grid;
    private final ProposalForm form;

    public ProposalView(ProposalService proposalService) {
        // Configure the grid, create the form, etc.

// tag::snippet[]
        grid.addSelectionListener(event -> {
            event.getFirstSelectedItem().ifPresent(this::editProposal); // <1>
        });
// end::snippet[]
    }

// tag::snippet[]
    private void editProposal(Proposal proposal) {
        // Populate the form in either buffered mode or write-through mode
    }
// end::snippet[]
}
----
<1> Calls `editProposal()` if an item has been selected in the grid.

If your form uses *buffered mode*, you have to store a reference to the FDO so that you can write to it when saving. The `editProposal()` method could look like this:

[source,java]
----
private @Nullable Proposal proposal;

private void editProposal(Proposal proposal) {
    this.proposal = proposal;
    form.read(proposal);
}
----

If your form uses *write-through mode*, the form stores the reference to the FDO. The `editProposal()` method could look like this:

[source,java]
----
private void editProposal(Proposal proposal) {
    form.bind(new Proposal(proposal)); // <1>
}
----
<1> Uses a copy-constructor to create a copy of the proposal before binding it, avoiding the risk of stale data in the grid.

If you need a refresher on form binding, buffered mode and write-through mode, see the <<../bind-form#,Bind a Form>> guide.

// TODO Links to guides about grids and selection via URL parameter


=== Fetch and Load

This approach is preferable when you handle the selection through a URL parameter, or when your grid (or other data listing component) and your form use different data objects. It requires more code than the Load from Selection approach, but does not have the risk of stale data in the grid.

When using Fetch and Load, you first fetch the FDO from an application service, and then populate the form with it. You also have to handle the case when the application service returns an empty result. This could happen if the ID is invalid, or if the entity has been deleted by another session.

Here is an example of what Fetch and Load could look like:

[source,java]
----
@Route("proposals")
public class ProposalView extends Main {
    private final ProposalService proposalService;
    private final Grid<ProposalListEntry> grid; // <1>
    private final ProposalForm form;

    public ProposalView(ProposalService proposalService) {
        this.proposalService = proposalService;
        // Configure the grid, create the form, etc.

// tag::snippet[]
        grid.addSelectionListener(event -> {
            event.getFirstSelectedItem()
                .map(ProposalListEntry::proposalId) // <2>
                .ifPresent(this::editProposal);
        });
// end::snippet[]
    }

// tag::snippet[]
    private void editProposal(long proposalId) {
        proposalService.findById(proposalId).ifPresentOrElse(
            this::editProposal, // <3>
            this::showNoProposalFound // <4>
        );
    }

    private void editProposal(Proposal proposal) {
        // Populate the form in either buffered mode or write-through mode
    }

    private void showNoProposalFound() {
        // Show an error message
    }
// end::snippet[]
}
----
<1> The grid contains `ProposalListEntry` objects, not `Proposal` objects.
<2> Extracts the ID from the selected `ProposalListEntry` to fetch the corresponding `Proposal`.
<3> Populates the form if the proposal exists.
<4> Shows an error message if no proposal was found.


== Saving a Form

The process of saving a form in Vaadin generally follows this pattern:

1. Validate the form.
2. Write to the FDO.
3. Call the application service to save the FDO.
4. Re-initialize the form with the FDO returned by the service, refresh the grid, navigate to another view, or do something else.

How the application service is called depends on whether a single save operation or separate insert and update operations are used.


=== Using a Single Save Operation

In *buffered mode*, the form explicitly updates the FDO. This operation includes validation, as explained in the <<../bind-form/flow#writing-to-a-bean,Bind a Form>> guide. If you are editing an existing FDO, you need to have it stored somewhere:

[source,java]
----
@Route("proposals")
public class ProposalView extends Main {
    private final ProposalService service;
    private final Grid<Proposal> grid;
    private final ProposalForm form;
    private @Nullable Proposal proposal;

    // (Constructor omitted for brevity.)

    private void editProposal(Proposal proposal) {
        // Populate the form in buffered mode
    }

// tag::snippet[]
    private void saveProposal() {
        if (proposal != null && form.write(proposal)) { // <1>
            var savedProposal = service.save(proposal);
            editProposal(savedProposal);
        }
    }
// end::snippet[]
}
----
<1> Validates the form and updates the FDO if successful.

In *write-through mode*, only validation is necessary before calling the application service:

[source,java]
----
@Route("proposals")
public class ProposalView extends Main {
    private final ProposalService service;
    private final Grid<Proposal> grid;
    private final ProposalForm form;

    // (Constructor omitted for brevity.)

    private void editProposal(Proposal proposal) {
        // Populate the form in write-through mode
    }

// tag::snippet[]
    private void saveProposal() {
        form.getProposal().ifPresent(proposal -> { // <1>
            if (form.isValid()) {
                var savedProposal = service.save(proposal);
                editProposal(savedProposal);
            }
        });
    }
// end::snippet[]
}
----
<1> `getProposal()` returns an `Optional` that contains the bound proposal.


==== Saving New Items

The examples so far assume you're editing an existing FDO. When creating new items, the save logic changes slightly to accommodate an empty form and the absence of an existing object.

In *buffered mode*, you typically use a clean form and write to a new FDO before saving:

[source,java]
----
private final ProposalForm form;
private @Nullable Proposal proposal;
// ...

private void newProposal() {
    proposal = null;
    form.clear();
}

private void saveProposal() {
    if (proposal == null) {
        proposal = new Proposal();
    }
    if (form.write(proposal)) {
        var savedProposal = service.save(proposal);
        editProposal(savedProposal);
    }
}
----

In *write-through mode*, you bind to a new FDO:

[source,java]
----
private final ProposalForm form;
// ...

private void newProposal() {
    form.bind(new Proposal());
}

private void saveProposal() {
    // Same as before
}
----


==== Records and Single Save

When using records as FDO, `Binder` requires all record components to be bound to fields -- including the ID. Because you don't typically bind the ID to a UI component, you can create a dummy binding using [classname]`ReadOnlyHasValue`:

[source,java]
----
binder = new Binder<>(ProposalRecord.class); 
// tag::snippet[]
binder.forField(new ReadOnlyHasValue<Long>(ignore -> {})).bind("proposalId");
// end::snippet[]
binder.forField(titleField).bind("title"); 
binder.forField(proposalTypeField).bind("type");
// And so on...
----

You can now call the application service like this:

[source,java]
----
private final ProposalForm form;
// ...

private void saveProposal() {
    form.write().ifPresent(proposalRecord -> {
        var savedProposal = service.save(proposalRecord);
        editProposal(savedProposal);
    });
}
----

If the form was clean, the record returned by `form.write()` has a `null` ID. If the form had been populated by an existing record, the returned record has the ID of that record.


=== Using Separate Insert and Update Operations

If you have separate workflows for creating and updating, having separate insert and update operations in your application service is easy: you call the corresponding method in the corresponding workflow. However, if you are using the same form and a single Save operation in the user interface, you have to keep track of which method to call.

If you are using a wrapper class for persistent items, you can do something like this (assuming buffered mode):

[source,java]
----
private final ProposalService service;
private final ProposalForm form;
private @Nullable PersistentProposal existingProposal;
// ...

private void newProposal() {
    existingProposal = null;
    form.clear();
}

private void editProposal(PersistentProposal existingProposal) {
    this.existingProposal = existingProposal;
    form.read(existingProposal.unwrap());
}

private void saveProposal() {
    Proposal fdo = Optional.ofNullable(existingProposal)
                           .map(PersistentProposal::unwrap) // <1>
                           .orElseGet(Proposal::new); // <2>
    if (form.write(fdo)) {
        if (existingProposal == null) {
            editProposal(service.insert(fdo));
        } else {
            editProposal(service.update(existingProposal));
        }
    }
}
----
<1> If there is an existing `PersistentProposal`, write to its wrapped `Proposal` object.
<2> Otherwise, create a new `Proposal` to write to.

If you are using records, the principle is the same but the code for saving changes slightly:

[source,java]
----
private void saveProposal() {
    form.write().ifPresent(fdo -> {
        if (existingProposal == null) {
            editProposal(service.insert(fdo));
        } else {
            editProposal(service.update(existingProposal.withData(fdo))); // <1>
        }
    });
}
----
<1> Assumes there is a `withData()` method that returns a new wrapper record with the same ID as the original one, but with the specified wrapped FDO.

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.
