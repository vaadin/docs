---
title: Flow
page-title: How to bind a Flow form to a Form Data Object | Vaadin
meta-description: Learn how to bind forms to data in Vaadin Flow using the Binder class, with support for JavaBeans, records, converters, validation, and form state management.
order: 5
---


# Form Binding in Flow
:toclevels: 2

This guide teaches you the basics of the Flow binder, and how to implement *Form Data Objects* (FDO) both as JavaBeans and as Java records.


== Introducing Binder

Vaadin offers a [classname]`Binder` class that binds fields to FDO properties, ensuring that changes made in the form update the FDO. For each field-property pair, the `Binder` creates a new `Binding` object. However, since Binder is one-directional, *updates to the FDO outside of the `Binding` won't automatically reflect in the form fields* unless manually refreshed.

When loading a form, it populates fields with corresponding property values. When saving, it updates the FDO with the modified field values.

You can *attach a converter* to a `Binding` to transform between field values and FDO properties with different types. For example, a `String` field can be converted into an `EmailAddress` object in the FDO. You can also *attach validators* to ensure the input meets specific constraints, such as requiring a non-empty email.


== Types of FDOs

An FDO can range from a simple data container that holds only values, to a more advanced class that includes business logic such as validation rules. The best approach depends on your application's complexity and how much control you need over the data.


=== JavaBean FDOs

When implementing FDOs as JavaBeans, *each form field maps to a corresponding getter and setter method.* If a field is read-only, you can leave out the setter method.

.JavaBean Conventions Are Optional
[NOTE]
You can name your getters and setters any way you like, as long as their method descriptors match what's expected for property access methods. A getter should take no parameters and return a value, while a setter should accept a single parameter and return `void`.

You can add business logic to the setters. For instance, you could perform validation, or maintain a change log inside the bean.

When a form is loaded, the `Binder` populates each field with data from the corresponding getter. When the form is saved, the `Binder` calls the setters to update the bean with data in the form. You can then send the bean to an application service for processing.

Beans give you more flexibility for complex forms but require more boilerplate code than records, due to the need for explicit getters and setters. Since they are mutable, there's also a higher risk of bugs, especially when handling form cancellations or undo actions.

.Beware of Stale Data
[IMPORTANT]
If your FDOs come from a shared cache or data provider, be careful to avoid stale data. This can occur if a user starts editing an item and changes are written back to the FDO, but the user then cancels instead of saving. To prevent this, you can use buffered mode, refresh the FDO after cancellation, or bind a copy of the FDO instead of the original.


=== Record FDOs

When implementing FDOs as Java records, *each form field corresponds to a record component.*

When the form is loaded, the `Binder` populates each field with data from the corresponding record component. When the form is saved, the `Binder` creates a new record instance from the data in the form. You can then send the record to an application service for processing.

Java records are concise and eliminate boilerplate. Their immutability makes form state easier to manage, reducing the risk of subtle bugs. It also makes it clear when the form has been read or written.


== Binding to a Bean

Continuing with the *Project Proposal* form example from the <<../add-form/flow#,Add a Form>> guide, you can create a JavaBean to represent the FDO:

.Proposal.java
[source,java]
----
public class Proposal {
    private String title;
    private ProposalType type;
    private String description;
    private LocalDate startDate;
    private LocalDate endDate;

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public ProposalType getType() {
        return type;
    }
    public void setType(ProposalType type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDate getStartDate() {
        return startDate;
    }
    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getEndDate() {
        return endDate;
    }
    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }
}
----

To bind this bean to the form, create a [classname]`Binder` instance and register each form field:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<Proposal> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

// tag::snippet[]
        binder = new Binder<>();
        binder.forField(titleField) // <1>
            // Converters and validators would go here
            .bind(Proposal::getTitle, Proposal::setTitle); // <2>
        binder.forField(proposalTypeField)
            .bind(Proposal::getType, Proposal::setType);
        binder.forField(descriptionField)
            .bind(Proposal::getDescription, Proposal::setDescription);
        binder.forField(startDateField)
            .bind(Proposal::getStartDate, Proposal::setStartDate);
        binder.forField(endDateField)
            .bind(Proposal::getEndDate, Proposal::setEndDate);
// end::snippet[]
    }
}
----
<1> Creates a `Binding` for `titleField`.
<2> Uses getter and setter methods for binding.


=== Buffered vs. Write-Through

When using a JavaBean as an FDO, `Binder` can operate in *buffered* or *write-through* mode.

* *Buffered mode*: Changes remain in the form until explicitly saved. This prevents side effects but may affect validation behavior.
* *Write-through mode*: Updates the FDO immediately as the user edits the form. Business logic in setter methods is triggered immediately. However, invalid states can occur where the form contains errors, but the FDO remains valid.

Form validation is covered in the <<../validate-form#,Validate a Form>> guide.


=== Reading from a Bean

To populate a form in *buffered mode*, use `Binder.readBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(Proposal formDataObject) {
        binder.readBean(formDataObject);
    }
// end::snippet[]
}
----

For *write-through mode*, use `Binder.setBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void bind(Proposal formDataObject) {
        binder.setBean(formDataObject);
    }
// end::snippet[]

    public Optional<Proposal> getProposal() {
        return Optional.ofNullable(binder.getBean()); // <1>
    }
}
----
<1> It is a good idea to also add a getter method for the bound FDO.


=== Writing to a Bean

In *buffered mode*, use `Binder.writeBeanIfValid()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

    public void read(Proposal formDataObject) {
        binder.readBean(formDataObject);
    }

// tag::snippet[]
    public boolean write(Proposal formDataObject) {
        return binder.writeBeanIfValid(formDataObject); // <1>
    }    
// end::snippet[]
}
----
<1> Returns `true` if validation succeeds, `false` otherwise.

.Other methods for writing to a bean
[%collapsible]
====
The `Binder` class provides four methods for writing form data to an FDO:

`writeBean` :: Validates the entire form and writes all values to the FDO if validation passes. Throws an exception if validation fails.
`writeBeanAsDraft` :: Writes all valid values to the FDO while ignoring invalid values. No exception is thrown.
`writeBeanIfValid` :: Validates the form and writes all values if validation passes. Returns false (rather than throwing an exception) if validation fails.
`writeChangedBindingsToBean` :: Validates the entire form but only writes modified fields to the FDO if validation passes. Throws an exception if validation fails.

Some methods have overloaded versions that allow you to further customize the write operation. See the JavaDocs for details.
====

In *write-through mode*, no explicit write operation is needed. However, always check form validity before processing:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

    public void bind(Proposal formDataObject) {
        binder.setBean(formDataObject);
    }

    public Optional<Proposal> getProposal() {
        return Optional.ofNullable(binder.getBean());
    }

// tag::snippet[]
    public boolean isValid() {
        return binder.validate().isOk();
    }
// end::snippet[]
}
----


=== Clearing the Form

To clear the form in *buffered mode*, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

    public void read(Proposal formDataObject) {
        binder.readBean(formDataObject);
    }

    public boolean write(Proposal formDataObject) {
        return binder.writeBeanIfValid(formDataObject);
    }

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----

In *write-through mode*, unbind the FDO by setting it to `null`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<Proposal> binder;

    // Constructor omitted for clarity

    public void bind(Proposal formDataObject) {
        binder.setBean(formDataObject);
    }

    public Optional<Proposal> getProposal() {
        return Optional.ofNullable(binder.getBean());
    }

    public boolean isValid() {
        return binder.validate().isOk();
    }

// tag::snippet[]
    public void unbind() {
        binder.setBean(null);
    }
// end::snippet[]
}
----


== Binding to a Record

The equivalent *Project Proposal* FDO using a *record* looks like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

Unlike JavaBeans, records do not have setters. Instead, `Binder` uses *string-based mapping* to bind form fields to record components. You also need to specify the record class when creating the binder:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<ProposalRecord> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

 // tag::snippet[]
        binder = new Binder<>(ProposalRecord.class); // <1>
        binder.forField(titleField)
            // Converters and validators would go here
            .bind("title"); // <2>
        binder.forField(proposalTypeField).bind("type");
        binder.forField(descriptionField).bind("description");
        binder.forField(startDateField).bind("startDate");
        binder.forField(endDateField).bind("endDate");
// end::snippet[]
    }
}
----
<1> Passes the `ProposalRecord` record class to the `Binder` constructor.
<2> Uses record component names as string literals.


=== Avoiding Invalid Record Component Names

If you rename a record component but forget to update the corresponding `Binding`, it will only cause an error at runtime. The `bind()` method would notice that no such record component exists, and throw an exception.

To mitigate this, you can create a unit test that instantiates the form, like this:

.ProposalFormTest.java
[source,java]
----
class ProposalFormTest {
    @Test
    void instantiating_form_throws_no_exceptions() {
        new ProposalForm();
    }
}
----

Since the `bind()` method is called in the constructor, this test would fail if it tried to bind a field to a non-existent record component.

To reduce this risk, you can also use constants for record component names instead of string literals. The constants could look like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
    public static final String PROP_TITLE = "title";
    public static final String PROP_TYPE = "type";
    // And so on...
}
----

And you would use them with `Binder` like this:

[source,java]
----
binder.forField(titleField).bind(ProposalRecord.PROP_TITLE);
binder.forField(proposalTypeField).bind(ProposalRecord.PROP_TYPE);
// And so on...
----


=== Reading from a Record

To populate the form from a record, use `Binder.readRecord()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }
// end::snippet[]
}
----


=== Writing to a Record

Since records are immutable, `Binder.writeRecord()` creates a new instance:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }

// tag::snippet[]
    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord()); // <1>
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty(); // <2>
        }
    }
// end::snippet[]
}
----
<1> Returns a new `ProposalRecord` if validation succeeds.
<2> Returns an empty `Optional` if validation fails.

[IMPORTANT]
Since `Binder` creates a new record instance, *you must bind every record component to a field*. Otherwise, `Binder` does not know what values to pass to the unbound fields.


=== Clearing the Form

To clear the form, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    public ProposalForm() {
        // Constructor implementation omitted for clarity
        // ...
    }

    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }

    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord());
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty();
        }
    }

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----


//== Try It

// TODO Add a tutorial here

