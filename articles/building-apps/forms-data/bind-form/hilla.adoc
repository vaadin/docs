---
title: Hilla
page-title: How to bind a Hilla form to a Form Data Object | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 10
---

// TODO Fix references to "earlier project proposal example".

# Form Binding in Hilla

TODO


== Form Data Object and Form Model

// Some of this section may be better suited for the Overview page, as it is very similar to the Flow text.

Forms are used to display and edit data. This data comes from a *Form Data Object (FDO)*, which has a structure that aligns with the fields of the form. Each field in the form is typically mapped to a corresponding property in the FDO.

In Hilla, FDOs are fetched from and submitted to a *browser-callable application service* for further processing. From an architectural point of view, *an FDO belongs to the application layer* rather than the presentation layer.

FDOs are implemented in Java, typically as records, although JavaBeans are also possible. Hilla generates the necessary TypeScript interfaces and takes care of the serialization between Java and JSON. Hilla also generates a *form model*, which is a description of the FDO in TypeScript. This form model is then used by the Hilla binder.

[NOTE]
You can use your entities as FDOs if the forms and entities structurally match each other. However, this couples your domain logic to the UI. This can create maintainability issues, for instance if UI requirements and business logic evolve in different directions.

Continuing with the earlier *Project Proposal* form example, you can create a record to represent the FDO:

[source,java]
----
public record Proposal(
    @Nullable Long proposalId,
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

To get Hilla to find this FDO, you have to create a browser-callable service that either returns it or accepts it as a parameter:

[source,java]
----
@BrowserCallable
@AnonymousAllowed
public class ProposalService {

    public void save(Proposal proposal) {
        // Will be implemented later
    }
}
----

For more information about browser-callable services, see the <<../../business-logic/add-service#,Add a Service>> guide.


== Binding Fields

Hilla offers a `useForm`-hook that binds fields to form model properties, ensuring that changes made in the form update the FDO. Initialize it like this:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
// tag::snippet[]
import { useForm } from "@vaadin/hilla-react-form";
// end::snippet[]
import ProposalType from "Frontend/generated/com/example/application/tutorial/domain/ProposalType";
// tag::snippet[]
import ProposalModel from "Frontend/generated/com/example/application/tutorial/service/ProposalModel";
// end::snippet[]

export default function ProposalForm() {
// tag::snippet[]
    const { field, model, value } = useForm(ProposalModel); // <1>
// end::snippet[]

    return (
        <FormLayout>
            ...
        </FormLayout>
    );
}
----
<1> `ProposalModel` is the form model generated by Hilla from the `Proposal` FDO.

To bind a field to a form model property, use the `field` directive:

.ProposalForm.tsx
[source,tsx]
----
// Imports omitted for clarity.

function ProposalForm() {
    const { field, model, value } = useForm(ProposalModel)
// tag::snippet[]
    return (
        <FormLayout>
            <TextField label="Title" 
                       {...field(model.title)}/>
            <ComboBox label="Proposal Type" 
                      items={Object.values(ProposalType)} 
                      {...field(model.type)}/>
            <TextArea label="Description" 
                      data-colspan="2" 
                      {...field(model.description)}/>
            <DatePicker label="Start Date" 
                        {...field(model.startDate)}/>
            <DatePicker label="End Date" 
                        {...field(model.endDate)}/>
        </FormLayout>
    );
// end::snippet[]
}
----

To access the FDO itself, use the `value` variable. In the example above, `value` is an instance of type `Proposal`. Hilla makes sure the FDO and the form are always in sync.


== Clearing the Form

To clear the form, the `useForm()` hook provides a `clear()` function:

.ProposalForm.tsx
[source,tsx]
----
// Imports omitted for clarity.

function ProposalForm() {
// tag::snippet[]
    const { field, model, value, clear } = useForm(ProposalModel)
// end::snippet[]
    return (
        <FormLayout>
            ...
            <Button onClick={clear}>Clear Form</Button>
        </FormLayout>
    );
}
----

Clearing the form also clears the FDO, including unbound properties.


== Accessing the Form State

- Add example of accessing the form state (see the ref guide for details)

== Try It

- Add a tutorial here

