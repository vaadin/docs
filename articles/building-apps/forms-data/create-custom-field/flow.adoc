---
title: Flow
page-title: Create a Custom Field in Flow
description: Guide on how to create a Custom Field in Vaadin Flow.
meta-description: Guide on how to create a Custom Field in Vaadin Flow.
order: 5
---


= Create a Custom Field in Flow
:toclevels: 2

On this page you should be able to read through the necessities to create a custom field that's ready for production,
as well as a step-by-step guide that you can follow along to create an example custom field.


== Custom Fields in Flow

When you want multiple components to behave as a single form field, or you have a component that doesn’t support integration with Binder, setting labels, or displaying helper text, you should encapsulate those components in a Custom Field.
There are several approaches available, depending on how much customization is needed. The simplest solution will extend `CustomField` class, while a more complex solution could require extending `AbstractField`, `AbstractSinglePropertyField` or `AbstractCompositeField`.

=== Extending `CustomField`

When extending `CustomField` you get various built-in features like label, helper text, error message and validation state control. They are styled and function the same way other Vaadin field components do.

To create a Custom Field in Flow, you need to define a class that extends the `CustomField` base class and specify the value type that represents the combined value of its internal components.
You'll also need to implement two key methods:

* `generateModelValue()`: Computes the field’s value from the values of its internal components.
* `setPresentationValue(T value)`: Distributes the given value to the internal components.
These methods are automatically invoked when a value changes either on the client side (`generateModelValue`) or on the server side (`setPresentationValue`).

In the following example, we create a custom field that has a "Roll" button and an `IntegerField` that displays field value that can be modified. Every time the "Roll" button is clicked, it generates a new value.

```java
public class SingleDiceCustomField extends CustomField<Integer> {
    private static final int MIN_VALUE = 1;
    private static final int MAX_VALUE = 6;

    private final Button button;
    private final IntegerField input;

    public SingleDiceCustomField() {
        addClassName("single-dice-custom-field");

        button = new Button("Roll");
        button.addClickListener(clickEvent -> {
            setValue(RandomGenerator.getDefault().nextInt(MIN_VALUE, MAX_VALUE + 1));
        });

        input = new IntegerField();
        input.setMin(MIN_VALUE);
        input.setMax(MAX_VALUE);

        var layout = new HorizontalLayout(button, input);
        add(layout);
    }

    private Button createButton() {
        var button = new Button("Roll");
        button.addClickListener(clickEvent -> {
            setValue(RandomGenerator.getDefault().nextInt(MIN_VALUE, MAX_VALUE + 1));
        });

        return button;
    }

    @Override
    protected Integer generateModelValue() {
        return input.getValue();
    }

    @Override
    protected void setPresentationValue(Integer value) {
        input.setValue(value);
    }
}
```

=== Extending `AbstractField`

If you want more control than what extending `CustomField` provides, you could extend `AbstractField` or one of the other Helper classes based on it.
This is outside the scope of this article, you can instead read the article about <<{articles}/flow/binding-data/field,Creating a Component that Has a Value>>.

[IMPORTANT]
If your `AbstractField` has a client-side code imported with `@JsModule` and it uses Vaadin components like ComboBox or even is wrapped in a client-side version of the `CustomField` (`vaadin-custom-field`), then you might need add `@Uses({component}.class)` annotation, for example `@Uses(ComboBox.class)`, `@Uses(CustomField.class)`, otherwise the bundle optimization might exclude these components and your fields might fail to render.

== Choosing Internal Components

The internal components you embed can be any class that extends the Component class. This includes (but is not limited to) <<{articles}/components#,Vaadin Components>> like `TextField`, `DatePicker`, or `Grid`; <<{articles}/flow/create-ui/standard-html#,HTML element wrappers>> like `Input`, `Div`, or `NativeButton`; and third-party components from https://vaadin.com/directory[Vaadin Directory] add-ons.

Using <<{articles}/components#,Vaadin Components>> is usually the simplest choice, as it allows you to rely on the styles of the fields, and you can just propagate various states (like "invalid", "readonly", "disabled") and texts (helper text, error message) to the sub-fields.

Using <<{articles}/flow/create-ui/standard-html#,HTML element wrappers>> usually requires more careful design with various states the custom fields support. Depending on the design of your application, some custom fields states might not be relevant to it, if they are never used, so it is not required that you properly handle all these cases.

== Data Binding

There are two primary ways to work with values in a Custom Field:

* Direct interaction with the Custom Field instance
* Integration through Binder

The right approach depends on your use case. If the Custom Field is part of a larger form that maps to a data object, you should typically bind it using `Binder`. However, if the field is standalone, such as when it's used only to filter content in the UI, it may be more appropriate to interact with it directly.

Both approaches are covered below.

[WARNING]
Custom Field will automatically pick up value changes from input elements attached to it (either directly, or as part of another component), which means you *usually* don't have to add additional value change listeners that update the Custom Field value. You just have to make sure that `generateModelValue()` collects the changes correctly to create the custom field value. Being aware of this feature is critical to avoiding running into unexpected side effects. This is not the case for components like `Grid`, where you only get selection changed events.

=== Direct interaction

Since CustomField implements the HasValue interface, it supports the same API used by other form field components in Vaadin.

You can retrieve and set values using:
```java
myCustomField.getValue();      // Retrieve current value
myCustomField.setValue(value); // Update value
```

To react to value changes, you can register a listener:
```java
myCustomField.addValueChangeListener(listener);
```

It's recommended to use a lambda expression (for short handlers) or a method reference to keep your code concise.

The ValueChangeEvent provides:

* `event.getValue()` – the new value
* `event.getOldValue()` – the previous value
* `event.getSource()` – the source component (your Custom Field)
* `event.isFromClient()` – whether the change originated from the client side

```java
myCustomField.addValueChangeListener(event -> {
    if (event.isFromClient()) {
        var value = event.getValue();
        fullNameDiv.setText("Updated name: %s %s".formatted(value.getFirstName(), value.getLastName()));
    }
});
```

=== Using Binder

Binding a Custom Field works the same way as with built-in components like `TextField` or `ComboBox`. If you’re already familiar with Binder setup and validation, the process will feel familiar.

Example binding:
```java
binder.forField(myCustomField)
    .withValidator(new MyValidator())
    .bind(MyBinderObject::getName, MyBinderObject::setName);
```

In this example, the `MyBinderObject.getName()` (and `setName(..)`) should match the same object type as the Custom Field's value, meaning if your Custom Field extends `CustomField<MyNameObject>` the return type for `MyBinderObject.getName()` should be `MyNameObject`.

Once the binding is configured, calling `binder.setBean(myObject)` or `binder.readBean(myObject)` will automatically populate your Custom Field with the appropriate value.

== Label

When you extend a `CustomField`, it provides built-in support for setting a label, just like standard Vaadin field components. This means you can use `customField.setLabel("My Field");` to assign a label, and it will behave and appear consistently with other Vaadin input components, making it easy to maintain a uniform design across your forms.


=== Custom Labels for Internal Inputs

In more advanced use cases, your Custom Field might need a special label that cannot be achieved with just styling the label. In such cases, you should:

* Use the `NativeLabel` component to create accessible and styled labels.
* Override the `getLabel()` and `setLabel(String)` methods in your Custom Field to interact with your custom label logic.
* Link each label to its corresponding input using either:
  ** `label.setFor(Component)` (direct reference)
  ** `label.setFor(String)` (by ID)

The input component should have a unique ID set via `input.setId(String)`.

If you have multiple inputs, you can:

* Use individual `NativeLabel` elements for each input.
* Or assign a shared label by setting the `aria-labelledby` attribute on each input to point to a common label ID.

==== Example: Custom Label Handling
```java
public class MyCustomField extends CustomField<Integer> {
    // ...
    private final NativeLabel label;
    private final Input input;

    public MyCustomField(String label) {
        input = createInput();
        label = new NativeLabel(label);
        label.setFor(input);

        var layout = new Div(label, input);
        add(layout);
    }

    @Override
    public String getLabel() {
        return label.getText();
    }

    @Override
    public void setLabel(String labelText) {
        label.setText(labelText);
    }

    private Input createInput() {
        var input = new Input();
        // Generate a (very likely) unique field id
        input.setId("my-custom-field-" + RandomGenerator.getDefault().nextInt(1, 100_000));
        return input;
    }
}
```

== "Required" indicator

If your custom field requires a "required" indicator, by default, `CustomField` comes with the familiar methods:

* `field.isRequiredIndicatorVisible()` - check whether the indicator is visible,
* `field.setRequiredIndicatorVisible(Boolean)` - toggle the visibility of the indicator.

If you are not happy with the icon used, you should be able to adjust it with some CSS.

Alternatively, if you do need to
use your own indicator, you'll have to override the above methods. When you do that, you should still call the `super`
method as well, for the `setRequiredIndicatorVisible` method, so that you don't have to worry about handing accessibility
related stuff. You will also want to add `aria-hidden="true"` attribute on your custom indicator, so that it isn't additionally
announced by screen readers.

```java
@Override
public void setRequiredIndicatorVisible(boolean requiredIndicatorVisible) {
    super.setRequiredIndicatorVisible(requiredIndicatorVisible);
    customIndicator.setVisible(requiredIndicatorVisible);
}
```

You should also make sure to hide the original indicator with some CSS:
```css
vaadin-custom-field::part(required-indicator) {
    display: none;
}
```

== Validation

When extending `CustomField`, you get built-in support for marking the field as invalid and displaying error messages. This ensures your Custom Field behaves consistently with other Vaadin field components in terms of visual appearance and accessibility.

[IMPORTANT]
If you're extending `AbstractField`, you will have to implement the `HasValidationProperties` interface and add the necessary elements that use these (`invalid` and `errorMessage`) properties.

You can use:

```java
myCustomField.setErrorMessage("This field is required");
myCustomField.setInvalid(true);
```

This displays the error message below the field and applies Vaadin’s standard "invalid" styling.

When the field is bound to a Binder with one or more validators, Vaadin automatically manages the error state and message visibility for you.

=== Using the Internal Component’s Error Handling

If you want the error message to appear under a specific internal component, rather than under the entire Custom Field, you can override a few methods to delegate the validation logic.

In the example below, a TextField and Button are placed side by side inside a Custom Field. The goal is to show validation feedback only under the TextField, while keeping the Custom Field logic intact.

Override the following methods:

* `isInvalid()` — to reflect both the outer and internal component's invalid states.
* `setInvalid(boolean)` — to set both the outer and internal states.
* `getErrorMessage()` — to return the message from the internal field.
* `setErrorMessage(String)` — to assign the message to the internal field.

```java
public class ButtonTextFieldCustomField extends CustomField<String> {

    private final Button button = new Button("My button");
    private final TextField textField = new TextField();

    public ButtonTextFieldCustomField() {
        var layout = new HorizontalLayout(button, textField);
        add(layout);
    }

    @Override
    public boolean isInvalid() {
        return super.isInvalid() || textField.isInvalid();
    }

    @Override
    public void setInvalid(boolean invalid) {
        super.setInvalid(invalid);
        textField.setInvalid(invalid);
    }

    @Override
    public String getErrorMessage() {
        return textField.getErrorMessage();
    }

    @Override
    public void setErrorMessage(String errorMessage) {
        textField.setErrorMessage(errorMessage);
    }

    @Override
    protected String generateModelValue() {
        return textField.getValue();
    }

    @Override
    protected void setPresentationValue(String s) {
        textField.setValue(s);
    }
}

```

=== Using a Custom Element for Error Messages

In advanced cases, you may want to display validation messages in a custom location or format.

To achieve this, you need to:

* Use an appropriate element / component (typically a `Div`) to display the message.
* Assign it a unique `id`, e.g. `"my-custom-field-error-42"` (you will likely need to generate part of it).
* Link it to the input using the `aria-describedby` attribute, so assistive technologies can describe the error.
* Handle the visibility of the error message element(s) yourself. Usually you should hide it if the component is marked as valid
(you can override the `setInvalid(boolean)` method and add code to handle this) and reveal it if it's invalid and there's
an error message to be shown.
* Control its visibility by overriding `setInvalid(boolean)` to show or hide it based on the validation state.

```java
private final Div errorDiv = new Div();

public MyCustomField() {
    errorDiv.setId("my-custom-field-error-" + uniqueFieldNumber);

    Input input = createInput();

    var layout = new Div(label, errorDiv, input);

    add(layout);
}

@Override
public String getErrorMessage() {
    return errorDiv.getText();
}

@Override
public void setErrorMessage(String errorMessage) {
    errorDiv.setText(errorMessage);
}

@Override
public void setInvalid(boolean invalid) {
    super.setInvalid(invalid);
    if (invalid) {
        errorDiv.setVisible(true);
        input.getElement().setAttribute("aria-describedby", errorDiv.getId().orElse(""));
    } else {
        errorDiv.setVisible(false);
        input.getElement().removeAttribute("aria-describedby");
    }
}

```

[IMPORTANT]
Always remove aria-describedby when hiding the error element to avoid confusing screen readers.

=== Internal Validation

There might be some validation that you want to handle from the inside of your Custom Field, instead of relying only on external validation. This, however, could present various problems if unaccounted for. For internal validation you should never rely on the same `invalid` and `errorMessage` parameters to implement it. This is so that when your custom field is bound to a binder, validation doesn't ignore the internal validation state.
Instead, you should use a different approach to indicate an error state. It's recommended that you limit internal validation to the default validators available through Vaadin components, such as, for `IntegerField` using `field.setMax(Integer)`.
Alternatively you could have a method that an external binder could use to be aware of the error state. We will not cover such complex cases here.

== Styling

Styling a Custom Field works much like styling other Vaadin field components. However, because a Custom Field may include both built-in parts (like the label and error message) and your own internal elements, it's important to know how to target both effectively.

Before proceeding, we recommend reviewing the general (<<{articles}/styling,Styling>>) and the (<<{articles}/components/custom-field/styling,Custom Field Styling reference>>) to understand available selectors and theming options.

=== Styling Default Custom Field Elements

To style the built-in parts of `CustomField` (such as its label), use the `vaadin-custom-field` selector.

In the following example, the default label is styled to use the error text color when the field is in an invalid state:

```css
vaadin-custom-field[invalid]::part(label) {
    color: var(--lumo-error-text-color);
}
```

This rule will apply to all `CustomField` instances. If you want to style a specific type of custom field, you should assign it a class name.

Assign a custom class in Java:

```java
public MyCustomField() {
    addClassName("my-custom-field");
    // ...
}
```

Then target it in CSS:

```css
vaadin-custom-field.my-custom-field[invalid]::part(label) {
    color: var(--lumo-error-text-color);
}
```

.Best practice
[TIP]
Use both `vaadin-custom-field` and the custom classname in your selector to prevent accidental styling of unrelated components.

=== Styling Custom Internal Elements

To style internal elements (e.g., input fields, layout wrappers, buttons) that you've added to your `CustomField`, assign class names to both the outer field and the individual components.

Example:

```java
public MyCustomField() {
    addClassName("my-custom-field");

    var contentWrapper = new Div();
    contentWrapper.addClassName("my-custom-field-wrapper");

    var input = new Input();

    contentWrapper.add(input);
    add(contentWrapper);
}
```

Then target them in CSS:

```css
/* Style the wrapper */
.my-custom-field-wrapper {
    padding: var(--lumo-space-m);
    border: 1px solid var(--lumo-contrast-40pct);
}

/* Style the internal input */
vaadin-custom-field.my-custom-field input {
    border: 1px dashed var(--lumo-success-color);
}
```

=== Styling Directly in Java
Alternatively, you can style components directly through Java in several ways:

* Using <<{articles}/styling/lumo/utility-classes#,Lumo Utility classes>>, for example `label.addClassName(LumoUtility.Padding.Left.SMALL);`
* Using `HasStyle` API on the component
** Through predefined methods, for example `label.getStyle().setPaddingLeft("var(--lumo-space-xs)")`
** Through a generic style property setter `label.getStyle().set("padding-left", "var(--lumo-space-xs)"`.

[TIP]
If the component doesn't directly implement the `HasStyle` interface, in most cases you can access the same API through `component.getElement().getStyle()`.

[IMPORTANT]
When using `HasStyle` API, its is recommended that you use <<{articles}/styling/lumo/lumo-style-properties#,Lumo Style Properties>> when possible, if you're using the Lumo theme (or your own defined CSS properties). For example use `"var(--lumo-space-xs)"` instead of "4px". This provides consistent styling, with the ability to make consistent changes, if, for example, sizing needs to be decreased.


== Localization / Internalization

If your application supports multiple languages, you might need to localize your Custom Field as well.
There are Vaadin components that accept a localization object, and you might need to have a similar approach to those. For example `DateTimePicker` accepts `DateTimePicker.DateTimePickerI18n`, which provides various variables that should contain texts
for various parts of the component. You can follow a similar examples for your component.

First, you have a class with all the texts.

```java
 public static class DateTimePickerI18n implements Serializable {
        private String dateLabel;
        private String timeLabel;
        private String badInputErrorMessage;
        private String incompleteInputErrorMessage;
        private String requiredErrorMessage;
        private String minErrorMessage;
        private String maxErrorMessage;

        public String getDateLabel() {
            return this.dateLabel;
        }

        public DateTimePickerI18n setDateLabel(String dateLabel) {
            this.dateLabel = dateLabel;
            return this;
        }

        public String getTimeLabel() {
            return this.timeLabel;
        }

        // .. and so on
    }
```

Then you add getter and setter for the localization object in your Custom Field.

```java
public DateTimePickerI18n getI18n() {
    return this.i18n;
}

public void setI18n(DateTimePickerI18n i18n) {
    Objects.requireNonNull(i18n, "The i18n properties object should not be null");
    this.i18n = i18n;
    this.updateI18n();
}
```

Then you add a method to update your fields based on the new localization object. The exact code for this in DateTimePicker
is a bit too complex for us, since it's based on web-component. So lets pretend it looks like this instead:

```java
private void updateI18n() {
    DateTimePickerI18n i18nObject = this.i18n != null ? this.i18n : new DateTimePickerI18n();
    dateField.setLabel(i18nObject.getDateLabel());
    timeField.setLabel(i18nObject.getTimeLabel());
    // .. and so on
}
```

You also have to make sure to call the `updateI18n()` method whenever texts should be updated, so like we already had in the
`setI18n(DateTimePickerI18n)` method.


For more information about localization please read the <<{articles}/flow/advanced/i18n-localization,Localization>> article.

== Accessibility

There could be a lot of accessibility issues you will have to solve for your Custom Field, we can not cover all of them here,
but we can address the most common ones.

`CustomField` itself has a label, and in single input case, you usually do not need to introduce labels, however, that label should
point to an input field. This does not occur by default, because the `CustomField` is not aware of which `input` should it point to, especially in fields with multiple inputs.

Vaadin currently does not provide a simple way to do this, that covers all possible cases.
Here's an example of doing it with JavaScript script call from your Custom Field code:

```java
private void setFor(TextField field) {
    field.getElement().executeJs("""
            setTimeout(() => {
              const inputId = $1.inputElement.id;
              const mainLabel = $0.querySelector(
                '#'+$0.getAttribute('aria-labelledby'));
              mainLabel.setAttribute('for', inputId);
            }, 100);""", getElement(), field.getElement());
}
```

The default role of the custom field is `group` If there's only a single input, appropriate role would `input`.
Vaadin currently does not provide a straight forward way to do this, you will once again have to make a JS call.
```java
getElement().executeJs(
                "setTimeout(() => $0.setAttribute('role', 'input'), 100);",
                this);
```

You can combine these two calls into one and call it in the `onAttach` method, so that even if your field is attached and detached, the correct accessibility persists.

```java
@Override
public void onAttach(AttachEvent event) {
    getElement().executeJs("""
            setTimeout(() => {
              $0.setAttribute('role', 'input');
              const inputId = $1.inputElement.id;
              const mainLabel = $0.querySelector(
                '#'+$0.getAttribute('aria-labelledby'));
              mainLabel.setAttribute('for', inputId);
            }, 100);""", getElement(), field.getElement());
}
```

[.collapsible-list]
== Try It

Let's create a duration field. It will require two input fields "hours" and "minutes", as well as custom labels for them, so that the field can be read as, for example "2 hours and 30 minutes". The input fields will be `IntegerField` components. It will support localization, and it will be accessible.

.Set Up the Project
[%collapsible]
====
To start, generate a <<{articles}/getting-started/start#,walking skeleton with a Flow UI>>, <<{articles}/getting-started/import#,open>> it in your IDE, and <<{articles}/getting-started/run#,run>> it with hotswap enabled.
====


.Step 2 - Setup Basics
[%collapsible]
====

Let's set up the bare minimum that we need for this field to function. We're going to initialize each component in a separate method so that we can add more component specific code to it later without cluttering the constructor.

```java
import com.vaadin.flow.component.customfield.CustomField;
import com.vaadin.flow.component.html.NativeLabel;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.textfield.IntegerField;

import java.time.Duration;

public class DurationField extends CustomField<Duration> {

    private static final long MINUTES_IN_HOUR = 60;
    private static final int MINUTES_STEP_INTERVAL = 15;

    private final NativeLabel hoursLabel;
    private final NativeLabel minutesLabel;
    private final IntegerField hours;
    private final IntegerField minutes;
    private final Span and;

    public DurationField() {
        hoursLabel = createHoursLabel();
        minutesLabel = createMinutesLabel();
        hours = createHoursField();
        minutes = createMinutesField();
        and = createAndSpan();

        add(hours, hoursLabel, and, minutes, minutesLabel);
    }

    private NativeLabel createHoursLabel() {
        return new NativeLabel("hours");
    }

    private NativeLabel createMinutesLabel() {
        return new NativeLabel("minutes");
    }

    private IntegerField createHoursField() {
        var hours = new IntegerField();
        hours.setWidth("45px");

        return hours;
    }

    private IntegerField createMinutesField() {
        var minutes = new IntegerField();
        minutes.setWidth("45px");
        minutes.setStep(MINUTES_STEP_INTERVAL);

        return minutes;
    }

    private Span createAndSpan() {
        return new Span("and");
    }

    @Override
    protected Duration generateModelValue() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            // If any of the fields are empty, we do not have enough to generate a value.
            return null;
        }

        var hourMinutes = MINUTES_IN_HOUR * hours.getValue();
        return Duration.ofMinutes(hourMinutes + minutes.getValue());
    }

    @Override
    protected void setPresentationValue(Duration newPresentationValue) {
        var h = (int) newPresentationValue.toHours();
        var m = newPresentationValue.toMinutesPart();
        hours.setValue(h);
        minutes.setValue(m);
    }

    @Override
    public void focus() {
        // Make sure component focus targets the hours field.
        hours.focus();
    }
}
```

At this point, if we test this component, we'll find that it's functioning, but it doesn't look good, as there are spacing issues. So lets fix that in the next step.
====

.Step 3 - Styling
[%collapsible]
====

We do not need a lot of custom styling for our Custom Field, so lets use <<{articles}/styling/lumo/utility-classes#,Lumo Utility classes>> to fix some of the spacing issues we have.
For hours and minutes labels, lets add some left padding:

```java
label.addClassName(LumoUtility.Padding.Left.SMALL);
```

For "and" Span element, lets add some left and right padding.
```java
andSpan.addClassNames(LumoUtility.Padding.Left.SMALL, LumoUtility.Padding.Right.SMALL);
```

So our resulting CustomField now looks like this:

```java
import com.vaadin.flow.component.customfield.CustomField;
import com.vaadin.flow.component.html.NativeLabel;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.theme.lumo.LumoUtility;

import java.time.Duration;

public class DurationField extends CustomField<Duration> {
    private static final long MINUTES_IN_HOUR = 60;
    private static final int MINUTES_STEP_INTERVAL = 15;

    private final NativeLabel hoursLabel;
    private final NativeLabel minutesLabel;
    private final IntegerField hours;
    private final IntegerField minutes;
    private final Span and;

    public DurationField() {
        hoursLabel = createHoursLabel();
        minutesLabel = createMinutesLabel();
        hours = createHoursField();
        minutes = createMinutesField();
        and = createAndSpan();

        add(hours, hoursLabel, and, minutes, minutesLabel);
    }

    private NativeLabel createHoursLabel() {
        var label = new NativeLabel("hours");
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private NativeLabel createMinutesLabel() {
        var label = new NativeLabel("minutes");
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private IntegerField createHoursField() {
        var hours = new IntegerField();
        hours.setWidth("45px");

        return hours;
    }

    private IntegerField createMinutesField() {
        var minutes = new IntegerField();
        minutes.setWidth("45px");
        minutes.setStep(MINUTES_STEP_INTERVAL);

        return minutes;
    }

    private Span createAndSpan() {
        var andSpan = new Span("and");
        andSpan.addClassNames(LumoUtility.Padding.Left.SMALL, LumoUtility.Padding.Right.SMALL);
        return andSpan;
    }

    @Override
    protected Duration generateModelValue() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            // If any of the fields are empty, we do not have enough to generate a value.
            return null;
        }

        var hourMinutes = MINUTES_IN_HOUR * hours.getValue();
        return Duration.ofMinutes(hourMinutes + minutes.getValue());
    }


    @Override
    protected void setPresentationValue(Duration newPresentationValue) {
        var h = (int) newPresentationValue.toHours();
        var m = newPresentationValue.toMinutesPart();
        hours.setValue(h);
        minutes.setValue(m);
    }

    @Override
    public void focus() {
        // Make sure component focus targets the hours field.
        hours.focus();
    }
}
```

The extra padding is sufficient for the Custom Field to look decent for our use case. Let's move to the next step.

====

.Step 4 - Validation
[%collapsible]
====

We want to establish some restrictions on the field and make sure we provide sufficient feedback for user to work within these restrictions.
Since we're using `IntegerField` we're already restricting the input to digits. Let's make sure the "hours" value is never a negative number.

```java
hours.setMin(0);
```

Let's also make sure that "minutes" are never negative, and never above 59.

```java
minutes.setMax(59);
minutes.setMin(0);
```

That's all we need to for the internal validation. The browser will automatically indicate to the user that these fields are invalid and what the value expectations are.

Let's also attach this field to a binder and add two validators. For this, we will first have to create an object to bind to.

```java
import java.time.Duration;

public class DurationTutorialDTO {
    private Duration duration;

    public Duration getDuration() {
        return duration;
    }

    public void setDuration(Duration duration) {
        this.duration = duration;
    }
}
```

Now let's create the binder, and bind our field to the duration value.

``` java

var durationField = new DurationField(); // Create our field
durationField.setLabel("Duration");

var binder = new Binder<DurationTutorialDTO>();
binder.forField(durationField)
        .bind(DurationTutorialDTO::getDuration, DurationTutorialDTO::setDuration);
```

We want to make sure that the user enters a value into this field, so let's indicate that this is a required field. For this we will use the `asRequired(..)` method with a custom error message. This will also add the required field indicator to the main label of our component.

```java
var binder = new Binder<DurationTutorialDTO>();
binder.forField(durationField)
    .asRequired("Please provide a valid duration.")
    .bind(DurationTutorialDTO::getDuration, DurationTutorialDTO::setDuration);
```


Next we want to make sure that the entered hours are not more than a week. Depending on our use case, we might be more interested in calculating the minutes, but let's keep this simple.

```java
private final long HOURS_IN_A_WEEK = 24 * 7;
//...
binder.forField(duration4)
       .asRequired("Please provide a valid duration.")
       .withValidator((value, context) -> {
           if (value.toHours() > HOURS_IN_A_WEEK) {
               return ValidationResult.error("Duration cannot exceed " + HOURS_IN_A_WEEK + " hours");
           }
           return ValidationResult.ok();
       })
       .bind(DurationTutorialDTO::getDuration, DurationTutorialDTO::setDuration);
```


Lets also make sure that the invalid state is propagated to internal components, by overriding the `setInvalid(boolean)` method.

```java
    @Override
    public void setInvalid(boolean invalid) {
        super.setInvalid(invalid);
        hours.setInvalid(invalid);
        minutes.setInvalid(invalid);
    }
```

Now lets modify the `generateModelValue()` method to not generate a value, if the internal fields are invalid.
```java
protected Duration generateModelValue() {
    //...
    if (hours.isInvalid() || minutes.isInvalid()) {
        // If any of the fields are invalid, we can not use it to generate a value.
        return null;
    }
    //...
}
```

That's all for validation, our field now has some internal validation and some external validation through Binder. Here's our updated Custom Field:

```java
import com.vaadin.flow.component.customfield.CustomField;
import com.vaadin.flow.component.html.NativeLabel;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.theme.lumo.LumoUtility;

import java.time.Duration;
import java.util.Optional;

public class DurationField extends CustomField<Duration> {
    private static final long MINUTES_IN_HOUR = 60;
    private static final int MINUTES_STEP_INTERVAL = 15;

    private final NativeLabel hoursLabel;
    private final NativeLabel minutesLabel;
    private final IntegerField hours;
    private final IntegerField minutes;
    private final Span and;

    public DurationField() {
        hoursLabel = createHoursLabel();
        minutesLabel = createMinutesLabel();
        hours = createHoursField();
        minutes = createMinutesField();
        and = createAndSpan();

        add(hours, hoursLabel, and, minutes, minutesLabel);
    }

    private NativeLabel createHoursLabel() {
        var label = new NativeLabel("hours");
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private NativeLabel createMinutesLabel() {
        var label = new NativeLabel("minutes");
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private IntegerField createHoursField() {
        var hours = new IntegerField();
        hours.setMin(0);
        hours.setWidth("45px");

        return hours;
    }

    private IntegerField createMinutesField() {
        var minutes = new IntegerField();
        minutes.setWidth("45px");
        minutes.setStep(MINUTES_STEP_INTERVAL);

        return minutes;
    }

    private Span createAndSpan() {
        var andSpan = new Span("and");
        andSpan.addClassNames(LumoUtility.Padding.Left.SMALL, LumoUtility.Padding.Right.SMALL);
        return andSpan;
    }

    @Override
    protected Duration generateModelValue() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            // If any of the fields are empty, we do not have enough to generate a value.
            return null;
        }

        if (hours.isInvalid() || minutes.isInvalid()) {
            // If any of the fields are invalid, we can not use it to generate a value.
            return null;
        }

        var hourMinutes = MINUTES_IN_HOUR * hours.getValue();
        return Duration.ofMinutes(hourMinutes + minutes.getValue());
    }

    @Override
    protected void setPresentationValue(Duration newPresentationValue) {
        var h = (int) newPresentationValue.toHours();
        var m = newPresentationValue.toMinutesPart();
        hours.setValue(h);
        minutes.setValue(m);
    }

    @Override
    public void setInvalid(boolean invalid) {
        super.setInvalid(invalid);
        hours.setInvalid(invalid);
        minutes.setInvalid(invalid);
    }

    @Override
    public void focus() {
        // Make sure component focus targets the hours field.
        hours.focus();
    }
}

```

====

.Step 5 - Localization
[%collapsible]
====

If we have or plan to support multiple languages in our application and our Custom Field, we need provide the developer
with a way to achieve this. The Vaadin Way of doing this is to create a class containing all the necessary localized texts.
For our approach we will only be including all the necessary texts for the elements we have added and that we have not provided API
that would allow us to update them (which would be an alternative approach).

```java
public class DurationFieldI18n implements Serializable {
    private String hours = "hours";
    private String minutes = "minutes";
    private String and = "and";

    public String getHours() {
        return hours;
    }

    public void setHours(String hours) {
        this.hours = hours;
    }

    public String getMinutes() {
        return minutes;
    }

    public void setMinutes(String minutes) {
        this.minutes = minutes;
    }

    public String getAnd() {
        return and;
    }

    public void setAnd(String and) {
        this.and = and;
    }
}
```

Here we provide a default value for each String property, so when this object is created and not modified, it will contain
default values.
This could also be a Java record instead, depending on how you're planning to update and construct this object.

First lets add our object as constructor parameter, and add an no parameter construct that will just use the default values.

```java
private DurationFieldI18n i18n;

public DurationField() {
    this(new DurationFieldI18n());
}

public DurationField(DurationFieldI18n i18n) {
    this.i18n = i18n;
    //...
}
```

Now let's add a method that updates all our relevant elements.

```java
private void updateLabels() {
    hoursLabel.setText(i18n.getHours());
    minutesLabel.setText(i18n.getMinutes());
    and.setText(i18n.getAnd());
}
```

Got to make sure we add a call to this method in our constructor, after all the elements have been initialized.

```java
public DurationField(DurationFieldI18n i18n) {
    //...
    updateLabels();
}
```

Let's also add a way to update and receive our localization object at a later point.

```java
public DurationFieldI18n getI18n() {
    return i18n;
}

public void setI18n(DurationFieldI18n i18n) {
    this.i18n = i18n;
    updateLabels();
}
```

Now when constructing our Custom Field, or at a later point we can provide text in a different language.

```java
var duration = new DurationField(); // Uses default labels initially
//...
duration.setLabel("Ilgums"); // Localized label
duration.setI18n(new DurationFieldI18n("stundas", "minūtes", "un")); // Localized to different language
```


Here's the updated Custom Field code:

```java
import com.vaadin.cf.components.DurationFieldI18n;
import com.vaadin.flow.component.customfield.CustomField;
import com.vaadin.flow.component.html.NativeLabel;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.theme.lumo.LumoUtility;

import java.time.Duration;

public class DurationField extends CustomField<Duration> {
    private static final long MINUTES_IN_HOUR = 60;
    private static final int MINUTES_STEP_INTERVAL = 15;

    private final NativeLabel hoursLabel;
    private final NativeLabel minutesLabel;
    private final IntegerField hours;
    private final IntegerField minutes;
    private final Span and;

    private DurationFieldI18n i18n;

    public DurationField() {
        this(new DurationFieldI18n());
    }

    public DurationField(DurationFieldI18n i18n) {
        this.i18n = i18n;

        hoursLabel = createHoursLabel();
        minutesLabel = createMinutesLabel();
        hours = createHoursField();
        minutes = createMinutesField();
        and = createAndSpan();

        updateLabels();

        add(hours, hoursLabel, and, minutes, minutesLabel);
    }

    private NativeLabel createHoursLabel() {
        var label = new NativeLabel();
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private NativeLabel createMinutesLabel() {
        var label = new NativeLabel();
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private IntegerField createHoursField() {
        var hours = new IntegerField();
        hours.setMin(0);
        hours.setWidth("45px");

        return hours;
    }

    private IntegerField createMinutesField() {
        var minutes = new IntegerField();
        minutes.setWidth("45px");
        minutes.setStep(MINUTES_STEP_INTERVAL);

        return minutes;
    }

    private Span createAndSpan() {
        var andSpan = new Span();
        andSpan.addClassNames(LumoUtility.Padding.Left.SMALL, LumoUtility.Padding.Right.SMALL);
        return andSpan;
    }

    @Override
    protected Duration generateModelValue() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            // If any of the fields are empty, we do not have enough to generate a value.
            return null;
        }

        if (hours.isInvalid() || minutes.isInvalid()) {
            // If any of the fields are invalid, we can not use it to generate a value.
            return null;
        }

        var hourMinutes = MINUTES_IN_HOUR * hours.getValue();
        return Duration.ofMinutes(hourMinutes + minutes.getValue());
    }

    @Override
    protected void setPresentationValue(Duration newPresentationValue) {
        var h = (int) newPresentationValue.toHours();
        var m = newPresentationValue.toMinutesPart();
        hours.setValue(h);
        minutes.setValue(m);
    }

    public DurationFieldI18n getI18n() {
        return i18n;
    }

    public void setI18n(DurationFieldI18n i18n) {
        this.i18n = i18n;
        updateLabels();
    }

    @Override
    public void setInvalid(boolean invalid) {
        super.setInvalid(invalid);
        hours.setInvalid(invalid);
        minutes.setInvalid(invalid);
    }

    @Override
    public void focus() {
        // Make sure component focus targets the hours field.
        hours.focus();
    }

    private void updateLabels() {
        hoursLabel.setText(i18n.getHours());
        minutesLabel.setText(i18n.getMinutes());
        and.setText(i18n.getAnd());
    }
}
```

====

.Step 6 - Accessibility
[%collapsible]
====

Finally, lets make sure we handle all the accessibility issues that we have.
The challenging part here, is that we have the main label ("Duration") and two inputs it should be linked to.
In addition, we have individualized labels for each input ("hours" and "minutes").
From accessibility perspective we want the labels to be read as "Duration hours" and "Duration minutes".
We can achieve this by using `aria-labelledby` on the inputs and referencing both the main label the more specific label.
But, we have to conform to HTML semantics as well, so the labels should still have `for` attributes pointing to related input.
However, `for` attribute only allows for referencing one input, meaning we have to select which input specifically we will use.
It's not important which one you chose as the screen reader will prioritize `aria-labelledby` for reading out input labels.

Let's create method that does all that on JS side, since it will help us avoid generating a separate unique id for our inputs.
It won't be pretty, but it will take care over everything needed.

```java
private void setFor(IntegerField field, NativeLabel label, String labelIdPostfix) {
    field.getElement().executeJs("""
            setTimeout(() => {
              // Find the main label id
              const originalLabelId = $0.getAttribute('aria-labelledby');
              // Create a custom label, based on the original label, making it unique
              const customLabelId = originalLabelId + '-' +  $3;
              // Set the custom label id to our custom label
              $2.id = customLabelId;
              // Make sure our specific input is labeled by the main label and its specific label
              $1.inputElement.setAttribute('aria-labelledby', originalLabelId + " " + customLabelId);

              const inputId = $1.inputElement.id;

              // Make sure main label is associated with some input
              var mainLabel = document.getElementById(originalLabelId);
              mainLabel.setAttribute('for', inputId);
              // Make sure the 'for' attribute for the more specific label is associate with its input
              $2.setAttribute('for', inputId);
            }, 100);""", getElement(), field.getElement(), label.getElement(), labelIdPostfix);
}
```

Let's also update the `aria-description` to provide a description of the full value.

```java
private void updateAriaDescription() {
    getElement().setAttribute("aria-description", valueAsString());
}

private String valueAsString() {
    if (hours.getValue() == null || minutes.getValue() == null) {
        return "";
    }

    return String.format("%d %s %s %d %s", hours.getValue(),
            i18n.getHours(), i18n.getAnd(), minutes.getValue(),
            i18n.getMinutes());
}
```

Next, we actually have to call these methods.
In the constructor:

```java
updateAriaDescription();
setFor(hours, hoursLabel, "hours");
setFor(minutes, minutesLabel, "minutes");
```

We will also need to update the description when any of the values are updated.

Our full code looks like this:

```java
package com.vaadin.cf.components.tutorial;

import com.vaadin.cf.components.DurationFieldI18n;
import com.vaadin.flow.component.customfield.CustomField;
import com.vaadin.flow.component.html.NativeLabel;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.theme.lumo.LumoUtility;

import java.time.Duration;

public class DurationField extends CustomField<Duration> {

    private static final long MINUTES_IN_HOUR = 60;
    private static final int MINUTES_STEP_INTERVAL = 15;

    private final NativeLabel hoursLabel;
    private final NativeLabel minutesLabel;
    private final IntegerField hours;
    private final IntegerField minutes;
    private final Span and;

    private DurationFieldI18n i18n;

    public DurationField() {
        this(new DurationFieldI18n());
    }

    public DurationField(DurationFieldI18n i18n) {
        this.i18n = i18n;

        hoursLabel = createHoursLabel();
        minutesLabel = createMinutesLabel();
        hours = createHoursField();
        minutes = createMinutesField();
        and = createAndSpan();

        updateAriaDescription();
        updateLabels();

        setFor(hours, hoursLabel, "hours");
        setFor(minutes, minutesLabel, "minutes");

        add(hours, hoursLabel, and, minutes, minutesLabel);
    }

    private void setFor(IntegerField field, NativeLabel label, String labelIdPostfix) {
        field.getElement().executeJs("""
                setTimeout(() => {
                  // Find the main label id
                  const originalLabelId = $0.getAttribute('aria-labelledby');
                  // Create a custom label, based on the original label, making it unique
                  const customLabelId = originalLabelId + '-' +  $3;
                  // Set the custom label id to our custom label
                  $2.id = customLabelId;
                  // Make sure our specific input is labeled by the main label and its specific label
                  $1.inputElement.setAttribute('aria-labelledby', originalLabelId + " " + customLabelId);

                  const inputId = $1.inputElement.id;

                  // Make sure main label is associated with some input
                  var mainLabel = document.getElementById(originalLabelId);
                  mainLabel.setAttribute('for', inputId);
                  // Make sure the 'for' attribute for the more specific label is associate with its input
                  $2.setAttribute('for', inputId);
                }, 100);""", getElement(), field.getElement(), label.getElement(), labelIdPostfix);
    }

    private NativeLabel createHoursLabel() {
        var label = new NativeLabel();
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private NativeLabel createMinutesLabel() {
        var label = new NativeLabel();
        label.addClassName(LumoUtility.Padding.Left.SMALL);
        return label;
    }

    private IntegerField createHoursField() {
        var hours = new IntegerField();
        hours.setMin(0);
        hours.setWidth("45px");

        hours.addValueChangeListener(e -> {
            updateAriaDescription();
        });

        return hours;
    }

    private IntegerField createMinutesField() {
        var minutes = new IntegerField();
        minutes.setMax(59);
        minutes.setMin(0);
        minutes.setWidth("45px");
        minutes.setStep(MINUTES_STEP_INTERVAL);

        minutes.addValueChangeListener(e -> {
            updateAriaDescription();
        });

        return minutes;
    }

    private Span createAndSpan() {
        var andSpan = new Span();
        andSpan.addClassNames(LumoUtility.Padding.Left.SMALL, LumoUtility.Padding.Right.SMALL);
        return andSpan;
    }

    @Override
    protected Duration generateModelValue() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            // If any of the fields are empty, we do not have enough to generate a value.
            return null;
        }

        if (hours.isInvalid() || minutes.isInvalid()) {
            // If any of the fields are invalid, we can not use it to generate a value.
            return null;
        }

        var hourMinutes = MINUTES_IN_HOUR * hours.getValue();
        return Duration.ofMinutes(hourMinutes + minutes.getValue());
    }

    @Override
    protected void setPresentationValue(Duration newPresentationValue) {
        var h = (int) newPresentationValue.toHours();
        var m = newPresentationValue.toMinutesPart();
        hours.setValue(h);
        minutes.setValue(m);
        updateAriaDescription();
    }

    public DurationFieldI18n getI18n() {
        return i18n;
    }

    public void setI18n(DurationFieldI18n i18n) {
        this.i18n = i18n;
        updateLabels();
    }

    @Override
    public void setInvalid(boolean invalid) {
        super.setInvalid(invalid);
        hours.setInvalid(invalid);
        minutes.setInvalid(invalid);
    }

    private void updateAriaDescription() {
        getElement().setAttribute("aria-description", valueAsString());
    }

    private String valueAsString() {
        if (hours.getValue() == null || minutes.getValue() == null) {
            return "";
        }

        return String.format("%d %s %s %d %s", hours.getValue(),
                i18n.getHours(), i18n.getAnd(), minutes.getValue(),
                i18n.getMinutes());
    }

    @Override
    public void focus() {
        // Make sure component focus targets the hours field.
        hours.focus();
    }

    private void updateLabels() {
        hoursLabel.setText(i18n.getHours());
        minutesLabel.setText(i18n.getMinutes());
        and.setText(i18n.getAnd());
        updateAriaDescription();
    }
}
```

====

.Final Thoughts
[%collapsible]
====
Getting everything right when building a Custom Field is challenging. When you're starting to build it, start with the basics, make sure its working well for you and fits your use case, and leave the more challenging bits for later.
Accessibility usually is the hardest to get right, so it's good to keep it in mind during the design phase.
Hopefully this guide made you more comfortable implementing Custom Fields.
====
