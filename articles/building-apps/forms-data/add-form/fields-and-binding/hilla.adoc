---
title: Hilla
page-title: How to use fields and data binding in Hilla | Vaadin
meta-description: TODO Write meta-description
order: 10
---


= Fields and Binding in Flow
:toclevels: 2

TODO Write introduction


== Laying Out the Fields

In Hilla, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <</components/form-layout#,Form Layout>>, <</components/vertical-layout#,Vertical Layout>>, and an ordinary `<div>` (with some CSS).  The Form Layout component supports multiple columns, whereas Vertical Layout lays out the components in a single column.

.Layout or <div>?
[TIP]
If you are used to working with Flow, you can continue to work with the familiar layout components in Hilla. If you have a background in React or some other client-side framework, you may feel more comfortable working with `<div>`.

The following example shows how to build a two-column project proposal form with various input components:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
import ProposalType from "Frontend/generated/com/example/application/domain/ProposalType";

export default function ProposalForm() {
    return (
        <FormLayout>
            <TextField label="Title"/>
            <ComboBox label="Proposal Type" items={Object.values(ProposalType)}/> {/* <1> */}
            <TextArea label="Description" data-colspan="2"/> {/* <2> */}
            <DatePicker label="Start Date"/>
            <DatePicker label="End Date"/>
        </FormLayout>
    );
}
----
<1> `ProposalType` is an `enum` in this example.
<2> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::../images/example-form.png[A screenshot of a form]

Form Layout is responsive; when space is limited, it automatically adjusts to a single-column layout, placing each input on its own row. It also includes additional features not covered in this example. For
more information see the <<{articles}/components/form-layout#,Form Layout>> documentation.


== Common Field Components

Vaadin provides a set of *build-in field components* that you can use in your forms:

* *Text Input Components*
  - <<{articles}/components/text-field#,Text Field>> -- For standard single-line text input
  - <<{articles}/components/text-area#,Text Area>> -- For multi-line text input
  - <<{articles}/components/email-field#,Email Field>> -- Specialized field for email addresses
  - <<{articles}/components/password-field#,Password Field>> - Secure field for password entry
  - <<{articles}/components/rich-text-editor#,Rich Text Editor>> - Advanced text editing with formatting options
* *Selection Components*
  - <<{articles}/components/checkbox#,Checkbox>> -- For binary (true/false) selections
  - <<{articles}/components/radio-button#,Radio Button Group>> -- For selecting a single option from a visible list
  - <<{articles}/components/combo-box#,Combo Box>> -- Drop-down for selecting a single option
  - <<{articles}/components/multi-select-combo-box#,Multi-Select Combo Box>> -- Drop-down for selecting multiple options
  - <<{articles}/components/select#,Select>> -- Simple drop-down menu
  - <<{articles}/components/list-box#,List Box>> -- Scrollable list of options
* *Date and Time Components*
  - <<{articles}/components/date-picker#,Date Picker>> -- For selecting a date
  - <<{articles}/components/time-picker#,Time Picker>> -- For selecting a time
  - <<{articles}/components/date-time-picker#,Date Time Picker>> -- For selecting both date and time
* *Numeric Components*
  - <<{articles}/components/number-field#,Number Field>> -- For numeric input


== FDOs and Form Models

In Hilla, FDOs are fetched from and submitted to a *browser-callable application service* for further processing. 
FDOs are implemented in Java, typically as records, although JavaBeans are also possible. 

Hilla *generates the necessary TypeScript interfaces* and takes care of the serialization between Java and JSON. Hilla also generates a *form model*, which is a description of the FDO in TypeScript. This form model is then used by the Hilla binder.

Continuing with the earlier *Project Proposal* form example, you can create a record to represent the FDO:

[source,java]
----
public record Proposal(
    @Nullable Long proposalId,
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

To get Hilla to find this FDO, you have to create a browser-callable service that either returns it or accepts it as a parameter:

[source,java]
----
@BrowserCallable
@AnonymousAllowed
public class ProposalService {

    public void save(Proposal proposal) {
        // Will be implemented later
    }
}
----

For more information about browser-callable services, see the <<../../../business-logic/add-service#,Add a Service>> guide.


== The `useForm` Hook

Hilla offers a `useForm`-hook that binds fields to form model properties, ensuring that changes made in the form update the FDO. When you implement your form as its own component, you should initialize it outside the form and pass the result in as a property.

For example, here is a form component that accepts the result of `useForm` as a required property:

.ProposalForm.tsx
[source,tsx]
----
import { UseFormResult } from "@vaadin/hilla-react-form";
import ProposalModel from "Frontend/generated/com/example/application/tutorial/service/ProposalModel";
// (Other imports omitted for brevity)

export type ProposalFormProps = {
    form: UseFormResult<ProposalModel> // <1>
}

export default function ProposalForm({form}: ProposalFormProps) {
    return (
        <FormLayout>
            ...
        </FormLayout>
    );
}
----
<1> `ProposalModel` is a Hilla form model generated from the `Proposal` FDO.

A parent component that uses the form could look something like this:

.ProposalDrawer.tsx
[source,tsx]
----
import { useForm } from "@vaadin/hilla-react-form";
// (Other imports omitted for brevity)

export default function ProposalDrawer() {
    const form = useForm(ProposalModel);
    return (
        <section>
            <h2>Edit Proposal</h2>
            <ProposalForm form={form}/>
        </section>
    );
}
----

== Binding Fields

To bind a field to a form model property, use the `field` directive from the `useForm` hook:

.ProposalForm.tsx
[source,tsx]
----
// (Imports omitted for brevity)

export type ProposalFormProps = {
    form: UseFormResult<ProposalModel>
}

export default function ProposalForm({form}: ProposalFormProps) {
    return (
        <FormLayout>
            <TextField label="Title" 
                       {...form.field(form.model.title)}/>
            <ComboBox label="Proposal Type" 
                      items={Object.values(ProposalType)} 
                      {...form.field(form.model.type)}/>
            <TextArea label="Description" 
                      data-colspan="2" 
                      {...form.field(form.model.description)}/>
            <DatePicker label="Start Date" 
                        {...form.field(form.model.startDate)}/>
            <DatePicker label="End Date" 
                        {...form.field(form.model.endDate)}/>
        </FormLayout>
    );
}
----


== Accessing the Form State

To access the FDO itself, use the `value` variable. In the example above, `value` is an instance of type `Proposal`. Hilla makes sure the FDO and the form are always in sync.

- Add example of accessing the form state (see the ref guide for details)


== Clearing the Form

To clear the form, the `useForm()` hook provides a `clear()` function:

.ProposalDrawer.tsx
[source,tsx]
----
// (Imports omitted for brevity)

export default function ProposalDrawer() {
    const form = useForm(ProposalModel);
    return (
        <section>
            <h2>Edit Proposal</h2>
            <ProposalForm form={form}/>
            <Button onClick={form.clear}>Clear Form</Button>
        </section>
    );
}
----

Clearing the form also clears the FDO, including unbound properties.


== Reading from an FDO

TODO


== Writing to an FDO

TODO