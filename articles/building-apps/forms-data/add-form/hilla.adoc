---
title: Hilla
page-title: How to add a form to a Hilla view | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 10
---


= Add a Form in Hilla
:toclevels: 2

// TODO Write Introduction
// TODO Review with AI


== Laying Out the Fields

In Hilla, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <<{articles}/components/form-layout#,FormLayout>>, <<{articles}/components/vertical-layout#,VerticalLayout>>, and an ordinary `<div>` (with some CSS). `FormLayout` supports multiple columns, whereas `VerticalLayout` lays out the components in a single column.

.Layout or <div>?
[TIP]
If you are used to working with Flow, you can continue to work with the familiar layout components in Hilla. If you have a background in React or some other client-side framework, you may feel more comfortable working with `<div>`.

The following example shows how to build a two-column project proposal form with various input components:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
import ProposalType from "Frontend/generated/com/example/application/domain/ProposalType";

export default function ProposalForm() {
    return (
        <FormLayout>
            <TextField label="Title"/>
            <ComboBox label="Proposal Type" items={Object.values(ProposalType)}/> {/* <1> */}
            <TextArea label="Description" data-colspan="2"/> {/* <2> */}
            <DatePicker label="Start Date"/>
            <DatePicker label="End Date"/>
        </FormLayout>
    );
}
----
<1> `ProposalType` is an `enum` in this example.
<2> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

`FormLayout` is responsive, which means that if there is not enough room, the layout adjusts to a single column, with each input component on its own row. It also has other features not presented here. For
more information see the <<{articles}/components/form-layout#,FormLayout>> documentation.


== The Form Model

// Some of this section may be better suited for the Overview page, as it is very similar to the Flow text.

Forms are used to display and edit data. This data comes from a *form model*, which has a structure that aligns with the fields of the form. Each field in the form is typically mapped to a corresponding property in the model.

In Hilla, form models are fetched from and submitted to a *browser-callable application service* for further processing. From an architectural point of view, *the form models belong to the application layer* rather than the presentation layer.

Form models are implemented in Java, typically as records, although JavaBeans are also possible. Hilla  generates the necessary TypeScript interfaces and takes care of the serialization between Java and JSON.

Continuing with the earlier *Project Proposal* form example, you can create a record to represent the form model:

[source,java]
----
public record Proposal(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

To get Hilla to find this form model, you have to create a browser-callable service that either returns it or accepts it as a parameter:

[source,java]
----
@BrowserCallable
@AnonymousAllowed
public class ProposalService {

    public void insert(Proposal proposal) {
        // Will be implemented later
    }
}
----

For more information about browser-callable services, see the <<../../business-logic/add-service#,Add a Service>> guide.


== Binding Fields

Hilla offers a `useForm`-hook that binds fields to form model properties, ensuring that changes made in the form update the model. Initialize it like this:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
// tag::snippet[]
import { useForm } from "@vaadin/hilla-react-form";
// end::snippet[]
import ProposalType from "Frontend/generated/com/example/application/tutorial/domain/ProposalType";
// tag::snippet[]
import ProposalModel from "Frontend/generated/com/example/application/tutorial/service/ProposalModel";
// end::snippet[]

export default function ProposalForm() {
// tag::snippet[]
    const { field, model, value } = useForm(ProposalModel); // <1>
// end::snippet[]

    return (
        <FormLayout>
            ...
        </FormLayout>
    );
}
----
<1> `ProposalModel` is generated by Hilla from the `Proposal` Java record. 

To bind a field to a form model property, use the `field` directive:

.ProposalForm.tsx
[source,tsx]
----
// Imports omitted for clarity.

function ProposalForm() {
    const { field, model, value } = useForm(ProposalModel)
// tag::snippet[]
    return (
        <FormLayout>
            <TextField label="Title" 
                       {...field(model.title)}/>
            <ComboBox label="Proposal Type" 
                      items={Object.values(ProposalType)} 
                      {...field(model.type)}/>
            <TextArea label="Description" 
                      data-colspan="2" 
                      {...field(model.description)}/>
            <DatePicker label="Start Date" 
                        {...field(model.startDate)}/>
            <DatePicker label="End Date" 
                        {...field(model.endDate)}/>
        </FormLayout>
    );
// end::snippet[]
}
----

To access the data of the form model, use the `value` variable. In the example above, `value` is an instance of type `Proposal`. Hilla makes sure this object and the form are always in sync.


// == Try It

// TODO Add mini tutorial later