---
title: Hilla
page-title: How to add a form to a Hilla view | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 10
---


= Add a Form in Hilla
:toclevels: 2

TODO Write Introduction
// TODO Review with AI


== Laying Out the Fields

In Hilla, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <</components/form-layout#,Form Layout>>, <</components/vertical-layout#,Vertical Layout>>, and an ordinary `<div>` (with some CSS).  The Form Layout component supports multiple columns, whereas Vertical Layout lays out the components in a single column.

.Layout or <div>?
[TIP]
If you are used to working with Flow, you can continue to work with the familiar layout components in Hilla. If you have a background in React or some other client-side framework, you may feel more comfortable working with `<div>`.

The following example shows how to build a two-column project proposal form with various input components:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
import ProposalType from "Frontend/generated/com/example/application/domain/ProposalType";

export default function ProposalForm() {
    return (
        <FormLayout>
            <TextField label="Title"/>
            <ComboBox label="Proposal Type" items={Object.values(ProposalType)}/> {/* <1> */}
            <TextArea label="Description" data-colspan="2"/> {/* <2> */}
            <DatePicker label="Start Date"/>
            <DatePicker label="End Date"/>
        </FormLayout>
    );
}
----
<1> `ProposalType` is an `enum` in this example.
<2> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

Form Layout is responsive; when space is limited, it automatically adjusts to a single-column layout, placing each input on its own row. It also includes additional features not covered in this example. For
more information see the <<{articles}/components/form-layout#,Form Layout>> documentation.


== Displaying Forms in Dialogs

In business applications, dialogs are commonly used for creating new items, while drawers are typically used for editing existing ones. By implementing the form as a component of its own, you can reuse it in both dialogs and drawers.

[source,tsx]
----
export type ProposalDialogProps = {
    opened?: boolean,
    onOpenedChanged?: (opened: boolean) => void
}

export function ProposalDialog(props: ProposalDialogProps) {
    const opened = useSignal(props.opened);

    const close = () => {
        opened.value = false;
        props.onOpenedChanged && props.onOpenedChanged(false);
    }

    // The Create button does not do anything yet.
    const footer = (<>
        <Button theme={"primary"}>Create Proposal</Button>
        <Button onClick={close}>Cancel</Button>
    </>);

    return (
        <Dialog opened={opened.value} header-title="New Proposal" footer={footer}
                onOpenedChanged={e => props.onOpenedChanged && props.onOpenedChanged(e.detail.value)}>
            <ProposalForm/>
        </Dialog>
    );
}
----

== Displaying Forms in Drawers


