---
title: Hilla
page-title: How to add a form to a Hilla view | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 10
---


= Add a Form in Hilla
:toclevels: 2

TODO Write Introduction
// TODO Review with AI


== Laying Out the Fields

In Hilla, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <</components/form-layout#,Form Layout>>, <</components/vertical-layout#,Vertical Layout>>, and an ordinary `<div>` (with some CSS).  The Form Layout component supports multiple columns, whereas Vertical Layout lays out the components in a single column.

.Layout or <div>?
[TIP]
If you are used to working with Flow, you can continue to work with the familiar layout components in Hilla. If you have a background in React or some other client-side framework, you may feel more comfortable working with `<div>`.

The following example shows how to build a two-column project proposal form with various input components:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
import ProposalType from "Frontend/generated/com/example/application/domain/ProposalType";

export default function ProposalForm() {
    return (
        <FormLayout>
            <TextField label="Title"/>
            <ComboBox label="Proposal Type" items={Object.values(ProposalType)}/> {/* <1> */}
            <TextArea label="Description" data-colspan="2"/> {/* <2> */}
            <DatePicker label="Start Date"/>
            <DatePicker label="End Date"/>
        </FormLayout>
    );
}
----
<1> `ProposalType` is an `enum` in this example.
<2> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

Form Layout is responsive, which means that if there is not enough room, the layout adjusts to a single column, with each input component on its own row. It also has other features not presented here. For
more information see the <<{articles}/components/form-layout#,Form Layout>> documentation.


== Form Data Object and Form Model

// Some of this section may be better suited for the Overview page, as it is very similar to the Flow text.

Forms are used to display and edit data. This data comes from a *Form Data Object (FDO)*, which has a structure that aligns with the fields of the form. Each field in the form is typically mapped to a corresponding property in the FDO.

In Hilla, FDO:s are fetched from and submitted to a *browser-callable application service* for further processing. From an architectural point of view, *an FDO belongs to the application layer* rather than the presentation layer.

FDO:s are implemented in Java, typically as records, although JavaBeans are also possible. Hilla generates the necessary TypeScript interfaces and takes care of the serialization between Java and JSON. Hilla also generates a *form model*, which is a description of the FDO in TypeScript. This form model is then used by the Hilla binder.

[NOTE]
You can use your entities as FDO:s if the forms and entities structurally match each other. However, this couples your domain logic to the UI. This can create maintainability issues, for instance if UI requirements and business logic evolve in different directions.

Continuing with the earlier *Project Proposal* form example, you can create a record to represent the FDO:

[source,java]
----
public record Proposal(
    @Nullable Long proposalId,
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

To get Hilla to find this FDO, you have to create a browser-callable service that either returns it or accepts it as a parameter:

[source,java]
----
@BrowserCallable
@AnonymousAllowed
public class ProposalService {

    public void save(Proposal proposal) {
        // Will be implemented later
    }
}
----

For more information about browser-callable services, see the <<../../business-logic/add-service#,Add a Service>> guide.


== Binding Fields

Hilla offers a `useForm`-hook that binds fields to form model properties, ensuring that changes made in the form update the FDO. Initialize it like this:

.ProposalForm.tsx
[source,tsx]
----
import { ComboBox, DatePicker, FormLayout, TextArea, TextField } from "@vaadin/react-components";
// tag::snippet[]
import { useForm } from "@vaadin/hilla-react-form";
// end::snippet[]
import ProposalType from "Frontend/generated/com/example/application/tutorial/domain/ProposalType";
// tag::snippet[]
import ProposalModel from "Frontend/generated/com/example/application/tutorial/service/ProposalModel";
// end::snippet[]

export default function ProposalForm() {
// tag::snippet[]
    const { field, model, value } = useForm(ProposalModel); // <1>
// end::snippet[]

    return (
        <FormLayout>
            ...
        </FormLayout>
    );
}
----
<1> `ProposalModel` is the form model generated by Hilla from the `Proposal` FDO.

To bind a field to a form model property, use the `field` directive:

.ProposalForm.tsx
[source,tsx]
----
// Imports omitted for clarity.

function ProposalForm() {
    const { field, model, value } = useForm(ProposalModel)
// tag::snippet[]
    return (
        <FormLayout>
            <TextField label="Title" 
                       {...field(model.title)}/>
            <ComboBox label="Proposal Type" 
                      items={Object.values(ProposalType)} 
                      {...field(model.type)}/>
            <TextArea label="Description" 
                      data-colspan="2" 
                      {...field(model.description)}/>
            <DatePicker label="Start Date" 
                        {...field(model.startDate)}/>
            <DatePicker label="End Date" 
                        {...field(model.endDate)}/>
        </FormLayout>
    );
// end::snippet[]
}
----

To access the FDO itself, use the `value` variable. In the example above, `value` is an instance of type `Proposal`. Hilla makes sure the FDO and the form are always in sync.


== Clearing the Form

To clear the form, the `useForm()` hook provides a `clear()` function:

.ProposalForm.tsx
[source,tsx]
----
// Imports omitted for clarity.

function ProposalForm() {
// tag::snippet[]
    const { field, model, value, clear } = useForm(ProposalModel)
// end::snippet[]
    return (
        <FormLayout>
            ...
            <Button onClick={clear}>Clear Form</Button>
        </FormLayout>
    );
}
----

Clearing the form also clears the FDO, including unbound properties.

// == Try It

// TODO Add mini tutorial later
