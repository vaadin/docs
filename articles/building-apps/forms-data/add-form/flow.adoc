---
title: Flow
page-title: How to add a form to a Flow view | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 5
---


// TODO Add tutorial
// TODO Re-write introduction
// TODO Review with AI

= Add a Form in Flow
:toclevels: 2

In this guide, you'll learn the basics of creating a form in Flow and binding it to a form data object. You'll learn the difference between using a JavaBean and a Java record as form data object, and their pros and cons. Because data binding in Flow is a large topic, this guide only contains enough to get you started. For more details, see Flow's <<{articles}/flow/binding-data#,Forms & Data Binding>> reference guide.


== Laying Out the Fields

In Flow, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <<{articles}/components/form-layout#,FormLayout>> and <<{articles}/components/vertical-layout#,VerticalLayout>>. `FormLayout` supports multiple columns, whereas `VerticalLayout` lays out the components in a single column. You also often end up combining these with <<{articles}/components/horizontal-layout#,HorizontalLayout>>, which lays out its components in a single row.

[IMPORTANT]
Layout components are not the same as router layouts. However, you can build a router layout using layout components.

The follow example shows how to build a two-column project proposal form with various input components:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> { // <1>

    public ProposalForm() {
        var titleField = new TextField("Title");
        getContent().add(titleField); // <2>

        var proposalTypeField = new ComboBox<ProposalType>("Proposal Type");
        proposalTypeField.setItems(ProposalType.values());
        getContent().add(proposalTypeField);

        var descriptionField = new TextArea("Description");
        getContent().add(descriptionField);
        getContent().setColspan(descriptionField, 2); // <3>

        var startDateField = new DatePicker("Start Date");
        getContent().add(startDateField);

        var endDateField = new DatePicker("End Date");
        getContent().add(endDateField);
    }
}
----
<1> `Composite` hides the API of `FormLayout` from users of `ProposalForm`, reducing the risk of misuse.
<2> `getContent()` returns the `FormLayout`.
<3> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

`FormLayout` is responsive, which means that if there is not enough room, the layout adjusts to a single column, with each input component on its own row. It also has other features not presented here. For
more information see the <<{articles}/components/form-layout#,FormLayout>> documentation.


== Introducing Form Data Object (FDO)

Forms are used to display and edit data. This data comes from a *Form Data Object* (FDO), which has a structure that aligns with the fields of the form. Each field in the form is typically mapped to a corresponding property in the FDO.

FDO:s are often fetched from and submitted to an <<../../business-logic/add-service#,application service>> for further processing, such as validation, and persistence. From an architectural point of view, *an FDO belongs to the application layer* rather than the presentation layer.


== Introducing Binder

Vaadin offers a [classname]`Binder` class that binds fields to FDO properties, ensuring that changes made in the form update the FDO. For each field-property pair, the `Binder` creates a new `Binding` object. However, since Binder is one-directional, *updates to the FDO outside of the `Binding` won't automatically reflect in the form fields* unless manually refreshed.

When loading a form, it populates fields with corresponding property values. When saving, it updates the FDO with the modified field values.

You can attach a converter to a `Binding` to transform between field values and FDO properties with different types. For example, a `String` field can be converted into an `EmailAddress` object in the FDO. You can also attach validators to ensure the input meets specific constraints, such as requiring a non-empty email.


== Types of FDO:s

The FDO can be a simple data container that only holds values, or it can be a more advanced class that includes business logic, such as validation rules. Each approach has its own advantages and trade-offs, depending on the complexity of the application and the level of control needed over the data.


=== Simple FDO:s

Simple FDO:s are typically implemented as records. *Every field in the form corresponds to a record component.*

When the form is loaded, the `Binder` populates each field with data from the corresponding record component. When the form is saved, the `Binder` creates a new record instance from the data in the form. You can then send the record to an application service for processing.

Java records are compact and require no boilerplate code. Furthermore, records are immutable. This clarifies when a form is loaded and saved, and reduces the risk for bugs.


=== Advanced FDO:s

Advanced FDO:s are typically implemented as JavaBeans. *Every field in the form corresponds to a getter method and a setter method.* If a field is read-only, you can leave out the setter method.

.JavaBean Conventions Are Optional
[IMPORTANT]
You can name your getters and setters any way you like, as long as their method descriptors match what's expected for property access methods. A getter should take no parameters and return a value, while a setter should accept a single parameter and return `void`.

You can add business logic to the setters. For instance, you could perform validation, or maintain a change log inside the bean.

When a form is loaded, the `Binder` populates each field with data from the corresponding getter. When the form is saved, the `Binder` calls the setters to update the bean with data in the form. You can then send the bean to an application service for processing.

Beans allow you to make more advanced forms, but also require more boilerplate code than records. Furthermore, since they are mutable, there is a higher risk of bugs, especially when rolling back changes.


=== Entities as FDO:s

In simple cases, such as CRUD-views and administration screens, the form model and the domain model may be the same. In that case, you can use your entities as FDO:s. However, using entities as FDO:s tightly couples your domain logic to the UI. This can create maintainability issues, especially if UI requirements evolve separately from the business logic. If this happens, it's better to introduce a dedicated FDO and handle data conversion in the application service.


== Binding to a Bean

Continuing with the earlier *Project Proposal* form example, you can create a JavaBean to represent the FDO:

.ProposalBean.java
[source,java]
----
public class ProposalBean {
    private String title;
    private ProposalType type;
    private String description;
    private LocalDate startDate;
    private LocalDate endDate;

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public ProposalType getType() {
        return type;
    }
    public void setType(ProposalType type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDate getStartDate() {
        return startDate;
    }
    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getEndDate() {
        return endDate;
    }
    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }
}
----

To bind this bean to the form, create a [classname]`Binder` instance and register each form field:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<ProposalBean> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

// tag::snippet[]
        binder = new Binder<>();
        binder.forField(titleField) // <1>
            // Converters and validators would go here
            .bind(ProposalBean::getTitle, ProposalBean::setTitle); // <2>
        binder.forField(proposalTypeField)
            .bind(ProposalBean::getType, ProposalBean::setType);
        binder.forField(descriptionField)
            .bind(ProposalBean::getDescription, ProposalBean::setDescription);
        binder.forField(startDateField)
            .bind(ProposalBean::getStartDate, ProposalBean::setStartDate);
        binder.forField(endDateField)
            .bind(ProposalBean::getEndDate, ProposalBean::setEndDate);
// end::snippet[]
    }
}
----
<1> Creates a `Binding` for `titleField`.
<2> Uses getter and setter methods for binding.


=== Buffered vs. Write-Through

When using a JavaBean as an FDO, `Binder` can operate in *buffered* or *write-through* mode.

* *Buffered mode*: Changes remain in the form until explicitly saved. This prevents side effects but may affect validation behavior.
* *Write-through mode*: Updates the FDO immediately as the user edits the form. Business logic in setter methods is triggered immediately. However, invalid states can occur where the form contains errors, but the FDO remains valid.

Form validation is covered in the <<../validate-form#,Validate a Form>> guide.


=== Reading from a Bean

To populate a form in *buffered mode*, use `Binder.readBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(ProposalBean formDataObject) {
        binder.readBean(formDataObject);
    }
// end::snippet[]
}
----

For *write-through mode*, use `Binder.setBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void bind(ProposalBean formDataObject) {
        binder.setBean(formDataObject);
    }
// end::snippet[]
}
----


=== Writing to a Bean

In *buffered mode*, use `Binder.writeBeanIfValid()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void read(ProposalBean formDataObject) {
        binder.readBean(formDataObject);
    }

// tag::snippet[]
    public boolean write(ProposalBean formDataObject) {
        return binder.writeBeanIfValid(formDataObject); // <1>
    }    
// end::snippet[]
}
----
<1> Returns `true` if validation succeeds, `false` otherwise.

.Other methods for writing to a bean
[%collapsible]
====
The `Binder` class provides four methods for writing form data to an FDO:

`writeBean` :: Validates the entire form and writes all values to the FDO if validation passes. Throws an exception if validation fails.
`writeBeanAsDraft` :: Writes all valid values to the FDO while ignoring invalid values. No exception is thrown.
`writeBeanIfValid` :: Validates the form and writes all values if validation passes. Returns false (rather than throwing an exception) if validation fails.
`writeChangedBindingsToBean` :: Validates the entire form but only writes modified fields to the FDO if validation passes. Throws an exception if validation fails.

Some methods have overloaded versions that allow you to further customize the write operation. See the JavaDocs for details.
====

In *write-through mode*, no explicit write operation is needed. However, always check form validity before processing:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void bind(ProposalBean formDataObject) {
        binder.setBean(formDataObject);
    }

// tag::snippet[]
    public boolean isValid() {
        return binder.validate().isOk();
    }
// end::snippet[]
}
----


=== Clearing the Form

To clear the form in *buffered mode*, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void read(ProposalBean formDataObject) {
        binder.readBean(formDataObject);
    }

    public boolean write(ProposalBean formDataObject) {
        return binder.writeBeanIfValid(formDataObject);
    }

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----

In *write-through mode*, unbind the FDO by setting it to `null`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void bind(ProposalBean formDataObject) {
        binder.setBean(formDataObject);
    }

    public boolean isValid() {
        return binder.validate().isOk();
    }

// tag::snippet[]
    public void unbind() {
        binder.setBean(null);
    }
// end::snippet[]
}
----


== Binding to a Record

The equivalent *Project Proposal* FDO using a *record* looks like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

Unlike JavaBeans, records do not have setters. Instead, `Binder` uses *string-based mapping* to bind form fields to record components. You also need to specify the record class when creating the binder:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<ProposalRecord> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

 // tag::snippet[]
        binder = new Binder<>(ProposalRecord.class); // <1>
        binder.forField(titleField)
            // Converters and validators would go here
            .bind("title"); // <2>
        binder.forField(proposalTypeField).bind("type");
        binder.forField(descriptionField).bind("description");
        binder.forField(startDateField).bind("startDate");
        binder.forField(endDateField).bind("endDate");
// end::snippet[]
    }
}
----
<1> Passes the `ProposalRecord` record class to the `Binder` constructor.
<2> Uses record component names as string literals.


=== Avoiding Invalid Record Component Names

If you rename a record component but forget to update the corresponding `Binding`, it will only cause an error at runtime. The `bind()` method would notice that no such record component exists, and throw an exception.

To mitigate this, you can create a unit test that instantiates the form, like this:

.ProposalFormTest.java
[source,java]
----
class ProposalFormTest {
    @Test
    void instantiating_form_throws_no_exceptions() {
        new ProposalForm();
    }
}
----

Since the `bind()` method is called in the constructor, this test would fail if it tried to bind a field to a non-existent record component.

To reduce this risk, you can also use constants for record component names instead of string literals. The constants could look like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
    public static final String PROP_TITLE = "title";
    public static final String PROP_TYPE = "type";
    // And so on...
}
----

And you would use them with `Binder` like this:

[source,java]
----
binder.forField(titleField).bind(ProposalRecord.PROP_TITLE);
binder.forField(proposalTypeField).bind(ProposalRecord.PROP_TYPE);
// And so on...
----


=== Reading from a Record

To populate the form from a record, use `Binder.readRecord()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }
// end::snippet[]
}
----


=== Writing to a Record

Since records are immutable, `Binder.writeRecord()` creates a new instance:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }

// tag::snippet[]
    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord()); // <1>
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty(); // <2>
        }
    }
// end::snippet[]
}
----
<1> Returns a new `ProposalRecord` if validation succeeds.
<2> Returns an empty `Optional` if validation fails.


=== Clearing the Form

To clear the form, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    public ProposalForm() {
        // Constructor implementation omitted for clarity
        // ...
    }

    public void read(ProposalRecord formDataObject) {
        binder.readRecord(formDataObject);
    }

    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord());
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty();
        }
    }

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----

//== Best Practices

// TODO Explain how to pick the correct FDO type

== Try It

- Add a tutorial here

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.