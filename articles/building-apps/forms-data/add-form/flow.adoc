---
title: Flow
page-title: How to add a form to a Flow view | Vaadin
description: TODO Write description
meta-description: TODO Write meta-description
order: 5
---


= Add a Form in Flow
:toclevels: 2

In this guide, you'll learn the basics of creating a form in Flow and binding it to a form model. You'll learn the difference between using a JavaBean and a Java record as form model, and their pros and cons. Because data binding in Flow is a large topic, this guide only contains enough to get you started. For more details, see Flow's <<{articles}/flow/binding-data#,Forms & Data Binding>> reference guide.


== Laying Out the Fields

In Flow, you build the form visually by *adding input components to a layout component*. The most common layout components for forms are <<{articles}/components/form-layout#,FormLayout>> and <<{articles}/components/vertical-layout#,VerticalLayout>>. `FormLayout` supports multiple columns, whereas `VerticalLayout` lays out the components in a single column. You also often end up combining these with <<{articles}/components/horizontal-layout#,HorizontalLayout>>, which lays out its components in a single row.

[IMPORTANT]
Layout components are not the same as router layouts. However, you can build a router layout using layout components.

The follow example shows how to build a two-column project proposal form with various input components:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> { // <1>

    public ProposalForm() {
        var title = new TextField("Title");
        getContent().add(title); // <2>

        var proposalType = new ComboBox<ProposalType>("Proposal Type");
        proposalType.setItems(ProposalType.values());
        getContent().add(proposalType);

        var description = new TextArea("Description");
        getContent().add(description);
        getContent().setColspan(description, 2); // <3>

        var startDate = new DatePicker("Start Date");
        getContent().add(startDate);

        var endDate = new DatePicker("End Date");
        getContent().add(endDate);
    }
}
----
<1> `Composite` hides the API of `FormLayout` from users of `ProposalForm`, reducing the risk of misuse.
<2> `getContent()` returns the `FormLayout`.
<3> Since `FormLayout` has two columns by default, this makes the description field take up the full width of the layout.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

`FormLayout` is responsive, which means that if there is not enough room, the layout adjusts to a single column, with each input component on its own row. It also has other features not presented here. For
more information see the <<{articles}/components/form-layout#,FormLayout>> documentation.


== Introducing Form Model

// Some of this section may be better suited for the Overview page than under Flow. It depends on the Hilla-article.
Forms are used to display and edit data. This data comes from a *form model*, which has a structure that aligns with the fields of the form. Each field in the form is typically mapped to a corresponding property in the model.

Form models are often fetched from and submitted to an <<../../business-logic/add-service#,application service>> for further processing, such as validation, and persistence. From an architectural point of view, *the form models belong to the application layer* rather than the presentation layer.
// When signal is added to the mix, we get a View Model, whereas the form model takes the role of the M in MVVM.


== Introducing Binder

Vaadin offers a [classname]`Binder` class that binds fields to form model properties, ensuring that changes made in the form update the model. For each field-property pair, the `Binder` creates a new `Binding` object. However, since Binder is one-directional, *updates to the model outside of the `Binding` won't automatically reflect in the form fields* unless manually refreshed.

When loading a form, it populates fields with corresponding property values. When saving, it updates the model with the modified field values.

You can attach a converter to a `Binding` to transform between field values and model properties with different types. For example, a `String` field can be converted into an `EmailAddress` object in the model. You can also attach validators to ensure the input meets specific constraints, such as requiring a non-empty email.


== Types of Form Models

The form model can be a simple data container that only holds values, or it can be a more advanced model that includes business logic, such as validation rules. Each approach has its own advantages and trade-offs, depending on the complexity of the application and the level of control needed over the data.


=== Simple Form Models

Simple form models are typically implemented as records. *Every field in the form corresponds to a record component.*

When the form is loaded, the `Binder` populates each field with data from the corresponding record component. When the form is saved, the `Binder` creates a new record instance from the data in the form. You can then send the record to an application service for processing.

Java records are compact and require no boilerplate code. Furthermore, records are immutable. This clarifies when a form is loaded and saved, and reduces the risk for bugs.


=== Advanced Form Models

Advanced form models are typically implemented as JavaBeans. *Every field in the form corresponds to a getter method and a setter method.* If a field is read-only, you can leave out the setter method.

.JavaBean Conventions Are Optional
[IMPORTANT]
You can name your getters and setters any way you like, as long as their method descriptors match what's expected for property access methods. A getter should take no parameters and return a value, while a setter should accept a single parameter and return `void`.

You can add business logic to the setters. For instance, you could perform validation, or maintain a change log inside the bean.

When a form is loaded, the `Binder` populates each field with data from the corresponding getter. When the form is saved, the `Binder` calls the setters to update the bean with data in the form. You can then send the bean to an application service for processing.

Beans allow you to make more advanced forms, but also require more boilerplate code than records. Furthermore, since they are mutable, there is a higher risk of bugs, especially when rolling back changes.


=== Entities as Form Models

In simple cases, such as CRUD-views and administration screens, the form model and the domain model may be the same. In that case, you can use your entities as form models. However, using entities as form models tightly couples your domain logic to the UI. This can create maintainability issues, especially if UI requirements evolve separately from the business logic. If this happens, it's better to introduce a dedicated form model and handle data conversion in the application service.


== Binding to a Bean

Continuing with the earlier *Project Proposal* form example, you can create a JavaBean to represent the form model:

.ProposalBean.java
[source,java]
----
public class ProposalBean {
    private String title;
    private ProposalType type;
    private String description;
    private LocalDate startDate;
    private LocalDate endDate;

    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }

    public ProposalType getType() {
        return type;
    }
    public void setType(ProposalType type) {
        this.type = type;
    }

    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDate getStartDate() {
        return startDate;
    }
    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public LocalDate getEndDate() {
        return endDate;
    }
    public void setEndDate(LocalDate endDate) {
        this.endDate = endDate;
    }
}
----

To bind this bean to the form, create a [classname]`Binder` instance and register each form field:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<ProposalBean> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

// tag::snippet[]
        binder = new Binder<>();
        binder.forField(title) // <1>
            // Converters and validators would go here
            .bind(ProposalBean::getTitle, ProposalBean::setTitle); // <2>
        binder.forField(proposalType)
            .bind(ProposalBean::getType, ProposalBean::setType);
        binder.forField(description)
            .bind(ProposalBean::getDescription, ProposalBean::setDescription);
        binder.forField(startDate)
            .bind(ProposalBean::getStartDate, ProposalBean::setStartDate);
        binder.forField(endDate)
            .bind(ProposalBean::getEndDate, ProposalBean::setEndDate);
// end::snippet[]
    }
}
----
<1> Creates a `Binding` for the `title` field.
<2> Uses getter and setter methods for binding.


=== Buffered vs. Write-Through

When using a JavaBean as a form model, `Binder` can operate in *buffered* or *write-through* mode.

* *Buffered mode*: Changes remain in the form until explicitly saved. This prevents side effects but may affect validation behavior.
* *Write-through mode*: Updates the model immediately as the user edits the form. Business logic in setter methods is triggered immediately. However, invalid states can occur where the form contains errors, but the model remains valid.

Form validation is covered in the <<../validate-form#,Validate a Form>> guide.


=== Reading from a Bean

To populate a form in *buffered mode*, use `Binder.readBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(ProposalBean formModel) {
        binder.readBean(formModel);
    }
// end::snippet[]
}
----

For *write-through mode*, use `Binder.setBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void bind(ProposalBean formModel) {
        binder.setBean(formModel);
    }
// end::snippet[]
}
----


=== Writing to a Bean

In *buffered mode*, use `Binder.writeBean()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void read(ProposalBean formModel) {
        binder.readBean(formModel);
    }

// tag::snippet[]
    public boolean write(ProposalBean formModel) {
        try {
            binder.writeBean(formModel);
            return true; // <1>
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return false; // <2>
        }
    }    
// end::snippet[]
}
----
<1> Returns `true` if validation succeeds.
<2> Returns `false` if validation fails.

In *write-through mode*, no explicit write operation is needed. However, always check form validity before processing:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void bind(ProposalBean formModel) {
        binder.setBean(formModel);
    }

// tag::snippet[]
    public boolean isValid() {
        return binder.validate().isOk();
    }
// end::snippet[]
}
----


=== Clearing the Form

To clear the form in *buffered mode*, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void read(ProposalBean formModel) {
        binder.readBean(formModel);
    }

    public boolean write(ProposalBean formModel) {
        try {
            binder.writeBean(formModel);
            return true;
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return false;
        }
    }    

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----

In *write-through mode*, unbind the model by setting it to `null`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalBean> binder;

    // Constructor omitted for clarity

    public void bind(ProposalBean formModel) {
        binder.setBean(formModel);
    }

    public boolean isValid() {
        return binder.validate().isOk();
    }

// tag::snippet[]
    public void unbind() {
        binder.setBean(null);
    }
// end::snippet[]
}
----


== Binding to a Record

The equivalent *Project Proposal* form model using a *record* looks like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
}
----

Unlike JavaBeans, records do not have setters. Instead, `Binder` uses *string-based mapping* to bind form fields to record components. You also need to specify the record class when creating the binder:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

// tag::snippet[]
    private final Binder<ProposalRecord> binder;
// end::snippet[]

    public ProposalForm() {
        // Creating and adding fields omitted for clarity

 // tag::snippet[]
        binder = new Binder<>(ProposalRecord.class); // <1>
        binder.forField(title)
            // Converters and validators would go here
            .bind("title"); // <2>
        binder.forField(proposalType).bind("type");
        binder.forField(description).bind("description");
        binder.forField(startDate).bind("startDate");
        binder.forField(endDate).bind("endDate");
// end::snippet[]
    }
}
----
<1> Passes the `ProposalRecord` record class to the `Binder` constructor.
<2> Uses record component names as string literals.


=== Avoiding Invalid Record Component Names

If you rename a record component but forget to update the corresponding `Binding`, it will only cause an error at runtime. The `bind()` method would notice that no such record component exists, and throw an exception.

To mitigate this, you can create a unit test that instantiates the form, like this:

.ProposalFormTest.java
[source,java]
----
class ProposalFormTest {
    @Test
    void instantiating_form_throws_no_exceptions() {
        new ProposalForm();
    }
}
----

Since the `bind()` method is called in the constructor, this test would fail if it tried to bind a field to a non-existent record component.

To reduce this risk, you can also use constants for record component names instead of string literals. The constants could look like this:

.ProposalRecord.java
[source,java]
----
public record ProposalRecord(
    String title, 
    ProposalType type, 
    String description, 
    LocalDate startDate, 
    LocalDate endDate
) {
    public static final String PROP_TITLE = "title";
    public static final String PROP_TYPE = "type";
    // And so on...
}
----

And you would use them with `Binder` like this:

[source,java]
----
binder.forField(title).bind(ProposalRecord.PROP_TITLE);
binder.forField(proposalType).bind(ProposalRecord.PROP_TYPE);
// And so on...
----


=== Reading from a Record

To populate the form from a record, use `Binder.readRecord()`:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

// tag::snippet[]
    public void read(ProposalRecord formModel) {
        binder.readRecord(formModel);
    }
// end::snippet[]
}
----


=== Writing to a Record

Since records are immutable, `Binder.writeRecord()` creates a new instance:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    // Constructor omitted for clarity

    public void read(ProposalRecord formModel) {
        binder.readRecord(formModel);
    }

// tag::snippet[]
    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord()); // <1>
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty(); // <2>
        }
    }
// end::snippet[]
}
----
<1> Returns a new `ProposalRecord` if validation succeeds.
<2> Returns an empty `Optional` if validation fails.


=== Clearing the Form

To clear the form, refresh the fields:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> {

    private final Binder<ProposalRecord> binder;

    public ProposalForm() {
        // Constructor implementation omitted for clarity
        // ...
    }

    public void read(ProposalRecord formModel) {
        binder.readRecord(formModel);
    }

    public Optional<ProposalRecord> write() {
        try {
            return Optional.of(binder.writeRecord());
        } catch (ValidationException ex) {
            // Binder already shows the error messages.
            return Optional.empty();
        }
    }

// tag::snippet[]
    public void clear() {
        binder.refreshFields();
    }
// end::snippet[]
}
----

//== Best Practices

// TODO Explain how to pick the correct form model

// == Try It

// TODO Add mini tutorial later. It should be about creating a proper form for adding new tasks to the todo list.