---
title: Flow
page-title: How to build a form in Flow | Vaadin
meta-description: Build responsive forms in Vaadin using Flow. Learn how to display forms in dialogs and drawers with callbacks, data binding, and reusable components.
order: 5
---


= Add a Form in Flow
:toclevels: 2

This guide teaches you how to visually build forms in Flow and display them in dialogs and drawers.


== Laying Out the Fields

In Flow, forms you build forms visually by *adding input components to layout components*. The most commonly used layout components for forms include <<{articles}/components/form-layout#,Form Layout>> and <<{articles}/components/vertical-layout#,Vertical Layout>>. Form Layout supports multiple columns, whereas Vertical Layout lays out the components in a single column. These are often combined with <<{articles}/components/horizontal-layout#,Horizontal Layout>>, which lays out its components in a single row.

[IMPORTANT]
Layout components differ from router layouts, although you can construct a router layout using them.

The following example demonstrates how to build a two-column project proposal form using various input components:

.ProposalForm.java
[source,java]
----
public class ProposalForm extends Composite<FormLayout> { // <1>

    public ProposalForm() {
        var titleField = new TextField("Title");
        getContent().add(titleField); // <2>

        var proposalTypeField = new ComboBox<ProposalType>("Proposal Type");
        proposalTypeField.setItems(ProposalType.values());
        getContent().add(proposalTypeField);

        var descriptionField = new TextArea("Description");
        getContent().add(descriptionField);
        getContent().setColspan(descriptionField, 2); // <3>

        var startDateField = new DatePicker("Start Date");
        getContent().add(startDateField);

        var endDateField = new DatePicker("End Date");
        getContent().add(endDateField);
    }
}
----
<1> `Composite` hides the API of Form Layout from users of `ProposalForm`, reducing the risk of misuse.
<2> `getContent()` returns the Form Layout.
<3> Because Form Layout uses two columns by default, this expands the description field to span the full width.

The finished form would look like this:

[.fill]
image::images/example-form.png[A screenshot of a form]

Form Layout is responsive; when space is limited, it automatically adjusts to a single-column layout, placing each input on its own row. It also includes additional features not covered in this example. For
more information see the <<{articles}/components/form-layout#,Form Layout>> documentation.


== Displaying Forms in Dialogs

In business applications, dialogs are commonly used for creating new items, while drawers are typically used for editing existing ones. By implementing the form as a class of its own, you can reuse it in both dialogs and drawers.

When working with dialogs in Vaadin, it's important to remember they do not alter the application's control flow. For example, in Swing, you can hand control over to a dialog and wait until the user closes it. After that, control returns to the calling code and you can proceed, depending on what option the user selected. In Vaadin, opening a dialog is another way of displaying a UI element -- it doesn't block execution or pause logic. Instead, user interactions are handled through event listeners or callbacks.

The following example shows a dialog used to create new project proposals. The caller supplies an `onSave` callback, which is triggered when the user clicks the [guibutton]*Save* button:

[source,java]
----
public class ProposalDialog extends Dialog {
        
    private final SerializableConsumer<Proposal> onSave;
    private final ProposalForm form;

    public ProposalDialog(SerializableConsumer<Proposal> onSave) {
        this.onSave = onSave;
        form = new ProposalForm();

        var saveBtn = new Button("Create Proposal", event -> save());
        saveBtn.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        var cancelBtn = new Button("Cancel", event -> close());
            
        setHeaderTitle("New Proposal");
        add(form);
        getFooter().add(cancelBtn, saveBtn);
    }

    private void save() {
        var proposal = new Proposal();
        if (form.write(proposal)) { // <1>
            onSave.accept(proposal); // <2>
            close();
        }
    }
}
----
<1> Writes the form data to a new `Proposal` Form Data Object (FDO). See the <<../bind-form#,Bind a Form>> guide for details.
<2> Uses a callback to let the caller decide how to save the FDO.

Here's how you might use the dialog in your application:

[source,java]
----
var grid = new Grid<Proposal>();
// Configure grid here...

var createProposalButton = new Button("Create Proposal", event -> {
    new ProposalDialog(proposal -> {
        var saved = proposalService.save(proposal); // <1>
        grid.getDataProvider().refreshAll(); // <2>
        grid.select(saved); // <3>
    }).open();
});
----
<1> Saves the proposal with an application service. See the <<../load-save-form#,Load and Save a Form>> guide for details.
<2> Refreshes the grid of proposals so that the new one shows up.
<3> Selects the newly added proposal, opening the edit drawer.


== Displaying Forms in Drawers

// TODO Write about the new master-detail layout that is coming in the next Vaadin version!

In many applications, drawers are used to edit existing items and are often tied to a selection. When a user selects an item, the drawer is shown; when the drawer is closed, the selection is typically cleared. For this reason, it's common to include both a save callback and a close callback when working with drawers.

The following example shows a drawer that reuses the same form component from the dialog example to edit project proposals. The caller provides two callbacks: an `onSave` callback for handling save logic, and an `onClose` callback that runs when the drawer is closed:

[source,java]
----
public class ProposalDrawer extends Section {

    private final SerializableFunction<Proposal, Proposal> onSave;
    private final SerializableRunnable onClose;
    private final ProposalForm form;
    private @Nullable Proposal proposal;

    public ProposalDrawer(SerializableFunction<Proposal, Proposal> onSave, 
                          SerializableRunnable onClose) {
        this.onSave = onSave;
        this.onClose = onClose;
        form = new ProposalForm();

        var header = new H2("Edit Proposal");

        var saveBtn = new Button("Save", event -> save());
        saveBtn.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        var cancelBtn = new Button("Cancel", event -> close());

        var buttons = new HorizontalLayout(cancelBtn, saveBtn);
        
        add(header, form, buttons);
        addClassNames(LumoUtility.Display.FLEX, // <1>
                LumoUtility.FlexDirection.COLUMN, 
                LumoUtility.Border.ALL,
                LumoUtility.Padding.MEDIUM);
        setVisible(false); // <2>
    }

    public void editProposal(Proposal proposal) {
        this.proposal = proposal;
        form.read(proposal);
        setVisible(true);
    }

    private void save() {
        if (proposal != null && form.write(proposal)) {
            proposal = onSave.apply(proposal);
            form.read(proposal);
        }
    }

    public void close() {
        proposal = null;
        form.clear();
        setVisible(false);
        onClose.run();
    }
}
----
<1> Example styling -- optional and not required for drawer functionality.
<2> Hide the drawer by default until an item is selected.

To show the drawer when a user selects an item from a grid, you can use the following pattern:

[source,java]
----
@Route("proposals")
public class ProposalView extends Main {

    public ProposalView(ProposalService proposalService) {
        var grid = new Grid<Proposal>();
        // Configure the grid here...

        var drawer = new ProposalDrawer(
            proposal -> {
                var saved = proposalService.save(proposal); // <1>
                grid.getDataProvider().refreshAll(); // <2>
                return saved;
            }, 
            grid::deselectAll // <3>
        );
        grid.addSelectionListener(event -> {
            event.getFirstSelectedItem.ifPresentOrElse(
                drawer::editProposal,  // <4>
                drawer::close // <5>
            );
        });

        add(grid, drawer);

        // Style the view here...
    }
}
----
<1> Saves the proposal with an application service.
<2> Refreshes the grid so that the updated proposal shows up.
<3> Clears the grid selection when the drawer is closed.
<4> Displays the selected proposal in the drawer.
<5> Closes the drawer when the selection is cleared.

//== Try It

//- Add a tutorial here
