---
title: Responsiveness
description:
order: 20
---


= Responsiveness
:toclevels: 2

In the scope of UX design, responsiveness refers to the UI responding to changes in the viewport size. Making a responsive application often means adapting the UI to mobile phone screen sizes and taking touch interactions into consideration. The same responsive techniques can also be adapted to make the best out of large screen sizes. The goal is not to squeeze or stretch the UI elements to fill the available space, but rather to adapt the user interfaces to best use the available screen estate.


== Designing for Mobile Responsiveness

You can optimize a user interface for a small touchscreen in different ways, depending on your application's specific needs. As a rule of thumb it's better to do a limited set of mobile functionalities well, than to rush through and force everything to fit on a small screen.


=== Reduce Features on Small Screens

The most lightweight option is to reduce the number of features on smaller screens. This works for applications that are primarily used on the desktop, and whose mobile UI is used only from time to time to access read-only data or simple workflows. For instance, users may not need to do system administration and heavy data entry on their mobiles. 

In the following example, you can see two variants of the same user interface. On the left is the desktop variant with all the features. On the right is the mobile variant with less filters.

[link=images/responsiveness1.png]
image::images/responsiveness1.png[Desktop UI on the left; Mobile UI with less filters on the right]


=== Build a Responsive System

The next option is to adapt the entire user interface to be mobile friendly. To make this easy, you should base the UI on a design system that takes responsiveness into account. In practice, you use CSS https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries[media queries] and https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries[container queries] to make responsive UI building blocks. To reduce the need for one-off, view specific overrides, the building blocks should adapt to the viewport size independently.

In the following example, the mobile variant of the user interface contains all the filters of the desktop variant. To adapt to the smaller viewport, the filter panel shows up as an overlay that the user can show and hide as needed. 

[link=images/responsiveness2.png]
image::images/responsiveness2.png[Desktop UI on left; Mobile UI with filter panel as overlay on right]


=== Start with Small Screens

If the mobile variant of your user interface is as important as the desktop variant, you should start by designing the mobile variant. This approach is called "mobile first". The user experience on mobile becomes more natural without the burden of an existing desktop design. Once the mobile UI is ready, you adapt it to larger viewport sizes for the desktop variant.

The following example shows a UI design that was first made for mobile, and then adapted to the desktop. The use case is the same as in the earlier examples, but the desktop variant is based on the mobile variant and not vice versa.

[link=images/responsiveness3.png]
image::images/responsiveness3.png[Mobile UI with a list of cards on left; Desktop UI with a list of cards on right]

Adapting a mobile user interface to the desktop is not only about adjusting the size of elements. For instance, a workflow may consist of a series of smaller steps on the mobile that can be combined on the desktop.


=== Separate User Interfaces

The approaches covered so far have been compromises: either the mobile UI is a variant of the desktop UI or vice versa. When the best possible user experience is required for both, you should develop the user interfaces independently from each other. However, this doubles the effort and amount of UI code. You may also need to create separate backend services for each UI, making the application more complex. This in turn makes it more expensive to add new features and make changes.

Because of this, you should aim for a responsive user interface, and only create separate versions for the parts where it is needed. For instance, QR code scanning, or a full-screen map, may benefit from having their own UI implementations for mobile and desktop.

The following example shows a mobile UI that relies on swipe gestures, while the desktop version has totally different interaction patterns.

[link=images/responsiveness4.png]
image::images/responsiveness4.png[Mobile UI with touch slider on the left; Desktop UI with data grid on the right]


=== What Screen Sizes Should I Design for?

Avoid designing explicitly for any specific screen resolution like 1920x1080 or “iPhone 22 Pro”. Even if your users are known to have a very specific hardware setup they would still benefit from being able to resize their browser window to half screen or use browser zoom. The design tool artboard needs to have some size, but consider that to be fluid. Push yourself to test how your design adapts to larger and smaller sizes. Especially note that the browser window tends to be much narrower than the screen resolution. Image below demonstrates that on a 1270x900 screen roughly 75% of height is actually available for the browser content.

image::images/responsiveness-browser-size.png[Height of browser content area is 697px while screen height is 900px]


== Responsive Features in Vaadin Components

Some of the components have responsive features built into them. For example the image below shows that the position of the Date Picker's overlay is changed to optimize for touchscreen devices.

image::images/responsiveness-date-picker.png[Left field has overlay below field; Right shows overlay docked to bottom of viewport]

[cols="1,2"]
|===
|Component|Responsive features

|App Layout|Navigation drawer can be displayed as an overlay or bottom navbar. Drawer automatically collapses to hamburger menu on small viewports.
|Dashboard|Reflow content automatically to optimize use of available space.
|Charts|All chart types can be configured to fill any available space. Charts will scale in real time when container size changes.
|Dialog, Confirm Dialog|Button toolbar changes to vertical layout when space is limited.
|Context Menu|Overlay is displayed as fixed to bottom of screen on mobile sizes.
|CRUD|Editor is always shown as an overlay on small viewports.
|Date Picker|Overlay is displayed as fixed to bottom of screen on mobile sizes.
|Email Field|Email specific touchscreen keyboard is used if provided by OS.
|Form Layout|By default, contents displayed in two columns are shown in a single column on mobile sizes.
|Menu Bar|Overflow menu appears when items don't fit in the width of the element.
|Number Field|Number specific touchscreen keyboard is used if provided by OS
|Password Field|Mobile browsers can display the typed character for a moment before obscuring it.
|Select|Overlay is displayed as fixed to bottom of screen on mobile sizes.
|Tabs|Horizontal scroll buttons appear when tabs don't fit in the width of the element. Container is horizontally scrollable.
|===


=== Native Inputs and Vaadin Fields

At first glance the operating systems native overlays for selecting days or options from a list may seem like a good option. Our approach has been to use our own inputs as they allow better control when the input has min-max limits, disabled options or other logic for entering a value. For example time pickers in all operating systems are not guaranteed to be able to display limits for entering time which would lead to usability issues and different experience depending on the user's device.

Image below shows Vaadin Time Picker next to OS native time pickers.

image::images/responsiveness-native-inputs.png[Time Picker components in Vaadin, Android and iOS]


== Developing Responsive User Interfaces

In Vaadin the technical implementation of responsive layouts is based on standard web technologies; Flexbox, Grid, Media query and container query. We also offer some helpers for the non-CSS savvy people for utilizing those CSS techniques.


=== Flexbox and Grid

https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox[Flexbox] is a layout which sets its child DOM elements to either expand to available space or shrink to minimize the used space. Items are displayed either vertically (column) or horizontally (row). In addition flexbox can be configured to wrap to a new line, which helps implement content that automatically reflows on smaller viewport sizes.

https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids[Grid] is a two-dimensional layout system. It's similar to having multiple Flexboxes next to each other, but adds more control over the layout. The concept behind Grid is slightly more complex than Flexbox but mastering both allows implementing very sophisticated responsive layout structures on the web.

In Vaadin the layout components already use FlexBox and Grid and make them easier to approach. If the Vaadin layout components don't fit your specific needs, you can write your own CSS or use the Lumo Utilities.


=== CSS Media Query and Container Query

Here’s an example of a mobile toolbar that is hidden on non-mobile viewports. Media query will override the styles when viewport width is within a defined scope.

```css
html {
    .mobile-toolbar {
        display: none;
    }
    @media (max-width: 640px) {
        .mobile-toolbar {
            display: flex;
        }
    }
}
```


Media query is a good tool for defining responsive breakpoints based on the viewports width. Sometimes styling based on viewport width isn't enough and container query allows styling based on size of the element's container. For example when an application has resizable content areas, it's desirable to style the content based content area rather than width of screen.

In this example when the side panel container has a width of 400px or more a footer is shown.

```css
html {
    .sidepanel {
        display: none;
        container-type: inline-size;
        container-name: sidepanel;   /* Optional */
    }
    @container sidepanel (min-width: 400px) {
        .footer {
            display: flex;
        }
    }
}
```


=== Lumo Utilities

Utility classes are small, single-purpose CSS classes that can be applied directly to a component or HTML element to style them in a specific way. Unlike traditional CSS approaches, which often involve writing custom styles for each element, utility classes provide a more modular and reusable way to style your content.

Here's the same example of mobile toolbar that is hidden on non-mobile viewports. It's important to note that the responsive utility classes follow a *mobile-first approach*. For example, "Small" styles are applied when the screen width is 640 pixels or wider.

[.example]
--
[source,html]
----
<source-info group="Lit"></source-info>
<div class="flex sm:hidden">
----

[source,java]
----
<source-info group="Flow"></source-info>
mobileToolbar.addClassNames(Display.FLEX, Display.Breakpoint.Small.HIDDEN);
----
.TSX
[source,html]
----
<source-info group="React"></source-info>
<div className="flex sm:hidden">
----
--

Blog post "https://vaadin.com/blog/building-responsive-layouts-with-vaadin-utility-classes[Building responsive layouts with Vaadin utility classes]" goes into details of Lumo Utility classes through examples.
