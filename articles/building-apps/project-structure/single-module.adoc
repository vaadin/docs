---
title: Single-module Projects
description: Learn how and when to use single-module projects for your Vaadin apps.
order: 10
---

# Single-Module Projects

The simplest type of project for a Vaadin application is a single-module https://spring.io/projects/spring-boot:[Spring Boot] project. https://maven.apache.org/:[Maven] is the recommended build and dependency management system. 

If Spring Boot or Maven are new to you, you should stop reading now and familiarize yourself with them before proceeding. Maven has a https://maven.apache.org/guides/getting-started/index.html:[Getting Started Guide]. Spring Boot has an extensive https://docs.spring.io/spring-boot/index.html:[reference manual] that includes a https://docs.spring.io/spring-boot/tutorial/first-application/index.html:[tutorial].

## Package Type

Whenever you build a web application with Spring Boot, you have to decide whether to package it as a JAR-file or as a WAR-file. This also applies to Vaadin applications. Both approaches have their own pros and cons:

### Packaging as a JAR File

When a Vaadin application is packaged as a JAR-file, it contains everything it needs to run, except for the Java Virtual Machine itself. The web server, like https://tomcat.apache.org/:[Tomcat], https://jetty.org/index.html:[Jetty], or https://undertow.io/:[Undertow], is embedded and you can start your application by running this command: `java -jar <your-app>.jar`

This makes the deployment simple. If you want to deploy your application to a containerized environment, you can https://docs.spring.io/spring-boot/reference/packaging/container-images/index.html:[turn your application into a container image]. If you want to deploy your application to a virtual or bare metal Linux server, you can https://docs.spring.io/spring-boot/how-to/deployment/installing.html:[run it as a service] using either `init.d` or `systemd`. If you want to deploy your application to a Windows server, you can use https://github.com/kohsuke/winsw:[WinSW] to run it as a Windows service.

// TODO Mention GraalVM

Another advantage is that your application runs inside its own Java Virtual Machine, and therefore its own operating system process. You can configure  and restart it without affecting other applications. If the application is compromised, or crashes, other applications running on the same physical server are better protected since they run in their own processes. This comes with a cost. Since every application runs an embedded web server, they consume more memory and more disk space, compared to a traditional Java web application. However, given that memory and disk space is quite cheap today, the cost is well worth the benefits.

Unless you have a good reason to package as a WAR file, *packaging your Vaadin application as a JAR file is the recommended choice*.

### Packaging as a WAR File

Vaadin applications can also be packaged as https://docs.spring.io/spring-boot/how-to/deployment/traditional-deployment.html:[traditional Java web applications]. In this case, the resulting WAR-file must be deployed to an external web application server. You can use an open source server, such as https://tomcat.apache.org/:[Tomcat], https://jetty.org/index.html:[Jetty], or https://undertow.io/:[Undertow], or a commercial server such as JBoss or WebLogic.

A WAR-file only contains the application itself and any dependencies not provided by the web application server. Its size is therefore smaller than a self-contained JAR-file. Multiple WAR-files can be deployed to the same web application server. As the applications run inside the same JVM, the memory overhead is smaller compared to running each application inside its own JVM. The drawback of this approach is that if something happens to the JVM process, such as a memory or thread leak, all applications are affected.

You should consider WAR packaging if you already have a web application server, or if you need advanced features that are only available from a specific web application server. In all other cases, packaging as a JAR file is a better choice.

## Project Configuration

You can use various starters to create new single-module Vaadin projects (see <<{articles}/getting-started/project#,Getting Started>> for more information). You can also create the project manually, starting with a basic Maven POM-file and adding the necessary sections.

As for all Spring Boot projects, a lot of the configuration is imported through the `spring-boot-starter-parent`:

[source,xml]
----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>INSERT LATEST SPRING BOOT VERSION HERE</version> <!--1-->
    <relativePath/>
</parent>
----
<1> You can check the latest version https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent:[here].

The parent imports all the Spring Boot dependencies and configures the most common Maven plugins - such as the compiler - using sensible defaults. 

The parent configuration is the only part of the project configuration where you need to refer to the dependency version explicitly. Declare all other dependency versions as project properties, like this:

[source,xml]
----
<properties>
    <java.version>21</java.version> <!--1-->
    <vaadin.version>INSERT LATEST VAADIN VERSION HERE</vaadin.version> <!--2-->
</properties>
----
<1> This property is used by `spring-boot-starter-parent` to configure the Java compiler plugin.
<2> You can check the latest version https://mvnrepository.com/artifact/com.vaadin/vaadin-bom:[here].

Having the dependency versions declared as properties makes them easier to upgrade. It also makes it easier to get an overview of which dependencies your application has, other than the Spring Boot dependencies.

As Spring Boot, Vaadin comes with its own set of dependencies. These are imported through a Bill of Materials (BOM) like this:

[source,xml]
----
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.vaadin</groupId>
            <artifactId>vaadin-bom</artifactId>
            <version>${vaadin.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
----

Importing the Bill of Materials makes the dependencies known to your project. This means that when you use them, you don't have to declare their versions explicitly. To use the dependencies, you have to add them to your project like this:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>com.vaadin</groupId>
        <artifactId>vaadin-spring-boot-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
----

The only dependency you need to build a simple Vaadin application is `vaadin-spring-boot-starter`. The `spring-boot-devtools` dependency enables <<{articles}/flow/configuration/live-reload/spring-boot#,Spring Boot Developer Tools>> to make development a little easier. In a real application, you would also add dependencies for at least persistence and database access, and for running tests.

// TODO Add links to application layer documentation, once it has been written.

Next, to build your project, you need to add two more Maven plugins:

[source,xml]
----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>

        <plugin>
            <groupId>com.vaadin</groupId>
            <artifactId>vaadin-maven-plugin</artifactId>
            <version>${vaadin.version}</version>
            <executions>
                <execution>
                    <goals>
                        <goal>prepare-frontend</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

The `spring-boot-maven-plugin` does at lot of things, but for now, you can think of it as the plugin that packages your project into a single, executable JAR file. For more information about this plugin, see the https://docs.spring.io/spring-boot/maven-plugin:[Spring Boot documentation].

The `vaadin-maven-plugin` also does a lot of things. The `prepare-frontend` goal checks that you have sufficiently recent versions of the `node` and `npm` tools, and installs them if they are missing. It also reviews all the resources used by your application, generates some missing source files and moves them into their correct places. Depending on how much work the plugin has to do, the first execution of this goal may take some time. However, later executions are often fast and therefore it makes sense to include this goal in every build. For more information about this plugin, see <<{articles}/flow/production/production-build#,Production Build>> and <<{articles}/flow/configuration/maven#,Maven Configuration Properties>>.

After you have executed `prepare-frontend`, you are ready to run your application in <<{articles/flow/configuration/development-mode#,development mode>>. To make a production build, you also have to run the `build-frontend` goal. This goal takes a lot longer to complete, which is why it is often configured inside its own `production` Maven profile, like this:

[source,xml]
----
<profiles>
    <profile>
        <id>production</id>
        <dependencies>
            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-core</artifactId>
                <exclusions>
                    <exclusion>
                        <groupId>com.vaadin</groupId>
                        <artifactId>vaadin-dev</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>
        </dependencies>
        <build>
            <plugins>
                <plugin>
                    <groupId>com.vaadin</groupId>
                    <artifactId>vaadin-maven-plugin</artifactId>
                    <version>${vaadin.version}</version>
                    <executions>
                        <execution>
                            <goals>
                                <goal>build-frontend</goal>
                            </goals>
                            <phase>compile</phase>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
    </profile>
</profiles>
----

This means that the `build-frontend` goal only runs when the `production` profile is active. This profile also excludes the `vaadin-dev` dependency, as it is only needed in development.

A fully configured POM-file for a single-module Vaadin application looks like this:

.pom.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example.application</groupId>
    <artifactId>application</artifactId>
    <name>application</name>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>INSERT LATEST SPRING BOOT VERSION HERE</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>21</java.version>
        <vaadin.version>INSERT LATEST VAADIN VERSION HERE</vaadin.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-bom</artifactId>
                <version>${vaadin.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>com.vaadin</groupId>
            <artifactId>vaadin-spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-maven-plugin</artifactId>
                <version>${vaadin.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-frontend</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <profile>
            <id>production</id>
            <dependencies>
                <dependency>
                    <groupId>com.vaadin</groupId>
                    <artifactId>vaadin-core</artifactId>
                    <exclusions>
                        <exclusion>
                            <groupId>com.vaadin</groupId>
                            <artifactId>vaadin-dev</artifactId>
                        </exclusion>
                    </exclusions>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.vaadin</groupId>
                        <artifactId>vaadin-maven-plugin</artifactId>
                        <version>${vaadin.version}</version>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>build-frontend</goal>
                                </goals>
                                <phase>compile</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>
    </profiles>
</project>
----

## Code Structure

The code structure of your Vaadin application should resemble its <<{articles}/building-apps/architecture/components,architecture>>. Regardless of which system components you end up with in your application, the following code structure is a good starting point:

// TODO Is this a good way of visualizing a directory structure?
// TODO Simplify the explanations
// TODO Add system component diagram 

[source, subs="+quotes"]
----
src/main/
├─ frontend/
│  ├─ components/      _- React user interface components_
│  ├─ themes/          _- CSS and theme configuration files_
|  |  ├─ my-theme/     _- Name of your application's theme_
|  |  |  ├─ *styles.css* _- Theme styles_
|  |  |  ├─ *theme.json* _- Lumo theme configuration file_
│  ├─ utils/           _- Frontend utility classes and functions_
│  ├─ views/           _- React views_
├─ java/
│  ├─ com/example/application/
│  │  ├─ domain/          _- Entities and other domain objects_
│  │  ├─ security/        _- Spring Security configuration and other security related classes_
│  │  ├─ services/        _- Application layer services_
│  │  ├─ utils/           _- Backend utility classes_
│  │  ├─ views/           _- Flow views and user interface components_
│  │  ├─ *Application.java* _- Main class_
├─ resources/
│  ├─ META-INF/
│  │  ├─ resources/
│  │  │  ├─ images/ _- Image files_ 
│  ├─ *application.properties* _- Configuration properties for your application_
----

Note the somewhat strange location of image files. You can find more information about this <<{articles}/flow/application/resources#,here>>.

### Application Layer

With a code structure like this, the <<{articles}/building-apps/architecture/layers#,conceptual application layer>> consists of the following system components:

* A `domain` system component that contains your entities, repositories, and other domain objects.
* A `services` system component that contains services and Data Transfer Objects that your presentation layer needs to interact with the application layer.

The application layer also contains two _cross-cutting packages_:

* A `security` package that contains the configuration files for Spring Security, and other security related classes. For example, you could have a `Roles` class that contains string constants for every user role in the system.
* A `utils` package that contains various utility classes that don't fit anywhere else. You should keep this package as scarce as possible. If you find yourself adding more and more classes to this package, there may be a problem with the separation of concerns in your application.

The main class of your application is `Application`. This class holds the `@SpringBootApplication` and <<{articles}/styling/application-theme#,`@Theme`>> annotations, and implements the <<{articles}/flow/advanced/modifying-the-bootstrap-page#application-shell-configurator,`AppShellConfigurator`>> interface. 

If your application is packaged as a JAR-file, this class contains the https://docs.spring.io/spring-boot/tutorial/first-application/index.html#getting-started.first-application.code.main-method:[`main()`] method. If your application is packaged as a WAR-file, this class extends the https://docs.spring.io/spring-boot/how-to/deployment/traditional-deployment.html:[`SpringBootServletInitializer`] class.

A detailed chapter on how to build your application layer for various types of applications is planned, but not yet written.

### Presentation Layer

// TODO Continue here


// TODO Add links to presentation layer and application layer once they have been written

## Enforcing Your Architecture

// TODO Write about ArchUnit

## When to Use

// TODO Explain when to use this project structure