---
title: Optimistic Locking
description: Learn about optimistic locking and when to use it.
order: 20
---

= Optimistic Locking

In all multi-user applications that change data, there is always a risk that two users try to update the same data at the same time. To avoid data consistency problems, it is important that the application detects when this happens, and handles it. One way of doing this is through optimistic locking.

Optimistic locking assumes that no conflict is going to happen, and so does not perform any data locking up front, as opposed to <<pessimistic-locking#,pessimistic locking>>. However, if a conflict does occur, the application detects it and throws an exception, often rolling back the transaction. Spring has an `OptimisticLockingFailureException` that you can use for this. 

Optimistic locking failures are always detected by the _application_, not by the database. To detect conflicts, optimistic locking uses a version number. Every record that it is going to be updated should contain a version column with an integer. For every update, this version is incremented by one. Update operations compare the current version number with the last known version number. If these numbers are different, it means that another user has updated the record after it was retrieved from the database. This is illustrated in the following pseudo-SQL example:

[source,sql]
----
UPDATE myTable 
    SET myField = 'my new value', 
        _version = :oldVersion + 1 
    WHERE id = :id AND _version = :oldVersion
----

An application executing this SQL script would then have to check the number of records that were actually updated. If this number was 0, it means that either the record did not exist, or the version numbers did not match. Both cases are optimistic locking failures. 

Both <<{articles}/building-apps/application-layer/persistence/repositories/jpa#,JPA>> and <<{articles}/building-apps/application-layer/persistence/repositories/jooq#,jOOQ>> have built-in support for optimistic locking. Furthermore, it is easy to implement yourself. However, you have to remember that you need both the primary key and the version number whenever you make an update.

As a rule of thumb, you should use optimistic locking for all updates that do not risk running into the Time-Of-Check to Time-Of-Use (TOCTOU) problem. For that, you should use <<pessimistic-locking#toctou,pessimistic locking>> instead.

== Resolving Conflicts

When an optimistic locking failure occurs, it means that another user has either updated, or deleted, the data you are trying to update. The easiest way of resolving this conflict is to inform the user of the conflict, ask them to refresh, and try again. In applications where conflicts are rare, this solution is often good enough.

If update conflicts are more frequent, you need to implement a mechanism for automatically merging the changes, or use a Conflict-free Replicated Data Type (CRDT). This is, however, outside the scope of this documentation page.
