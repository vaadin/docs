---
title: Futures
description: How to use `CompletableFuture` to iteract with the user interface.
order: 20
section-nav: badge-flow
---

= Futures [badge-flow]#Flow#

If you are using a Flow user interface, you can use a standard Java `CompletableFuture` to report results and errors to the user interface. You can also use it to cancel the job from the user interface. For reporting progress, however, you still need to use a callback.

== Returning a Result

The advantage of working with `CompletableFuture` is that Spring has built-in support for them when using the `@Async` annotation. For example, a background job that completes with either a string or an exception could be implemented like this:

[source,java]
----
@Async
public CompletableFuture<String> startBackgroundJob() {
    return CompletableFuture.completedFuture(doSomethingThatTakesALongTime());
}
----

If the `doSomethingThatTakesALongTime()` method throws an exception, Spring automatically returns a `CompletableFuture` with the exception in question.

To update the user interface, you have to add special completion stages that execute after the `CompletableFuture` completes. For more information about how to add these, see the <<{articles}/building-apps/presentation-layer/server-push/futures#,Server Push - Futures>> documentation page.

== Cancelling

You can cancel a Java `Future` by calling its `cancel()` method. The method has a `boolean` parameter that indicates whether the thread should be interrupted or not. However, `CompletableFuture`, which implements `Future`, does not use this parameter. It therefore does not make any difference whether you pass in `true` or `false`.

When you cancel a `CompletableFuture`, it completes with a `CompletionException` caused by a `CancellationException`. However, the job continues to silently run in the background until it has finished. If you want to notify the job itself that it has been cancelled, and should stop running at the next suitable moment, you have to make some changes.

`CompletableFuture` has an `isCancelled()` method that you can use to query whether the job has been cancelled or not. However, do to this, you cannot use the `@Async` annotation anymore. Instead, you have to manually execute the job using the `TaskExecutor`, and manage the state of the returned `CompletableFuture`. The principle is the same as when you are using callbacks or handles.

The earlier example would look like this when implemented using a `CompletableFuture`:

[source,java]
----
public CompletableFuture<String> startBackgroundJob() {
    var future = new CompletableFuture<String>();
    taskExecutor.execute(() -> {
        try {
            var step1Result = performStep1();

            if (future.isCancelled()) {
                return;
            }
            var step2Result = performStep2(step1Result);

            if (future.isCancelled()) {
                return;
            }
            var step3Result = performStep3(step2Result);

            if (future.isCancelled()) {
                return;
            }
            var result = performStep4(step3Result);
            future.complete(result);
        } catch (Exception ex) {
            future.completeExceptionally(ex);
        }
    });
    return future;
}
----

You do not need to do anything with the `future` after it has been cancelled, as it has already been completed. Returning is enough.