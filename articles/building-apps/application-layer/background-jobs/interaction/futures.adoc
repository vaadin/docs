---
title: Futures
description: How to use `CompletableFuture` to iteract with the user interface.
order: 20
section-nav: badge-flow
---


= Returning Futures [badge-flow]#Flow#

If you are using a Flow user interface, you can use a standard Java `CompletableFuture` to report results and errors to it, and to cancel the job. For reporting progress, however, you still need to use a callback.

Compared to <<callbacks#,callbacks>>, this approach is arguably easier to implement in the application layer, and more difficult to implement in the presentation layer. You should only use it if you have used `CompletableFuture` before and need other features that it offers, like chaining completion stages together.


== Returning a Result

Spring has built-in support for `CompletableFuture` when using the `@Async` annotation. 

The following example shows a background job that completes with either a string or an exception. If the method throws an exception, Spring automatically returns a `CompletableFuture` with the exception in question:

[source,java]
----
@Async
public CompletableFuture<String> startBackgroundJob() {
    return CompletableFuture.completedFuture(doSomethingThatTakesALongTime());
}
----

To update the user interface, you have to add special completion stages that execute after the `CompletableFuture` completes. For more information about how to add these, see the <<{articles}/building-apps/presentation-layer/server-push/futures#,Consuming Futures>> documentation page.


== Cancelling

You can cancel a Java `Future` by calling its `cancel()` method. The method has a `boolean` parameter that indicates whether the thread should be interrupted or not. However, `CompletableFuture`, which implements `Future`, does not use this parameter. It therefore does not make any difference whether you pass in `true` or `false`.

When you cancel a `CompletableFuture`, it completes with a `CompletionException` caused by a `CancellationException`. However, the job continues to silently run in the background until it has finished. If you want to notify the job itself that it has been cancelled, and should stop running at the next suitable moment, you have to make some changes.

`CompletableFuture` has an `isCancelled()` method that you can use to query whether the job has been cancelled or not. However, do to this, you cannot use the `@Async` annotation anymore. Instead, you have to manually execute the job using the `TaskExecutor`, and manage the state of the returned `CompletableFuture`. The principle is the same as when you are using callbacks or handles.

The earlier example would look like this when implemented using a `CompletableFuture`:

[source,java]
----
public CompletableFuture<String> startBackgroundJob() {
    var future = new CompletableFuture<String>();
    taskExecutor.execute(() -> {
        try {
            var step1Result = performStep1();

            if (future.isCancelled()) {
                return;
            }
            var step2Result = performStep2(step1Result);

            if (future.isCancelled()) {
                return;
            }
            var step3Result = performStep3(step2Result);

            if (future.isCancelled()) {
                return;
            }
            var result = performStep4(step3Result);
            future.complete(result);
        } catch (Exception ex) {
            future.completeExceptionally(ex);
        }
    });
    return future;
}
----

You do not need to do anything with the `future` after it has been cancelled, as it has already been completed. Returning is enough.