---
title: Route Parameters in Flow 
page-title: How to use route parameters in Flow | Vaadin
description: TODO Write a description
meta-description: TODO Write a meta description
tab-title: Flow
order: 5
---


= Route Parameters in Flow

To pass a route parameter to a Flow view, you should implement the [interfacename]`HasUrlParameter<T>` interface. This interface takes a type argument that can be `Long`, `Integer`, `String`, or `Boolean`. It declares a method [methodname]`setParameter()` that is called to pass the route parameter to the view. 

For example, you'd create a [classname]`CustomerView` that takes the customer ID as a parameter like this:

[source,java]
----
@Route("customers")
public class CustomerView extends Main implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event, String parameter) {
        setText("Customer ID: " + parameter);
    }
}
----

If you now navigated to `/customers/cu12345`, the router would call [methodname]`setParameter()` with `"cu12345"` as the parameter value.


== Optional Parameters

Route parameters are required by default. Continuing on the example above, if you tried to navigate to `/customers`, the router would return a `404 Not Found` error. 

To make a URL parameter optional, use the [annotationname]`@OptionalParameter` annotation, like this:

[source,java]
----
@Route("customers")
public class CustomerView extends Main implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event, @OptionalParameter String parameter) {
        if (parameter == null) { // <1>
            showCustomerList();
        } else {
            showCustomerWithId(parameter);
        }
    }

    private void showCustomerList() {
        // ...
    }

    private void showCustomerWithId(String customerId) {
        // ...
    }
}
----

If you now navigated to `/customers`, the router would call [methodname]`setParameter()` with `null` as the parameter value.


== Wildcard Parameters

A route parameter is by default limited to a single URL segment. For example, if you have a `customers` route that takes a string parameter, and you try to navigate to `/customers/cu1234/edit`, the router would return a `404 Not Found` error. 

If you want to capture more than one URL segment in a route parameter, you need to mark it as a wildcard parameter. You do this by annotating the parameter with [annotationname]`@WildcardParameter`, like this:

[source,java]
----
@Route("customers")
public class CustomerView extends Main implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event, @WildcardParameter String parameter) {
        if (parameter.isEmpty()) { // <1>
            showCustomerList();
        } else {
            // Extract the segments from the parameter
        }
    }

    private void showCustomerList() {
        // ...
    }
}
----

If you now navigated to `/customers/cu1234/edit`, the router would call [methodname]`setParameter()` with `"cu1234/edit"` as the parameter value.

Empty wildcard parameters are handled differently than empty optional parameters. Whereas an empty optional parameter is `null`, an empty wildcard parameter is an empty string. Thus, if you navigated to `/customers`, the router would call `setParameter()` with `""` as the parameter value.

If you are thinking about using wildcard parameters because you need multiple route parameters, <<../route-templates#,Route Templates>> may be better suited for you.


== Try It

// TODO Make a mini-tutorial here