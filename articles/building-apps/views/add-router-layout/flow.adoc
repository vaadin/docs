---
title: Flow
page-title: How to add a Flow view to a Vaadin application
meta-description: Learn how to create and apply router layouts in Vaadin Flow, including automatic and explicit layouts, nested layouts, and route prefixes for structured navigation.
order: 5
---

// TODO We need a deep dive about this, as there are so many options. This guide covers only the most common use cases.

= Router Layouts in Flow
:toclevels: 2

This guide teaches you how to create a router layout in Flow, apply it to views automatically and explicitly, and work with nested layouts. A hands-on mini-tutorial at the end will help you put these concepts into practice.


== Router Layouts in Flow

In Flow, router layouts are UI components that implement the [interfacename]`RouterLayout` interface, which provides two key methods:

* [methodname]`showRouterLayoutContent(HasElement)` -- shows the given view in the router layout.
* [methodname]`removeRouterLayoutContent(HasElement)` -- removes the given view in the router layout.

When you navigate to a view, the router first determines which layout to use -- if any. If you're navigating from one view to another inside the same router layout, the *existing router layout instance is reused*. Otherwise, a new instance is created. The router then calls [methodname]`showRouterLayoutContent()`, passing in the new view instance.


== Automatic Layouts

To create an automatic layout, add the [annotationname]`@Layout` annotation to a router layout. This layout is automatically applied to all views unless explicitly disabled.

The following example applies [classname]`MainLayout` to *all views*:

[source,java]
----
// tag::snippet[]
@Layout
// end::snippet[]
public class MainLayout extends AppLayout { // <1>
    ...
}
----
<1> `AppLayout` is a built-in router layout. See its <<{articles}/components/app-layout#,documentation page>> for more details.


=== Opting Out

Sometimes, you may want to exclude specific views from the automatic layout. For example, displaying a login view within an application layout might not be appropriate.

To *prevent a view from using the automatic layout*, set the `autoLayout` attribute of the [annotationname]`@Route` annotation to `false`:

[source,java]
----
@Route(value = "login", autoLayout = false)
public class LoginView extends Main {
    ...
}
----

[NOTE]
[annotationname]`@RouteAlias` also has the `autoLayout` attribute. You can disable or enable the automatic layout for a single view depending on the route used to access it.


=== Scoping to a Path

You can restrict an automatic layout to views with routes that start with a specific path.

The following example applies [classname]`AdminLayout` *only to views with routes starting with `/admin`*:

[source,java]
----
// tag::snippet[]
@Layout("/admin")
// end::snippet[]
public class AdminLayout extends AppLayout {
    ...
}
----

If a route matches multiple layouts, the layout with the longest matching path takes precedence. For example, given a main layout scoped to `/` (default) and an admin layout scoped to `/admin`, the layouts apply as follows:

* `/` -> rendered inside the main layout.
* `/customers` -> rendered inside the main layout.
* `/admin/users` -> rendered inside the admin layout
* `/admin/groups` -> rendered inside the admin layout.

[IMPORTANT]
Defining multiple layouts with the exact same path will result in an exception.


== Explicit Layouts

You can declare a view to use *a specific router layout* using the `layout` attribute of the [annotationname]`@Route` annotation:

[source,java]
----
// tag::snippet[]
@Route(layout = MyLayout.class)
// end::snippet[]
public class DefinedLayoutView extends Main {
    ...
}
----

Declaring a layout explicitly also disables the automatic layout for the view.

[NOTE]
[annotationname]`@RouteAlias` also has the `layout` attribute. You can render the same view in different layouts depending on the route used to access it.


== Nested Layouts

Automatic layouts do not apply to other layouts. By default, a router layout is rendered directly in the browser tab. To *render a router layout inside another router layout*, use the [annotationname]`@ParentLayout` annotation:

[source,java]
----
// tag::snippet[]
@ParentLayout(MainLayout.class)
// end::snippet[]
public class NestedLayout extends Div implements RouterLayout {
    ...
}
----


== Path Prefixes

By default, router layouts do not affect the routes of the views that they are applied to. You can change this with the [annotationname]`@RoutePrefix` annotation, which adds a prefix to all its routes.

In the following example, `MyView` receives the `some` prefix from its router layout, resulting in `some/path` being its actual path:

[source,java]
----
@Route(value = "path", layout = MyLayout.class)
public class MyView extends Main {
    ...
}

// tag::snippet[]
@RoutePrefix("some")
// end::snippet[]
public class MyLayout extends Div implements RouterLayout {
    ...
}
----


=== Opting Out

A view can opt out from a route prefix by setting the `absolute` attribute of [annotationname]`@Route` to `true`.

In the following example, the path of `MyView` is `path`, ignoring the prefix coming from `MyLayout`:

[source,java]
----
// tag::snippet[]
@Route(value = "path", layout = MyLayout.class, absolute = true)
// end::snippet[]
public class MyView extends Main {
    ...
}

@RoutePrefix("some")
public class MyLayout extends Div implements RouterLayout {
    ...
}
----

[NOTE]
[annotationname]`@RouteAlias` also has the `absolute` attribute.

Nested router layouts can also opt out from route prefixes.

In the following example, the path of `MyView` is in fact `nested/path`, as opposed to `some/nested/path`:

[source,java]
----
@Route(value = "path", layout = MyNestedLayout.class)
public class MyView extends Main {
    ...
}

// tag::snippet[]
@RoutePrefix(value = "nested", absolute = true)
// end::snippet[]
@ParentLayout(MyLayout.class)
public class MyNestedLayout extends Div implements RouterLayout {
    ...
}

@RoutePrefix("some")
public class MyLayout extends Div implements RouterLayout {
    ...
}
----


[.collapsible-list]
== Try It

In this mini-tutorial, you'll explore router layouts using the Vaadin walking skeleton. You'll then create a nested layout and experiment with different ways to apply it to views.


.Set Up the Project
[%collapsible]
====
First, generate a <<{articles}/getting-started/start#,walking skeleton with a Flow UI>>, <<{articles}/getting-started/import#,open>> it in your IDE, and <<{articles}/getting-started/run#,run>> it with hotswap enabled.
====


.Explore the Main Layout
[%collapsible]
====
The skeleton already contains a main layout. Instead of implementing one from scratch, you're going to have a look at it. Open [classname]`[application package].base.ui.view.MainLayout` in your IDE.

The main layout is based on <<{articles}/components/app-layout#,AppLayout>>:

.MainLayout.java
[source,java]
----
@Layout
public final class MainLayout extends AppLayout {

    public MainLayout() {
        setPrimarySection(Section.DRAWER);
        addToDrawer(createHeader(), new Scroller(createSideNav()), createUserMenu());
    }
    ...
}
----

It has a drawer on the left side with the following elements: an application header, a navigation menu, and a user menu. All the elements are styled using <<{articles}/styling/lumo/utility-classes#,Lumo Utility Classes>>.
====


.The Header
[%collapsible]
====
The header is created by the [methodname]`createHeader()` method. It contains the application's name and logo:

[source,java]
----
private Div createHeader() {
    // TODO Replace with real application logo and name
    var appLogo = VaadinIcon.CUBES.create();
    appLogo.addClassNames(TextColor.PRIMARY, IconSize.LARGE);

    var appName = new Span("Walking Skeleton");
    appName.addClassNames(FontWeight.SEMIBOLD, FontSize.LARGE);

    var header = new Div(appLogo, appName);
    header.addClassNames(Display.FLEX, Padding.MEDIUM, Gap.MEDIUM, AlignItems.CENTER);
    return header;
}
----

Now, change the name and the logo. Use an icon from <<{articles}/components/icons/default-icons#,the default icons>>.
====


.The Navigation Menu
[%collapsible]
====
The navigation menu is created by the [methodname]`createSideNav()` method. It includes all views -- both Flow and React -- that have declared a menu item:

[source,java]
----
private SideNav createSideNav() {
    var nav = new SideNav();
    nav.addClassNames(Margin.Horizontal.MEDIUM);
    MenuConfiguration.getMenuEntries().forEach(entry -> // <1>
        nav.addItem(createSideNavItem(entry)));
    return nav;
}

private SideNavItem createSideNavItem(MenuEntry menuEntry) {
    if (menuEntry.icon() != null) { // <2>
        return new SideNavItem(menuEntry.title(), menuEntry.path(), 
            new Icon(menuEntry.icon())); // <3>
    } else {
       return new SideNavItem(menuEntry.title(), menuEntry.path());
    }
}
----
<1> [classname]`MenuConfiguration` gives access to all registered view menu items.
<2> This navigation menu assumes that all menu items have a title, but only some may have an icon. If you know all your menu items have icons, you can simplify this method.
<3> This navigation menu assumes that the `icon` attribute contains the name of an <<{articles}/components/icons#,Icon>>.
====


.The User Menu
[%collapsible]
====
The user menu is created by the [methodname]`createUserMenu()` method. It is the only part of the router layout that is a stub:

[source,java]
----
private Component createUserMenu() {
    // TODO Replace with real user information and actions
    var avatar = new Avatar("John Smith");
    avatar.addThemeVariants(AvatarVariant.LUMO_XSMALL);
    avatar.addClassNames(Margin.Right.SMALL);
    avatar.setColorIndex(5);

    var userMenu = new MenuBar();
    userMenu.addThemeVariants(MenuBarVariant.LUMO_TERTIARY_INLINE);
    userMenu.addClassNames(Margin.MEDIUM);

    var userMenuItem = userMenu.addItem(avatar);
    userMenuItem.add("John Smith");
    userMenuItem.getSubMenu().addItem("View Profile");
    userMenuItem.getSubMenu().addItem("Manage Settings");
    userMenuItem.getSubMenu().addItem("Logout");

    return userMenu;
}
----

The <<{articles}/building-apps/security#,Security>> guides show you how to add real functionality to the user menu.
====


.Create a Nested Layout
[%collapsible]
====
Create a new Java package [packagename]`[application package].tutorial.ui.view`. Inside this package, create a new class called [classname]`NestedLayout`, like this:

.NestedLayout.java
[source,java]
----
import com.example.application.base.ui.view.MainLayout; // <1>
import com.vaadin.flow.component.HasElement;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.router.*;
import com.vaadin.flow.theme.lumo.LumoUtility;

@ParentLayout(MainLayout.class) // <2>
public class NestedLayout extends Div implements RouterLayout {

    private final Div content;

    public NestedLayout() {
        addClassNames(LumoUtility.Display.FLEX, LumoUtility.FlexDirection.COLUMN, 
                LumoUtility.Gap.SMALL, LumoUtility.Padding.MEDIUM, 
                LumoUtility.BoxSizing.BORDER, LumoUtility.Height.FULL);
        content = new Div();
        content.addClassNames(LumoUtility.Border.ALL, LumoUtility.Background.BASE);
        content.setSizeFull();
        add(new Div("This is a layout: " + this), content); // <3>
    }

    @Override
    public void showRouterLayoutContent(HasElement content) { // <4>
        this.content.getElement().appendChild(content.getElement());
    }
}
----
<1> Replace with real package.
<2> This renders the nested layout inside the main layout.
<3> Prints `this` on the screen so that you can see when the layout instance changes.
<4> This renders views inside the `content` element.

You can't see what your new layout looks like yet, because you don't have any views that use it. You'll fix that next.
====


.Create Example Views
[%collapsible]
====
You'll now create two views that contain links to each other and both use the new nested layout. Inside the [packagename]`[application package].tutorial.ui.view` package, create two new classes; [classname]`FirstView` and [classname]`SecondView`:

.FirstView.java
[source,java]
----
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.Main;
import com.vaadin.flow.router.Menu;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.router.RouterLink;

@Route(layout = NestedLayout.class)
@Menu
public class FirstView extends Main {

    public FirstView() {
        add(new H2("First View"),
            new RouterLink("Second View", SecondView.class));
    }
}
----

.SecondView.java
[source,java]
----
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.Main;
import com.vaadin.flow.router.Menu;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.router.RouterLink;

@Route(layout = NestedLayout.class)
@Menu
public class SecondView extends Main {

    public SecondView() {
        add(new H2("Second View"), 
            new RouterLink("First View", FirstView.class));
    }
}
----
====


.Test the Application
[%collapsible]
====
Restart the application. Open your browser and navigate to: http://localhost:8080/first

You should see the first view rendered inside the nested layout.

Navigate back and forth between the first view and the second view. You should see that the nested layout instance remains unchanged.

Now click on *Task List* in the navigation menu, then on *FirstView*. You should see that the nested layout instance has now changed.
====


.Add a Route Prefix
[%collapsible]
====
Add a `layout` route prefix to the nested layout:

.NestedLayout.java
[source,java]
----
@ParentLayout(MainLayout.class)
// tag::snippet[]
@RoutePrefix("layout")
// end::snippet[]
public class NestedLayout extends Div implements RouterLayout {
    ...
}
----

Restart the application. Notice that the paths of first view and second view have now changed to `layout/first` and `layout/second`, respectively.
====


.Enable Automatic Layout
[%collapsible]
====
Up to this point, the nested layout has been explicitly applied to the first view and second view. You'll now change this so that it is applied automatically, while keeping the application's behavior unchanged.

Start by removing the reference to [classname]`NestedLayout` from first view and second view, and add the `layout` prefix to each route:

.FirstView.java
[source,java]
----
// tag::snippet[]
@Route("layout/first")
// end::snippet[]
@Menu
public class FirstView extends Main {
    ...
}
----

.SecondView.java
[source,java]
----
// tag::snippet[]
@Route("layout/second")
// end::snippet[]
@Menu
public class SecondView extends Main {
    ...
}
----

Next, change the [classname]`NestedLayout` to be automatically applied to all paths that start with `/layout`. Remove the [annotationname]`@RoutePrefix` annotation and add the [annotationname]`@Layout` annotation:

.NestedLayout.java
[source,java]
----
@ParentLayout(MainLayout.class)
// tag::snippet[]
@Layout("/layout")
// end::snippet[]
public class NestedLayout extends Div implements RouterLayout {
    ...
}
----

Restart the application and click around. It should behave the same way as before.
====


.Final Thoughts
[%collapsible]
====
You've now learned how to:

* Create a custom router layout.
* Apply layouts explicitly and automatically.
* Use path prefixes in router layouts.

Now, try experimenting with route aliases and absolute routes!
====
