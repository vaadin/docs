---
title: Flow Views
page-title: How to add a Flow view to a Vaadin application
description: Learn how to add a Flow view to a Vaadin application.
meta-description: Learn how to create and organize Flow views in a Vaadin application. This guide covers defining routes, naming conventions, using route aliases, and structuring views into Java packages. Includes a hands-on tutorial to apply key concepts.
tab-title: Flow
order: 5
---


= Flow Views

In this guide, you'll learn how to create and name views in Java, assign multiple routes to a single view, and organize views into Java packages. To reinforce your learning, a hands-on mini-tutorial at the end helps you apply these concepts in a real Vaadin application.


== Creating Views

Flow views are Java classes that are annotated with [annotationname]`@Route` and extend [classname]`com.vaadin.flow.component.Component` -- or any of its subclasses. The default parameter of the [annotationname]`@Route` annotation is the path of the view. 

For example, you can define the [classname]`HelloWorld` component as the root view like this:

[source,java]
----
@Route("")
public class HelloWorld extends Div {
    public HelloWorld() {
        setText("Hello world");
    }
}
----

If the application is running from the root context, users would be able to access this view by navigating to `\https://example.com`.

Likewise, you can define the [classname]`CustomerListView` component as the target for the `/customer/list` route:

[source,java]
----
@Route("customer/list")
public class CustomerListView extends Main {
    public CustomerListView() {
        //...
    }
}
----

Users would be able to access this view by navigating to `\https://example.com/customers`.

[NOTE]
Don't include a leading `/` when you specify the path of a view.

Navigation between views is covered in more detail in the <<../navigate#,Navigate to a View>> guide.


== View Naming

If you do not specify a default parameter for [annotationname]`@Route`, the path is derived from the name of the view. The derived name is the class name in lower case, with the `View` suffix removed if there is one. Also, [classname]`MainView` and [classname]`Main` are mapped to root. 

For example:

* [classname]`MyEditor` becomes `"myeditor"`
* [classname]`PersonView` becomes `"person"`
* [classname]`MainView` becomes `""`

If you specify the path explicitly, you can name your views any way you like.


== Route Aliases

You can create multiple routes that target the same view. You do this with the `@RouteAlias` annotation.

For example, you can map `\https://example.com`, `\https://example.com/home`, and `\https://example.com/main` to [classname]`HomeView` like this:

[source,java]
----
@Route("")
@RouteAlias("home")
@RouteAlias("main")
public class HomeView extends Div {
    public HomeView() {
        //...
    }
}
----

Whenever you use route aliases, you have to create a primary route by using the [annotationname]`@Route` annotation. Only adding [annotationname]`@RouteAlias` to a view does not work.


== Package Naming

The recommended naming convention for Java packages containing views is [packagename]`[feature].ui.view`, where `[feature]` is the name of the full-stack feature that the view belongs to.

If the view consists of a single class only, you can store it directly in the `ui.view` package, like this:

[source]
----
com.example.application
└── crm <1>
    └── ui
        └── view
            ├── CustomerOnboardingView.java <2>
            ├── CustomerListView.java
            └── CUstomerDetailsView.java
----
<1> The example feature is "customer relationship management".
<2> All the views are in the same `view.ui` package.

If the view consists of more than one class, consider creating a separate package for it, like this:

[source]
----
com.example.application
└── crm
    └── ui
        └── view
            ├── onboarding
            │   ├── CustomerOnboardingView.java <1>
            │   └── ...
            ├── CustomerListView.java <2>
            └── CustomerDetailsView.java
----
<1> The onboarding view consists of multiple classes and has its own package.
<2> The other views remain in the `view.ui` package.

If you don't know whether your new view is going to be small or large, start by putting it in the `ui.view` package. You can always refactor it into its own package later.


== Try It

In this mini-tutorial, you'll explore both derived and explicit routes. You'll also create a new, simple view and specify multiple routes for it.


=== Set Up the Project

First, generate a <<{articles}/getting-started/start#,walking skeleton with a Flow UI>>, <<{articles}/getting-started/import#,open>> it in your IDE, and <<{articles}/getting-started/run#,run>> it with hotswap enabled.


=== Modify the Todo View

You'll start by changing the path of the [classname]`TodoView` to `todo`. Open the class [classname]`TodoView` in the [packagename]`com.example.application.todo.ui.view` package. Find the `@Route` annotation on the class, and remove the default parameter value. The code should now look like this:

.TodoView.java
[source,java]
----
// tag::snippet[]
@Route // <1>
// end::snippet[]
@PageTitle("Task List")
@Menu(order = 0, icon = "vaadin:clipboard-check", title = "Task List")
public class TodoView extends Main {
    //...
}
----
<1> The `""` default parameter value has been removed.

Because the path is now derived from the name of the class, you can access the view at: http://localhost:8080/todo


=== Create a Main View

Next, you'll create a new main view. In the [packagename]`com.example.application.todo.ui.view` package, create a new class called [classname]`MainView`, like this:

.MainView.java
[source,java]
----
import com.vaadin.flow.component.html.Main;
import com.vaadin.flow.router.Route;

@Route
public class MainView extends Main {
    public MainView() {
        setText("Main View");
    }
}
----

The path is again derived from the name of the class, which means you can access the view at: http://localhost:8080


=== Add a Route Alias

Now add a `@RouteAlias("home")` annotation to the [classname]`MainView`, like this:

.MainView.java
[source,java]
----
import com.vaadin.flow.component.html.Main;
import com.vaadin.flow.router.Route;
// tag::snippet[]
import com.vaadin.flow.router.RouteAlias;
// end::snippet[]

@Route
// tag::snippet[]
@RouteAlias("home")
// end::snippet[]
public class MainView extends Main {

    public MainView() {
        setText("Main View");
    }
}
----

You can now access the main view also at: http://localhost:8080/home


=== Try a Route with Multiple Segments

Now go back to [classname]`TodoView` and change the path to `manage/tasks/with/vaadin`, like this:

.TodoView.java
[source,java]
----
// tag::snippet[]
@Route("manage/tasks/with/vaadin")
// end::snippet[]
@PageTitle("Task List")
@Menu(order = 0, icon = "vaadin:clipboard-check", title = "Task List")
public class TodoView extends Main {
    //...
}
----

You can now access the todo view at: http://localhost:8080/manage/tasks/with/vaadin


=== Final Thoughts

Now you've explored how to define and organize Flow views in a Vaadin application. You've learned how to:

* Use both derived and explicit routes to structure your application's navigation.
* Create a main view and apply best practices for naming and organizing views.
* Define multiple routes for a single view, making navigation more flexible.
* Work with multi-segment routes to create more readable and meaningful URLs.

Next, see the <<../navigate#,Navigate to a View>> guide to learn how to navigate from one view to another.
