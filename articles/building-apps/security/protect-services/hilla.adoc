---
title: Hilla
page-title: How to protect browser callable services in a Vaadin application
meta-description: Learn how to secure browser-callable services in Vaadin Hilla using role-based access control. This guide covers authentication, authorization, and best practices for protecting services.
order: 10
---


= Protect Browser-Callable Services
:toclevels: 2

// This assumes @BrowserCallable services have been covered somewhere else
In a Vaadin application using Hilla views, securing [annotationname]`@BrowserCallable` services is crucial to prevent unauthorized access. In this guide, you'll learn how to control access to specific browser-callable services. A hands-on mini-tutorial at the end will help you apply these concepts in a real Vaadin application.

.Browser-callable services don't use Spring method security
[CAUTION]
Vaadin handles the protection of browser-callable services *outside Spring Security*. This means that if you inject a browser-callable service into another Java service or Flow view, it *will not be protected by default*.


== Securing the Services

Vaadin protects browser-callable services in the same way as it protects <<../protect-views/flow#,Flow views>> -- with annotations.

[IMPORTANT]
All browser-callable services are *inaccessible by default* and require explicit annotations to grant access.

You can annotate both *service classes* and individual *service methods*. An annotation placed on the class applies to *all public methods* of the class. An annotation placed on a method *overrides any annotation on the class*.

The following annotations are supported:

* [annotationname]`@AnonymousAllowed` allows access to *unauthenticated* users.
* [annotationname]`@PermitAll` allows any *authenticated* user to call the service or method.
* [annotationname]`@RolesAllowed` allows users *having the roles* specified in the annotation value to call the service or method.
* [annotationname]`@DenyAll` prevents *everyone* from calling the service or method.

[NOTE]
The [annotationname]`@AnonymousAllowed` annotation is a Vaadin-specific annotation; the others are Jakarta annotations (JSR-250).

The following example uses [annotationname]`@AnonymousAllowed` to allow *all users* -- both authenticated and unauthenticated -- to call the service:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@AnonymousAllowed
// end::snippet[]
public class PublicService {

    public void doSomething() {
        //...
    }
}
----

The following example combines [annotationname]`@PermitAll` and [annotationname]`@RolesAllowed` to allow *all authenticated users* to call the service, except for one method that can be called only by *administrators*:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@PermitAll
// end::snippet[]
public class ProtectedService {

    public void callableByAllUsers() { // <1>
    }

// tag::snippet[]
    @RolesAllowed(Roles.ADMIN) // <2>
// end::snippet[]
    public void callableByAdminsOnly() {
    }
}
----
<1> Inherits its access permissions from the [annotationname]`@PermitAll` annotation on the class.
<2> Overrides the [annotationname]`@PermitAll` annotation on the class, limiting the access.

You can also do the other way around. This example allows *only administrators* to call the service, except for one method that can be called by *all authenticated users*:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@RolesAllowed(Roles.ADMIN)
// end::snippet[]
public class ProtectedService {

// tag::snippet[]
    @PermitAll
// end::snippet[]
    public void callableByAllUsers() {
    }

    public void callableByAdminsOnly() {
    }
}
----


== Using Spring Method Security for Browser-Callable Services

<<flow#,Flow services>> are protected by Spring method security. If you have a *protected Flow service* that you want to *make available for Hilla views*, you can do that with some tweaking.

[NOTE]
The following assumes you have already set up Spring method security. For details, see the <<flow#,Protect Flow Services>> guide.

By default, requests coming in from the browser are denied by Vaadin before the service is even called. This applies even when the service is proxied and protected by Spring Security.

To *bypass Vaadin's security check and rely on Spring Security instead*, you have to add [annotationname]`@AnonymousAllowed` to the service, like this:

[source,java]
----
@BrowserCallable
// tag::snippet[]
@AnonymousAllowed // <1>
@PreAuthorize("isAuthenticated()") // <2>
// end::snippet[]
public class ProtectedService {

    public MyData callableByAllUsers() {
    }

// tag::snippet[]
    @PreAuthorize("hasRole('" + Roles.ADMIN + "')")
// end::snippet[]
    public void callableByAdminsOnly(MyData data) {
    }
}
----
<1> Bypass Vaadin's security check.
<2> Enable Spring method security instead.

[NOTE]
Better support for Spring Security is planned for a future version of Vaadin Hilla. See https://github.com/vaadin/hilla/issues/3271[this ticket] for more information.

.Don't configure Spring Security to use JSR-250 annotations
[WARNING]
Spring method security has support for the JSR-250 annotations that Vaadin uses to protect browser-callable services. However, *Vaadin treats [annotationname]`@PermitAll` differently than Spring Security*. Whereas Vaadin allows access to _authenticated_ users only, Spring Security allows access to _all_ users.


[.collapsible-list]
== Try It

In this mini-tutorial, you'll learn how to secure browser-callable services in a real Vaadin application. The tutorial uses the project from the <<../protect-views/hilla#try-it,Protect Views>> guide. If you haven't completed that tutorial yet, do it now before proceeding.

[IMPORTANT]
This tutorial applies to skeletons generated for Vaadin 24.7. Skeletons generated for Vaadin 24.8 and newer already have a security configuration.


.Create Role Constants
[%collapsible]
====
Create a new class [classname]`Roles` in the [packagename]`[application package].security` package:

.Roles.java
[source,java]
----
public final class Roles {
    public static final String ADMIN = "ADMIN";
    public static final String USER = "USER";

    private Roles() {
    }
}
----

Then update the [methodname]`userDetailsManager()` method of the [classname]`SecurityConfig` class to use the new constants:

.SecurityConfig.java
[source,java]
----
@EnableWebSecurity
@Configuration
// TODO: use VaadinSecurityConfigurer
class SecurityConfig extends VaadinWebSecurity {
    ...

    @Bean
    public UserDetailsManager userDetailsManager() {
        LoggerFactory.getLogger(SecurityConfig.class)
            .warn("Using in-memory user details manager!");
        var user = User.withUsername("user")
                .password("{noop}user")
// tag::snippet[]
                .roles(Roles.USER)
// end::snippet[]
                .build();
        var admin = User.withUsername("admin")
                .password("{noop}admin")
// tag::snippet[]
                .roles(Roles.ADMIN)
// end::snippet[]
                .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----
====


.Secure the Task Service
[%collapsible]
====
In an earlier tutorial, you made the task list read-only for users, allowing only admins to create tasks.

Open [classname]`TaskService` and replace [annotationname]`@AnonymousAllowed` with [annotationname]`@PermitAll`. Then, add [annotationname]`@RolesAllowed` to `createTask()`:

.TaskService.java
[source,java]
----
@BrowserCallable
// tag::snippet[]
@PermitAll
// end::snippet[]
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class TaskService {
    ...

// tag::snippet[]
    @RolesAllowed(Roles.ADMIN)
// end::snippet[]
    public void createTask(String description, @Nullable LocalDate dueDate) {
        //...
    }

    public List<Task> list(Pageable pageable) {
        // ...
    }
}
----

Restart the application and open your browser at: http://localhost:8080

Log in as `ADMIN` and create some tasks. Everything should work as before.
====


.Break the Task List
[%collapsible]
====
To see that the service is actually protected, you're going to break the task list. Open `src/main/frontend/views/task-list.tsx` and change `TaskListView()` so that `isAdmin` is always `true`:

.frontend/views/task-list.tsx
[source,tsx]
----
...

export default function TaskListView() {
    const dataProvider = useDataProvider<Task>({
        list: (pageable) => TaskService.list(pageable),
    });
    const auth = useAuth();
// tag::snippet[]
    const isAdmin = true; // auth.hasAccess({ rolesAllowed: ["ADMIN"] });
// end::snippet[]
    // ..
}
----

Then go back to the browser, logout, and login as `USER`. If you now try to create a task, you should get an error message.

Now change `TaskListView()` back again.
// TODO This should be replaced with an integration test that checks the security, if that is even possible to write at the moment.
====


.Final Thoughts
[%collapsible]
====
Your Vaadin application now has both secure views and secure services. However, it still uses *in-memory authentication*. You should replace it with a stronger storage mechanism.
// TODO Add link to our own guides once they have been written. Should cover UserDetailsService and Control Center.

[NOTE]
A guide showing you how to do this in a Vaadin application is planned, but not yet written. In the meantime, refer to the https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/storage.html[Spring Security Reference Manual].

====
