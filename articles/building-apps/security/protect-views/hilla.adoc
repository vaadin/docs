---
title: Hilla
page-title: How to protect Hilla views in a Vaadin application
meta-description: Learn how to control access to Hilla views using authentication and role-based security. This guide covers client-side access control, user roles, and best practices for securing views.
order: 10
---


= Protect Hilla Views
:toclevels: 2

In this guide, you'll learn how to control access to specific Hilla views both declaratively and programmatically.


== Client Security

In a Hilla view, the code is running in the browser and could easily be manipulated using the browser's development tools. Client-side security *enhances user experience by hiding inaccessible features and views*, but it *does not provide real security*.

[WARNING]
When working with Hilla views, *the real security layer protects the browser callable services*. For more information about this, see the <<../protect-services#,Protect Services>> guide.


== Requiring Authentication

By default, *all Hilla views are accessible without authentication*. To require login, add `loginRequired: true` to the view configuration. This ensures that users must authenticate before accessing the view:

.frontend/views/protected-view.tsx
[source,tsx]
----
export const config: ViewConfig = {
    title: 'Protected View',
    menu: {
        icon: 'vaadin:safe-lock',
        order: 1,
        title: 'Protected View',
    },
// tag::snippet[]
    loginRequired: true
// end::snippet[]
}

export default function ProtectedView() {
    return (
        <main>
            This view requires login
        </main>
    );
}
----

[IMPORTANT]
The `ViewConfig` object is parsed on the server as JSON. Because of this, *you cannot use constants or TypeScript code in it*.

If you want all views to require login, set the `loginRequired` attribute on the main layout:

.frontend/views/@layout.tsx
[source,tsx]
----
export const config: ViewConfig = {
// tag::snippet[]
    loginRequired: true
// end::snippet[]
}

export default function MainLayout() {
    return (
        <AppLayout primarySection="drawer">
            <Header/>
            <Scroller slot="drawer">
                <MainMenu/>
            </Scroller>
            <UserMenu/>
            <Suspense fallback={<ProgressBar indeterminate={true} className="m-0"/>}>
                <Outlet/>
            </Suspense>
        </AppLayout>
    );
}
----

Now all views rendered inside the layout require authentication.


== Role-Based Access

Vaadin supports granting access to views based on the roles of the user. To do this, you have to first make the roles of the current user available to the clients-side authentication context. Next, you have to declare which role or roles are required to access a certain view or router layout.


=== Adding Roles to Authentication Context

When you <<../add-login/hilla#,enabled authentication>>, you created an `auth.ts` file that setup the client authentication context. To use role-based security, you have to change the setup with information about the current user's roles. Pass a second argument to the `configureAuth` helper function:

.frontend/security/auth.ts
[source,typescript]
----
import { configureAuth } from '@vaadin/hilla-react-auth';
import { UserInfoService } from "Frontend/generated/endpoints";

const auth = configureAuth(UserInfoService.getUserInfo, {
// tag::snippet[]
    getRoles: (user) => { // <1>
        return user.authorities
            .filter(s => s.startsWith("ROLE_")) // <2>
            .map(s => s.substring(5)); // <3>
    }
// end::snippet[]
})
export const useAuth = auth.useAuth
export const AuthProvider = auth.AuthProvider
----
<1> The `user` object is of the type returned by `UserInfoService.getUserInfo()`.
<2> Includes only role authorities. In Spring Security, roles start with the `ROLE_` prefix by default.
<3> Strips the `ROLE_` prefix to get only the name of the role.


=== Declaring Required Roles

To make a view or layout available only to users with a specific role or roles, declare the roles in the  configuration object:

.frontend/views/admin.tsx
[source,tsx]
----
export const config: ViewConfig = {
    loginRequired: true,
// tag::snippet[]
    rolesAllowed: [ "ADMIN" ], // <1>
// end::snippet[]
    ...
}

export default function AdminView() {
    ...
}
----
<1> The `rolesAllowed` attribute is an array of strings.


=== Checking Access Programmatically

Sometimes, you may want to control which actions a user can perform inside a view. Instead of blocking access entirely, you can conditionally render elements based on the user's role. For instance, one role may have full read-write access whereas another role has only read-only access. *To check the roles of the current user*, use the `useAuth` hook:

.frontend/views/my-view.tsx
[source,tsx]
----
import { useAuth } from "Frontend/security/auth";

export default function MyView() {
// tag::snippet[]
    const auth = useAuth();
    const isAdmin = auth.hasAccess({ 
        rolesAllowed: [ "ADMIN" ] // <1>
    });
// end::snippet[]

    return (
        <main>
            {isAdmin && <p>Only admins see this</p>}
            <p>Everyone can see this</p>
        </main>
    );
}
----
<1> The `rolesAllowed` attribute is an array of strings.
