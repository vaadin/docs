---
title: Hilla
page-title: How to add a Hilla login view to a Vaadin application
meta-description: Learn how to create a secure login view using Hilla and React in Vaadin. This guide covers Spring Security integration, authentication setup, and best practices.
order: 10
---


= Hilla Login
:toclevels: 2

In this guide, you'll learn how to create a login view using Hilla and React. A hands-on mini-tutorial at the end will walk you through *enabling Spring Security*, setting up *in-memory authentication*, and integrating a login form into a real Vaadin application.

.Never Use Hard-Coded Credentials In Production
[WARNING]
In-memory authentication is convenient for development, but production applications must use a more secure approach, such as *JDBC authentication*, *LDAP authentication*, or *OAuth 2.0*. Refer to the https://docs.spring.io/spring-security/reference/servlet/authentication/index.html[Spring Security Reference Manual] for more details.


== Client Configuration

Vaadin includes a client-side security extension that integrates with Spring Security on the server. To configure it, follow these steps:

1. Create a *user information endpoint* on the server.
2. Set up a *React context* in the frontend.
3. Enable the context in the *`App` component*.


=== Create a User Information Endpoint

Since authentication happens on the server, you need a way to pass user information to the client. To achieve this, create a [annotationname]`@BrowserCallable` service that returns user details:

// This assumes that the concept of browser callable services has been explained earlier.

[source,java]
----
@BrowserCallable
public class UserInfoService {

    @PermitAll // <1>
    public @NonNull UserInfo getUserInfo() {
        var auth = SecurityContextHolder.getContext().getAuthentication(); // <2>
        var authorities = auth.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();
        return new UserInfo(auth.getName(), authorities); // <3>
    }
}
----
<1> Allows *all authenticated users* to access [methodname]`getUserInfo()`.
<2> Retrieves user details from Spring Security.
<3> Returns user information to the client.

Vaadin does not provide a built-in user information type, so you need to define your own:

[source,java]
----
public record UserInfo(
    @NonNull String name, 
    @NonNull Collection<String> authorities
) {
}
----

You can include *additional user details* (e.g., email, avatar) in this type and access them in React.


=== Setup the Authentication Context

Now, configure a *React context* to store authentication details, using Vaadin's helper `configureAuth()`:

.frontend/security/auth.ts
[source,typescript]
----
import { configureAuth } from '@vaadin/hilla-react-auth';
import { UserInfoService } from "Frontend/generated/endpoints";

const auth = configureAuth(UserInfoService.getUserInfo) // <1>
export const useAuth = auth.useAuth // <2>
export const AuthProvider = auth.AuthProvider // <3>
----
<1> Uses `UserInfoService` to fetch user details from the server.
<2> `useAuth` is a *React hook* that provides authentication state within views.
<3> `AuthProvider` is a *React context provider*.


=== Enable the Authentication Context

Next, wrap the root component with `<AuthProvider>`. First, *move `index.tsx` from `src/main/frontend/generated` to `src/main/frontend`*. Then, modify it as follows:

.frontend/index.tsx
[source,tsx]
----
import { createElement } from 'react';
import { createRoot } from 'react-dom/client';
import { RouterProvider } from 'react-router';
import { router } from 'Frontend/generated/routes.js';
// tag::snippet[]
import { AuthProvider } from "Frontend/security/auth";
// end::snippet[]

function App() {
    return (
// tag::snippet[]
        <AuthProvider>
{/* end::snippet[] */}
            <RouterProvider router={router} />
{/* tag::snippet[] */}
        </AuthProvider>
// end::snippet[]
    );
}
...
----


== The Login View

The login view is a standard <<../../views/add-view/hilla#,Hilla view>>. The easiest way to implement one is by using the <<{articles}/components/login#,LoginForm>> component:

.frontend/views/login.tsx
[source,tsx]
----
import { LoginForm } from "@vaadin/react-components";
import { ViewConfig } from "@vaadin/hilla-file-router/types.js";
import { useSearchParams } from "react-router";

export const config: ViewConfig = {
    skipLayouts: true, // <1>
    menu: {
        exclude: true // <2>
    }
}

export default function LoginView() {
    const [searchParams] = useSearchParams()
    const hasError = searchParams.has("error"); // <3>

    return (
        <main className="flex justify-center items-center w-full h-full">
            <LoginForm error={hasError} action="login"/> {/* <4> */}
        </main>
    )
}
----
<1> Disables auto layout to prevent the login view from being embedded in a <<../../views/add-rouer-layout#,router layout>>.
<2> Excludes the login view from the navigation menu.
<3> Detects if the `?error` query parameter is present.
<4> Instructs the login form to send a `POST` request to `/login` for authentication.

Spring Security's *form login* mechanism automatically processes authentication requests sent to `/login`. When authentication fails, the user is redirected back to the login page with `?error`, which the login view handles.


== Server Configuration

To instruct Spring Security to use your login view, modify your security configuration:

.SecurityConfig.java
[source,java]
----
@EnableWebSecurity
@Configuration
class SecurityConfig extends VaadinWebSecurity {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);
// tag::snippet[]
        setLoginView(http, "/login");
// end::snippet[]
    }
    ...
}
----

Now, when a user tires to access a protected view, they'll be redirected to the login page.

[IMPORTANT]
By default, Vaadin *permits access to Hilla views and router layouts*, and *denies access to Flow views and router layouts*. This is covered in more detail in the <<../protect-views#,Protect Views>> guide.


[.collapsible-list]
== Try It

In this mini-tutorial, you'll enable security and add a login form to a real Vaadin application. This serves as a foundation for future *security-related mini-tutorials*.

.Set Up the Project
[%collapsible]
====
First, generate a <<{articles}/getting-started/start#,walking skeleton with a Hilla UI>>, <<{articles}/getting-started/import#,open>> it in your IDE, and <<{articles}/getting-started/run#,run>> it with hotswap enabled.

[NOTE]
Security configuration changes may require a *manual restart* for them to take effect. Hotswap may not be enough.
====


.Add the Spring Security Dependency
[%collapsible]
====
Add the following Spring Security dependency to `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----
====


.Create the Security Configuration Class
[%collapsible]
====
Create a new package: [packagename]`com.example.application.security`

Inside this package, create a [classname]`SecurityConfig` class:

.SecurityConfig.class
[source,java]
----
import com.vaadin.flow.spring.security.VaadinWebSecurity;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;

@EnableWebSecurity
@Configuration
class SecurityConfig extends VaadinWebSecurity {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);
    }

    @Bean
    public UserDetailsManager userDetailsManager() {
        LoggerFactory.getLogger(SecurityConfig.class)
            .warn("Using in-memory user details manager!");
        var user = User.withUsername("user")
                .password("{noop}user")
                .roles("USER")
                .build();
        var admin = User.withUsername("admin")
                .password("{noop}admin")
                .roles("ADMIN")
                .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----
====


.Create the User Information Endpoint
[%collapsible]
====
Create a new package: `com.example.application.security.service`

Inside this package, create a [recordname]`UserInfo` record:

.UserInfo.java
[source,java]
----
import org.jspecify.annotations.NonNull;
import java.util.Collection;

public record UserInfo(@NonNull String name, 
                       @NonNull Collection<String> authorities) {
}

----

Then create a [classname]`UserInfoService` class:

.UserInfoService.java
[source,java]
----
import com.vaadin.hilla.BrowserCallable;
import jakarta.annotation.security.PermitAll;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;

@BrowserCallable
public class UserInfoService {

    @PermitAll
    public UserInfo getUserInfo() {
        var auth = SecurityContextHolder.getContext().getAuthentication();
        var authorities = auth.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority).toList();
        return new UserInfo(auth.getName(), authorities);
    }
}
----
====


.Setup the Authentication Context
[%collapsible]
====
Create a new directory: `src/main/frontend/security`

Inside this directory, create an `auth.ts` file:

.frontend/security/auth.ts
[source,typescript]
----
import { configureAuth } from '@vaadin/hilla-react-auth';
import { UserInfoService } from "Frontend/generated/endpoints";

const auth = configureAuth(UserInfoService.getUserInfo)
export const useAuth = auth.useAuth
export const AuthProvider = auth.AuthProvider
----
====


.Enable the Authentication Context
[%collapsible]
====
Locate the `src/main/frontend/generated/index.tsx` file and move it to `src/main/frontend`. Then add the `AuthProvider`:

.frontend/index.tsx
[source,tsx]
----
import { createElement } from 'react';
import { createRoot } from 'react-dom/client';
import { RouterProvider } from 'react-router';
import { router } from 'Frontend/generated/routes.js';
// tag::snippet[]
import { AuthProvider } from "Frontend/security/auth";
// end::snippet[]

function App() {
// tag::snippet[]
    return <AuthProvider><RouterProvider router={router} /></AuthProvider>;
// end::snippet[]
}
...
----
====


.Create the Login View
[%collapsible]
====
In the `src/main/frontend/views` directory, create a new file `login.tsx`:

.frontend/views/login.tsx
[source,tsx]
----
import { LoginForm } from "@vaadin/react-components";
import { ViewConfig } from "@vaadin/hilla-file-router/types.js";
import { useSearchParams } from "react-router";

export const config: ViewConfig = {
    skipLayouts: true,
    menu: {
        exclude: true
    }
}

export default function LoginView() {
    const [searchParams] = useSearchParams()
    const hasError = searchParams.has("error");

    return (
        <main className="flex justify-center items-center w-full h-full">
            <LoginForm error={hasError}
                       action="login"/>
        </main>
    )
}
----
====


.Update the Spring Security Configuration
[%collapsible]
====
Modify [classname]`SecurityConfig` to reference the new login view:

.SecurityConfig.java
[source,java]
----
@EnableWebSecurity
@Configuration
class SecurityConfig extends VaadinWebSecurity {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http);
// tag::snippet[]
        setLoginView(http, "/login");
// end::snippet[]
    }
    ...
}
----
====


.Require Authentication
[%collapsible]
====
By default, Vaadin *grants access to all Hilla views*. Require authentication by adding the following to `src/main/frontend/views/@layout.tsx`:

.frontend/views/@layout.tsx
[source,tsx]
----
// tag::snippet[]
import { ViewConfig } from "@vaadin/hilla-file-router/types.js";
// end::snippet[]
...
// tag::snippet[]
export const config: ViewConfig = {
    loginRequired: true
}
// end::snippet[]

export default function MainLayout() {
    // ...
}

----
====


.Test the Application
[%collapsible]
====
Restart your application to make sure all your changes have been applied. Navigate to: http://localhost:8080

You should now see the login screen. Login with one of the following credentials:

* *User:* user / *Password:* password
* *Admin:* admin / *Password:* admin

After logging in, you should be able to access the todo view.
====


.Final Thoughts
[%collapsible]
====
You have now successfully added authentication to your Vaadin application. Next, learn how to *log out users* by reading the <<../add-logout#,Add Logout>> guide.
====
