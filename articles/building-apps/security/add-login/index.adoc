---
title: Add Login
page-title: How to login a user to a Vaadin application
description: Learn how to add user login to a Vaadin application using Spring Security.
meta-description: Learn how to add user login to a Vaadin application using Spring Security. This guide covers setting up in-memory authentication for development and testing.
layout: tabbed-page
tab-title: Overview
order: 1
---


= Add Login

Most enterprise applications require users to authenticate before accessing the application. Vaadin applications use *Spring Security* for all security features, including authentication. Any authentication method available in Spring Security can also be used in a Vaadin application.

This guide shows you how to set up *in-memory authentication* for development and testing purposes.

.Never Use Hard-Coded Credentials In Production
[WARNING]
In-memory authentication is convenient for development, but production applications must use a more secure approach, such as *JDBC authentication*, *LDAP authentication*, or *OAuth 2.0*. Refer to the https://docs.spring.io/spring-security/reference/servlet/authentication/index.html[Spring Security Reference Manual] for more details.

// TODO add links to our own guides that explain how to do this.


== Steps to Set Up Authentication

To enable authentication in a Vaadin application, follow these steps:

1. Add the *Spring Security dependency* to your project.
2. Create a *Spring Security configuration class*.
3. Create a *login view*.
4. Grant access to specific views and layouts.

This guide covers the first three steps. For the fourth step, see the <<../protect-views#,Protect Views>> guide.


== Add Spring Security Dependency

Since Vaadin applications are built on Spring Boot, adding the *Spring Security starter* dependency enables authentication:

[source,xml]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----


== Create a Security Configuration Class

Simply adding Spring Security to your project locks you out of your application unless you configure authentication. You must define a [interfacename]`UserDetailsService` and a login form to allow users to log in.

[TIP]
It's best practice to create a dedicated package for security-related classes. If your root package is [packagename]`com.example.application`, place the security configuration inside: `com.example.application.security`

This is a minimal implementation of a security configuration class:

[.example]
--

.`SecurityConfig.java`
[source,java]
----
<source-info group="VaadinSecurityConfigurer"></source-info>
@EnableWebSecurity
@Configuration
@Import(VaadinAwareSecurityContextHolderStrategyConfiguration.class  // <1>
class SecurityConfig {

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configure Vaadin's security using VaadinSecurityConfigurer
        http.with(VaadinSecurityConfigurer.vaadin(), configurer -> { // <2>
            // TODO Configure the login view
        });
        return http.build();
    }

    @Bean
    public UserDetailsManager userDetailsManager() {
        LoggerFactory.getLogger(SecurityConfig.class)
            .warn("NOT FOR PRODUCTION: Using in-memory user details manager!"); // <3>
        var user = User.withUsername("user")
                .password("{noop}user")
                .roles("USER")
                .build();
        var admin = User.withUsername("admin")
                .password("{noop}admin")
                .roles("ADMIN")
                .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----

.`SecurityConfig.java`
[source,java]
----
<source-info group="VaadinWebSecurity (deprecated since V24.8)"></source-info>
@EnableWebSecurity
@Configuration
class SecurityConfig extends VaadinWebSecurity {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        super.configure(http); // <4>
        // TODO Configure the login view
    }

    @Bean
    public UserDetailsManager userDetailsManager() {
        LoggerFactory.getLogger(SecurityConfig.class)
            .warn("NOT FOR PRODUCITON: Using in-memory user details manager!"); // <3>
        var user = User.withUsername("user")
                .password("{noop}user")
                .roles("USER")
                .build();
        var admin = User.withUsername("admin")
                .password("{noop}admin")
                .roles("ADMIN")
                .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----

--
<1> Imports `VaadinAwareSecurityContextHolderStrategyConfiguration`, required for Vaadin security to work with Spring Security (auto-imported with `VaadinWebSecurity`).
<2> Always call with `VaadinSecurityConfigurer.vaadin()` -- this ensures that the application is properly configured.
<3> *Tip:* Log a warning message whenever using a configuration that shouldn't end up in production.
<4> Always call `super.configure()` -- this ensures that the application is properly configured.

The [classname]`VaadinSecurityConfigurer` class provides essential security configurations out of the box, including:

* CSRF protection
* Default request caching
* Access restriction to Vaadin views and services

[NOTE]
To customize security rules—such as allowing anonymous access to static resources—in either [classname]`VaadinSecurityConfigurer` or [classname]`VaadinWebSecurity`, adjust the configuration where appropriate: use [method]`securityFilterChain` for `VaadinSecurityConfigurer`, or configure `VaadinWebSecurity` _before_ calling `super.configure()`. Both classes apply a *catch-all rule* requiring authentication for _all_ requests, but when using `VaadinSecurityConfigurer` this rule can be customized or disabled (passing `null`) via `VaadinSecurityConfigurer.anyRequest(...)`.


== Create a Login View

You can implement the login view using Flow or Hilla. Follow the guides below:

* <<flow#,Add a Flow Login View>>
* <<hilla#,Add a Hilla Login View>>
