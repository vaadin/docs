---
title: LitElement Basics
order: 20
layout: page
---

= LitElement basics

For creating views on the frontend side, Vaadin Fusion uses web components, a native technology that allows creating custom HTML elements. It is almost like a framework built into the browser, so it is usually faster and smaller than any other framework, while still allowing developing views quickly and easily.

However, since the in-browser implementation of the web components is very low-level, to make them more convenient, it is recommended to use a LitElement library.

LitElement provides a simple base class, and a set of tools to create reactive web components. Under the hood, it uses lit-html, a tiny library to render and re-render HTML templates in the most efficient and declarative way.

Let's take a closer look at the creation of the LitElement-based web component.

.my-view.ts
[source,typescript]
----
import {LitElement, html, customElement} from 'lit-element';

@customElement('my-view')
class MyView extends LitElement {
  render() {
    return html`<h1>My View</h1>`;
  }
}

export default MyView;
----
Here is the `<my-view>` element defined. It will display `<h1>My view</h1>` at the page.

== Styling

For styling, LitElement provides a static property `styles`. You may use either a stylesheet imported from the `.css` file or define it in the component directly using the `css` tagged function.

You may specify multiple styles for the `styles` property. Just use the array instead of a direct assigning.

.my-view.ts
[source,typescript]
----
import {css, LitElement, html, customElement} from 'lit-element';
import styles from './my-view.css';

@customElement('my-view')
class MyView extends LitElement {
  static styles = [
    styles,
    css`
      h1 {
        color: red;
      }
    `,
  ];

  render() {
    return html`<h1>My View</h1>`;
  }
}

export default MyView;
----

== Data properties

Components can have properties that receives data from the outside (from HTML or HTML templating system) or preserves internal state. Changing that properties triggers asynchronous re-render to fill the template with the new data.

There are two decorators provided by LitElement that can transform a regular class field to a component data property.

- `@property` - makes a field a data property that is allowed to receive data from the outside. It means that you can send the data to the component via one of the following options:
  - Using the `html` tag function of LitElement: +html`<my-view .myProperty=${"myValue"}></my-view>`+
  - As an attribute to an instance of the component: `document.querySelector('my-view').setAttribute('myProperty', 'myValue')`.
  - As a property to an instance of the component: `document.querySelector('my-view').myProperty = 'myValue'`.
- `@internalProperty` - makes a field a data property that contains an internal state of the component. That properties must not be used from outside. You can use it for example if you need to trigger re-render on some events fired by children.

Read more about data properties in the link:https://lit-element.polymer-project.org/guide/properties[LitElement documentation].

.my-view.ts
[source,typescript]
----
import {LitElement, html, customElement, property, internalProperty} from 'lit-element';
import {classMap} from 'lit-html/directives/class-map'

@customElement('my-view')
class MyView extends LitElement {
  @property() message: string = '';
  @property() name: string = '';

  @internalProperty() active: boolean = false;

  render() {
    return html`
      <dl class=${classMap({
         active: this.active,
      })}>
        <dt>${this.name}</dt>
        <dd>${this.message}</dd>
      </dl>
      <button @click=${this.onClick}></button>
    `;
  }

  // It is not necessary to bind the property in the constructor because of the
  // LitElement design. Read more in "LitElement templates" section.
  private onClick() {
    this.active = !this.active;
  }
}

export default MyView;
----

== LitElement lifecycle

Each component has lifecycle methods that may be overridden to execute some code at the specific time. To the standard web component lifecycle LitElement adds own methods to handle the asynchronous `render` calls.

Here is the list of LitElement lifecycle methods. More about them you can read in the link:https://lit-element.polymer-project.org/guide/lifecycle[LitElement documentation].

=== `constructor`

**Specificity**: JS class

The constructor invoked when a class is instantiated. For a component, it happens when `document.createElement('my-view')` is called.

Usually, you don't need `constructor` because LitElement handles everything important. However, if you do, try to avoid performing any heavy work: the element might be discarded after invoking constructor.

**NOTE**: When the element is created, no render happens. The element needs to be connected to run the `render` callback.

=== `connectedCallback`

**Specificity**: Web Components

This callback is invoked each time the element is connected to the DOM.

Usually, the `connectedCallback` is used for setting up component-level event listeners, etc.

**NOTE**: since `render` is asynchronous it won't over when the `connectedCallback` finishes. Use <<first-updated,`firstUpdated`>> callback to execute the code after the first render.

=== `disconnectedCallback`

**Specificity**: Web Components

This callback is invoked each time the element is disconnected from the DOM.

Usually, it is used to remove or close everything that is set up during the `connectedCallback`.

**NOTE**: This callback is invoked __after__ the element is disconnected from the DOM. You won't have access to the DOM from within the component in this callback.

=== `firstUpdated` [[first-updated]]

**Specificity**: LitElement

This callback is invoked right after the first render is over and before the first `updated` callback. It receives an object that contains all changed properties.

=== `updated`

**Specificity**: LitElement

This callback is invoked after each render; for the first render, it is invoked right after the `firstUpdated` callback. Just like `firstUpdate`, it receives an object that contains all properties changed after the previous render.

=== Example

.my-view.ts
[source,typescript]
----
import {LitElement, html, customElement} from 'lit-element';

@customElement('my-button')
class MyButton extends LitElement {
  constructor() {
    super();
    this.onClick = this.onClick.bind(this);
  }

  connectedCallback() {
    this.addEventListener('click', this.onClick);
  }

  disconnectedCallback() {
    this.removeEventListener('click', this.onClick);
  }

  render() {
    return html`<button>Some button</button>`;
  }

  private onClick() {
    console.log('I am clicked');
  }
}

export default MyView;
----

== LitElement templates

The `render()` method should return a `TemplateResult` instance produced by the `html` tagged function. More about how to write templates in the link:https://lit-element.polymer-project.org/guide/templates[LitElement documentation].

== Usage in routing

About how to use components in the Vaadin Router you can read in the <<{articles}/fusion/routing/router#,Vaadin Router documentation>>.

== Shadow and Light DOM

There are two main approaches for web components that you may use.

=== Shadow DOM
A web component can create a shadow tree within. It is a separate document fragment almost inaccessible from the regular DOM existing as a part of the component and displayed in the browser as a regular element tree. With it, you can create elements with styles independent of the global CSS and HTML content not added to children nodes.

Shadow DOM is enabled by default in LitElement.

.shadow-component.ts
[source,typescript]
----
import {LitElement, html, customElement} from 'lit-element';

@customElement('my-view')
class MyView extends LitElement {
  render() {
    return html`<h1>My View</h1>`;
  }
}

export default MyView;
----

=== Light DOM

If you don't want to use the Shadow DOM you may still use the Light DOM, a regular part of the DOM controlled by the component's class. It lacks all of Shadow DOM advantages like scoped CSS or non-children HTML but it is lighter and simpler for both development and performance.

To enable Light DOM for the LitElement component, add a `createRenderRoot() { return this; }` method to your component.

=== Usage advices

It is recommended to use Shadow DOM only for design components (checkboxes, text fields, combo-boxes, etc.) and Light DOM for any other components like views or their parts. It would allow avoiding possible performance issues that might happen due to multiple nesting of shadow trees.

