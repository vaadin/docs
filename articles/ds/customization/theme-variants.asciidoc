---
title: Theme Variants
order: 50
layout: page
---

= Theme Variants
ifdef::web[]
endif::web[]

Variants are opt-in features of each theme which affect the visual presentation of components.
They do not affect their behavior or functionality.

Examples of variants include light and dark modes, density presets (compact, small, large), and visual prominence (primary, tertiary, no-borders).

Themes can define global and component-specific variants.
Theme variants can be used across all <<style-scopes#,Style Scopes>> – you don’t need to define or import them individually for each style scope.

ifdef::web[]
endif::web[]

== Global Variants

Global variants affect all component instances in an application.
Light and dark modes are good examples of global variants.

[.example]
--
In server-side views (Java), use the `variant` attribute of the [classname]#@Theme# annotation.

[source, Java]
----
@Theme(themeClass = Lumo.class, variant = Lumo.DARK)
----

In client-side views (TypeScript/HTML), set the `theme` attribute on the `<html>` element.

[source, TypeScript]
----
document.documentElement.setAttribute("theme", "dark");
----

[source, HTML]
----
<html theme="dark">
----
--


== Component Variants

Component variants affect selected component instances.
Primary buttons, and small buttons and text fields are common examples of component variants.
You can combine multiple variants together for a single component, for example a "small primary" button.

Many components have built-in variants in both the Lumo and the Material theme.

[.example]
--

Components which have built-in variants implement the [classname]#HasTheme# interface and have convenient Java APIs for using them.
For other components, use the <<{articles}/flow/element-api/properties-attributes#,Element API>> and the [methodname]#setAttribute# method.

[source, Java]
----
// Using the high-level HasTheme API
Button button = new Button("Themed button");
button.addThemeVariants(ButtonVariant.LUMO_PRIMARY,
        ButtonVariant.LUMO_SMALL);

Button button = new Button("Themed button");
button.getThemeNames().addAll(Arrays.asList("primary", "small"));

// Using the low-level Element API
Button button = new Button("Themed button");
String themeAttributeName = "theme";
String oldValue = button.getElement().getAttribute(themeAttributeName);
String variantsToAdd = "primary small";
button.getElement().setAttribute(themeAttributeName,
        oldValue == null || oldValue.isEmpty() ? variantsToAdd
                : ' ' + variantsToAdd);
----

In client-side TypeScript/HTML views, set the [propertyname]#theme# attribute value.

[source, TypeScript]
----
const button = document.createElement('vaadin-button');
button.textContent = 'Themed button';
button.setAttribute('theme', 'primary small');
----

[source, HTML]
----
<vaadin-button theme="primary small">Themed button</vaadin-button>
----
--


== Sub-Component Variants

Theme variants propagate to sub-components.
For example, the Combo Box component internally contains the Text Field component.
Setting a theme variant on a Combo Box applies it on the internal Text Field component.

This also means, that even though Combo Box does not have a built-in “small” variant of its own, it can still use the built-in “small” variant of the Text Field component.
For example:

[.example]
--
In server-side views (Java):

[source, Java]
----
ComboBox comboBox = new ComboBox();
comboBox.getElement().setAttribute("theme", TextFieldVariant.LUMO_SMALL.getVariantName());
----

In client-side views (TypeScript/HTML):

[source, TypeScript]
----
const comboBox = document.createElement('vaadin-combo-box');
comboBox.setAttribute('theme', 'small');
----

[source, HTML]
----
<vaadin-combo-box theme="small"></vaadin-combo-box>
----
--

See <<styling-components#sub-components,Styling Components>> to learn about the hierarchy of built-in Vaadin components, so you can use variants more effectively and know which exact components you need to target to customize components with sub-components.


== Custom Variants

Custom variants allow you to customize the visual appearance of components.
You can define custom variants in a stylesheet you import as component styles.
See <<custom-theme#,Creating a Custom Theme>> to learn more.
Technically, custom variants work like built-in variants.

To create a custom variant, first you need to write the styles for that variant.
For example, to create a new variant for Button, the following CSS would work:

[source, css]
----
:host([theme~="my-custom-variant"]) {
  /* Set the CSS properties you want to customize */
}
----

To learn how to target internal parts of components and how to write the correct CSS selectors, see <<styling-components#,Styling Components>>.

Then, you need to import the style sheet into the corresponding component’s style scope.
See <<custom-theme#,Creating a Custom Theme>> to learn more.

Then, you can use the `my-custom-variant` on a Button component, as shown before.
