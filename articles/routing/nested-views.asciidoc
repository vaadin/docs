---
title: Nested Views
description: Nested views: route configuration, styling, creating navigation menus, and using the tab component.
order: 50
layout: page
---

= Nested Views

In many typical applications, you have a main view that displays a menu allowing the user to choose a child view to display.
When the user selects an item from the menu, a specific child view is shown in a content area inside the main view.

.Nested Views
image::images/nested-views.png[]

You can define such a main view on either the server side or the client side.
However, if you intend to display any client-side child views, the main view must be a client-side view.

A main view typically:

- imports Lumo theme global styles,
- establishes the nested view structure with `<vaadin-app-layout>`,
- creates a navigation menu bar,
- generates menu links using the `router` instance,
- has a binding for the selected tab.

You can have multiple such main views.

== Route Configuration

In a nested view configuration, you have a route to the main view, and child routes to the sub-views.
The route to the main view is usually the root route.
You can configure the child views either with explicit full paths, such as `/main-view/users`, or hierarchically with child routes, as follows.

The following configuration in [filename]#index.ts# sets up a main view with two child views:

[source,typescript]
----
const routes = [
{
	path: '',
	component: 'main-view',
	action: async () => { await import ('./views/main/main-view'); },
	children: [
		{
			path: 'hello',
			component: 'hello-world-view',
			action: async () => { await import ('./views/helloworld/hello-world-view'); }
		},
		{
			path: 'about',
			component: 'about-view',
			action: async () => { await import ('./views/about/about-view'); }
		},
 		// for server-side, the next magic line sends all unmatched routes:
		...serverSideRoutes // IMPORTANT: this must be the last entry in the array
	]
},
];

export const router = new Router(document.querySelector('#outlet'));
router.setRoutes(routes);
----

The client-side Hilla [classname]#Router# instance provides helpful APIs for generating links.
This is helpful for the menu links covered later in this article.

In your [filename]#index.ts#, make sure you `export` the router instance to enable importing it in client-side views and layouts:

.index.ts
[source,typescript]
----
...
export const router = new Router(outlet);
...
----

== Import Theme Global Styles

In Hilla, themes have some global styles that need to be applied to the page.
With a server-side main layout in Java, these are automatically applied for convenience.
With a client-side main layout in TypeScript, they need to be imported manually to get consistent styling between server-side and client-side views.

Make sure to have an import of theme styles in your [filename]#main-layout.ts#:

.main-layout.ts
[source,typescript]
----
...
// Import global styles of the theme
import '@vaadin/vaadin-lumo-styles/all-imports';
...
----

== Establish an Application Layout

The most prominent feature of the main layout is that it defines the layout for the application.
You can use the https://vaadin.com/docs/ds/components/app-layout[App Layout] component:

.main-layout.ts
[source,typescript]
----
import { css, html, LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

// Import global styles of the theme
import '@vaadin/vaadin-lumo-styles/all-imports';

import '@vaadin/app-layout';

@customElement('main-layout')
export class MainLayoutElement extends LitElement {
  static get styles() {
    return css`
      :host {
        display: block;
        height: 100%;
      }
    `;
  }

  render() {
    return html`
      <vaadin-app-layout id="layout">
        <slot></slot>
      </vaadin-app-layout>
    `;
  }
}
----

[NOTE]
Keep the `<slot>` in the main layout template returned from the [methodname]#render()# method.
Hilla [classname]#Router# adds views as children in the main layout.

== Create the Navigation Menu

The main layout usually contains a navigation bar with the menu.
Here, we create the navigation bar with menu using `<vaadin-tabs>`:

.main-layout.ts
[source,typescript]
----
import { css, html, LitElement } from 'lit';
import { customElement } from 'lit/decorators.js';

// Import global styles of the theme
import '@vaadin/vaadin-lumo-styles/all-imports';

import '@vaadin/app-layout';
import '@vaadin/tabs';

@customElement('main-layout')
export class MainLayoutElement extends LitElement {
  render() {
    return html`
      <vaadin-app-layout id="layout">
        <vaadin-tabs slot="navbar" id="tabs">
          <vaadin-tab>
            <a href="/dashboard">Dashboard</a>
          </vaadin-tab>
        </vaadin-tabs>
        <slot></slot>
      </vaadin-app-layout>
    `;
  }
}
----

== Highlighting the Active Menu Link

The Hilla client-side router does not provide link highlighting itself.
Instead, this is done with template bindings and helper methods.

=== When Not Using the Tabs Component

When not using `<vaadin-tabs>`, you can style active links by binding the `active` attribute.
In this example, we start by defining the `location` property.
We then add a helper method [methodname]#isCurrentLocation()# to determine active links, and use it in the template binding in [methodname]#render()#:

.main-layout.ts
[source,typescript]
----
...
import { router } from './index';

@customElement('main-layout')
export class MainLayoutElement extends LitElement {
  // updated automatically from Hilla Router
  @property({type: Object}) location = router.location;

  static get styles() {
    return css`
      [active] {
        color: var(--lumo-body-text-color);
      }
    `;
  }

  render() {
    return html`
      <a href="${router.urlForPath('dashboard')}"
          ?active="${this.isCurrentLocation('dashboard')}">
        Dashboard
      </a>
      <slot></slot>
    `;
  }

  private isCurrentLocation(route: string): boolean {
    return router.urlForPath(route) === this.location.getUrl();
  }
}
----

=== Using the Tabs Component

When using `<vaadin-tabs>`, we need to bind the `selected` property to the index of the selected tab.

First, we create a list of the tabs of the menu:

.main-layout.ts
[source,typescript]
----
...
import { router } from './index';

interface MenuTab {
  route: string;
  name: string;
}

const menuTabs: MenuTab[] = [
  {route: 'dashboard', name: 'Dashboard'},
  {route: 'masterdetail', name: 'MasterDetail'},
];
----

Now, we extract the links from the template into a TypeScript array, and generate the menu from the array.

[source,typescript]
----
@customElement('main-layout')
export class MainLayoutElement extends LitElement {
  @property({type: Object}) location = router.location;

  render() {
    return html`
      <vaadin-app-layout id="layout">
        <vaadin-tabs slot="navbar" id="tabs" .selected="${this.getIndexOfSelectedTab()}">
          ${menuTabs.map(menuTab => html`
            <vaadin-tab>
              <a href="${router.urlForPath(menuTab.route)}" tabindex="-1">${menuTab.name}</a>
            </vaadin-tab>
          `)}
        </vaadin-tabs>
        <slot></slot>
      </vaadin-app-layout>
    `;
  }
----

We need to know if a given route is the current route:

----
  private isCurrentLocation(route: string): boolean {
    return router.urlForPath(route) === this.location.getUrl();
  }
----

Then we can calculate the index in the array in another helper:

----
  private getIndexOfSelectedTab(): number {
    const index = menuTabs.findIndex(
      menuTab => this.isCurrentLocation(menuTab.route)
    );

    // Select first tab if there is no tab for home in the menu
    if (index === -1 && this.isCurrentLocation('')) {
      return 0;
    }

    return index;
  }
}
----

== Final View

The complete main view is as follows:

.main-layout.ts
[source,typescript]
----
import { css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { router } from './index';

// Import global styles of the theme
import '@vaadin/vaadin-lumo-styles/all-imports';

import '@vaadin/app-layout';
import '@vaadin/tabs';

interface MenuTab {
  route: string;
  name: string;
}

const menuTabs: MenuTab[] = [
  {route: 'dashboard', name: 'Dashboard'},
  {route: 'masterdetail', name: 'MasterDetail'},
];

@customElement('main-layout')
export class MainLayoutElement extends LitElement {
  @property({type: Object}) location = router.location;

  static get styles() {
    return css`
      :host {
        display: block;
        height: 100%;
      }
    `;
  }

  render() {
    return html`
      <vaadin-app-layout id="layout">
        <vaadin-tabs slot="navbar" id="tabs" .selected="${this.getIndexOfSelectedTab()}">
          ${menuTabs.map(menuTab => html`
            <vaadin-tab>
              <a href="${menuTab.route}" tabindex="-1">${menuTab.name}</a>
            </vaadin-tab>
          `)}
        </vaadin-tabs>
        <slot></slot>
      </vaadin-app-layout>
    `;
  }

  private isCurrentLocation(route: string): boolean {
    return router.urlForPath(route) === this.location.getUrl();
  }

  private getIndexOfSelectedTab(): number {
    const index = menuTabs.findIndex(
      menuTab => this.isCurrentLocation(menuTab.route)
    );

    // Select first tab if there is no tab for home in the menu
    if (index === -1 && this.isCurrentLocation('')) {
      return 0;
    }

    return index;
  }
}
----
