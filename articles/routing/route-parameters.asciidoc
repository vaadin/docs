---
title: Route Parameters
description: Route parameters are variable parts of the URL segment that can be used to pass extra information to a given route
order: 20
layout: page
---

= Route Parameters

Route parameters refer to the variable parts of a URL segment.
These parameters provide a way to pass extra information to a given route.

For example, if the application has a route named `greet` that accepts a string parameter, then users can call the `greet` route with the URL `/greet/<some-string>`.
For example, users can use any of the following URLs to call the `greet` route:

    * `/greet/John`
    * `/greet/Jane`
    * `/greet/World`
    *  and so on .. 

In the above examples, the `John`, `Jane`, and `World` strings are route parameters that the `greet` route can use to respond to requests.

== Defining Route Parameters

A route target (_that is, a view_) that accepts route parameters passed through the URL should:

* implement the [interfacename]`HasUrlParameter<T>` interface, and
* define the parameter type using generics.

[interfacename]`HasUrlParameter` defines the [methodname]`setParameter()` method that is called by the [classname]`Router`, based on values extracted from the URL.
This method will always be invoked before a navigation target is activated (before the `BeforeEnter` event).

*Example*: Defining a navigation target that takes a string parameter and produces a greeting string from it, which the target then sets as its own text content on navigation:


[source,java]
----
@Route(value = "greet")
public class GreetingComponent extends Div
        implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event, String parameter) {
        setText(String.format("Hello, %s!", parameter));
    }
}
----

On startup, the navigation target is automatically configured for every `greet/<anything>` path, except where a separate navigation target with the exact `@Route` is configured to match `greet/<some specific path>`.
Thus, it is worth noting that an exact navigation target always takes precedence over route parameters when resolving the URL.

== Optional Route Parameters

Route parameters can be annotated as optional using `@OptionalParameter`.

*Example*: Defining the route to match both `greet` and `greet/<anything>`:

[source,java]
----
@Route("greet")
public class OptionalGreeting extends Div
        implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event,
            @OptionalParameter String parameter) {
        if (parameter == null) {
            setText("Welcome anonymous.");
        } else {
            setText(String.format("Welcome %s.", parameter));
        }
    }
}
----

Note that more specific route always takes precedence over an optionally parameterized route.

== Wildcard Route Parameters

When more parameters are needed, the route parameter can also be annotated with `@WildcardParameter`.

*Example*: Defining the route to match `greet` and anything after it, for instance `greet/one/five/three`:

[source,java]
----
@Route("greet")
public class WildcardGreeting extends Div
        implements HasUrlParameter<String> {

    @Override
    public void setParameter(BeforeEvent event,
            @WildcardParameter String parameter) {
        if (parameter.isEmpty()) {
            setText("Welcome anonymous.");
        } else {
            setText(String.format("Handling parameter %s.", parameter));
        }
    }
}
----

Note that more specific route always takes precedence over wildcard route.
Note also that if no value was passed to the wildcard route parameter, then its value will be an empty String.

== Maintaining Route Parameters manually

In certain cases, developer might want to maintain the parameters in the browser URL. 
Like if the edited entity in a form changes via instance method instead of via passing URL parameters.
In this case developer can use the History object to maintain the RouteParameters.

*Example*: A view that is updating the deep linking parameters based on a parameter given in a public API. The view also implements HasUrlParameter to de-serialise the parameter in case a user arrives directly to the page:

[source,java]
----
@Route
public class UserEditor extends VerticalLayout implements HasUrlParameter<Integer> {

    /**
     * This method can be called directly by other views.
     *
     * @param user the User instance to edit
     */
    public void editUser(User user) {
        // do the actual UI changes
        createFormForUser(user);
        // maintain a complete url in the browser
        updateQueryParameters(user);
    }

    private void updateQueryParameters(User o) {
        String deepLinkingUrl = RouteConfiguration.forSessionScope()
                .getUrl(getClass(), o.getId());
        // Assign the full deep linking URL directly using
        // History object: changes the URL in the browser,
        // but does not reload the page. 
        getUI().get().getPage().getHistory()
                .replaceState(null, deepLinkingUrl);
    }

    @Override // HasUrlParameter interface 
    public void setParameter(BeforeEvent event,
                             @OptionalParameter Integer id) {
        if(id != null) {
            // This method is called if user arrives via "deep link"
            // directly to this form. In a real world app, one would
            // likely fetch an entity/DTO via service based on its id
            createFormForUser(new User("User " + id, id));
        }
    }

    private void createFormForUser(User user) {
        // just show the user ID as this is really not a form example
        add(new Paragraph("User: " + user.getId()) );
    }

}
----

See more about maintaining the browser URL from the <<../advanced/history-api#, History API>>

== Alternatives to Route Parameters

Route parameters, the approach described in this guide, is the easiest method for accepting parameters, and it should work for most common use cases.
It is, therefore, recommended to use this approach if possible. 

However, if using route parameters is not sufficient for your use case, Vaadin Flow supports two additional techniques for accepting parameters:

. **Query Parameters**: this approach is suitable when it is necessary to have explicit name-value pairs or when you must accept several optional parameters.
(See the <<additional-guides/query-parameters#, Query Parameters guide>>).
 
. **Route Templates**: this is the most powerful yet complex approach to accepting parameters. Given its complexity, it is recommended not to choose this approach unless your specific use case cannot be addressed using route or query parameters.
(See the <<additional-guides/route-templates#, Route Templates guide>>).
