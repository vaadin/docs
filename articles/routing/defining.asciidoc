---
title: Defining Routes
description: Defining client-side TypeScript routes and server-side Java routes in a Hilla application.
order: 20
layout: page
---

= Defining Routes

TypeScript routes, typically for views or sub-views, are defined in a [classname]#Router# instance in the [filename]#index.ts# script.
If you also have server-side views defined in Java, you need to configure the router to fall back to those.

A typical router configuration that supports both TypeScript and Java routes goes as follows:

.index.ts
[source,typescript]
----
import { Router } from '@vaadin/router';
import { Flow } from '@vaadin/flow-frontend';

// Get the server-side routes from imports generated in the server
const {serverSideRoutes} = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});

export const router = new Router(document.querySelector('#outlet'));
router.setRoutes([
  // A single route here
  {
    path: 'users',            // The route
  	component: 'users-view',  // The component handling the route
    // Import the view component when needed
  	action: async () => { await import ('./views/users/users-view'); },
  },
  // For server-side, the next magic line sends all unmatched routes:
  ...serverSideRoutes // IMPORTANT: this must be the last entry in the array
]);
----

Client-side routes are explicitly listed in the configuration, and server-side routes are added there through the `serverSideRoutes` variable.

In the example above, we have a single client-side route `users`, which maps to a `users-view` component.
It would be defined in a file [filename]#views/users/users-view.ts# under the `frontend` folder where the [filename]#index.ts# is located.

In the following sections, we break up the client-side and server-side routing.

== Pure Client-Side Routing

In a pure TypeScript application with no server-side Java routes, you can configure routing as follows:

.index.ts
[source,typescript]
----
import { Router } from '@vaadin/router';

export const router = new Router(document.querySelector('#outlet'));
router.setRoutes([
  // A single route here
  {
    path: 'users',            // The route
  	component: 'users-view',  // The component handling the route
    // Import the view component when needed
  	action: async () => { await import ('./views/users/users-view'); },
  }
]);
----


=== Using the Client

First, you need to import the module, and then create the [classname]#Flow# instance.

At this point, you need to specify the location to the Flow-generated file with the imports for Java views, typically [filename]#/target/frontend/generated-flow-imports.js# in a Hilla Maven project.

Notice that the [methodname]#import()# function should be used to lazy-load Flow dependencies the first time the user navigates to a server-side view.

[source,typescript]
----
import { Flow } from '@vaadin/flow-frontend';
const flow = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});
----

Finally, make Hilla [classname]#Router# pass all unmatched paths to Flow server by adding `...serverSideRoutes` at the end of the router configuration block:

[source,typescript]
----
import { Router } from '@vaadin/router';
import { Flow } from '@vaadin/flow-frontend';

const {serverSideRoutes} = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});

export const router = new Router(document.querySelector('#outlet'));
router.setRoutes([
  {
    path: 'categories',
    component: 'app-categories',
    action: async () => { await import('./views/app-categories-view'); }
  },
  // for server-side, the next magic line sends all unmatched routes:
  ...serverSideRoutes // IMPORTANT: this must be the last entry in the array
]);
----
