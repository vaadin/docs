---
title: Auto Grid
order: 13
description: Used for displaying tabular data based on a Java backend service.
---

= [since:dev.hilla:hilla@v2.3]#Auto Grid#
:react:

// tag::description[]
Auto Grid is a component for displaying tabular data based on a Java backend service.
// end::description[]


== Basic Usage

Auto Grid requires a Java service that implements the `ListService<T>` interface. In the example here, the `ProductService` class extends `ListRepositoryService<T, ID, R>`, which in turn implements the `ListService<T>`:

[.example]
--
.ProductService.java
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/crud/ProductService.java[tags=snippet,indent=0]
----
.Product.java
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/crud/Product.java[tags=snippet,indent=0]
----
.Supplier.java
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/crud/Supplier.java[tags=snippet,indent=0]
----
.ProductRepository.java
[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/crud/ProductRepository.java[tags=snippet,indent=0]
----
--

Hilla generates TypeScript objects for each `@BrowserCallable` service implementing the `ListService<T>` interface. These TypeScript objects have callable methods that execute the corresponding Java service methods, enabling lazy data loading with sorting and filtering.

For the `ProductService` example, you can import the generated TypeScript object in your React view, and use it as a value for the `<AutoGrid service={}/>` property to display the data.

[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-basic.tsx[tags=snippet,indent=0,group=React]
----

The Auto Grid component renders a grid with columns for all properties of the `Product` entity with sorting and filtering, loading the data lazily from the backend by calling the `ListService<T>.list(Pageable pageable, @Nullable Filter filter)` method.

Here's what the rendered grid looks like:

[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-basic.tsx[render,tags=snippet,indent=0,group=React]
----

As you can see, Auto Grid automatically expands properties of `@OneToOne` relationships -- in this case the properties of the `supplier` -- and it displays them as columns in the grid. However, properties annotated with `@Id` or `@Version` are excluded by default. If you want to show them, though, you can use the `visibleColumns` property to specify which columns should be displayed. See <<#customizing-columns,Customizing Columns>> for more information.


== Customizing Columns

It's possible to customize the columns displayed by Auto Grid. How this is done is covered in the sections here.


=== Customizing Visibility & Order

To choose which of the data properties should be displayed as columns in Auto Grid, and to specify the column order, set the property names to the `visibleColumns` property.

The following example uses only the `category`, `name`, `supplier.supplierName`, and `price` properties, in this order:

.Auto Grid with Chosen Columns
[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-visible-columns.tsx[render,tags=snippet,indent=0,group=React]
----

.Use Dot Notation to Access Nested Properties
[NOTE]
When trying to access nested properties, use the Dot Notation, as shown in the example above. To access the `supplierName` of the `supplier` property, for example, you might use `supplier.supplierName`.


.Don't Expose Sensitive Data on Client-Side
[CAUTION]
When using Auto Grid, it's important to check that you don't expose sensitive data to the client-side. For example, if you have a `password` property in your entity, hiding it using the `visibleColumns` property won't prevent the data from being sent to the client-side. Make sure your service implementation doesn't expose sensitive data to the client-side. You could do this, for example, by using a `@JsonIgnore` annotation on the property.


=== Customizing Column Options

Individual columns can be customized using the `columnOptions` property. This takes an object in which each key is the name of a data property, and the value is a property's object that is passed when rendering the column for that property.

The following example uses column options to define a custom renderer for the price column that highlights prices in different colors, depending on their value:


[source,tsx]
.Auto Grid with Customized Price Column
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-column-options.tsx[render,tags=snippet,indent=0,group=React]
----

You can pass the same options as when rendering a column in a regular grid. See the <<../grid/#,Grid>> documentation page for more information and examples.


=== Adding Custom Columns

If you need to add a custom column, by joining the value of two or more properties and displaying them in a single column, this can be done by using the `customColumns` property. The `customColumns` property takes an array of `GridColumn` instances and renders them after the auto columns. Refer to the <<../grid/#,Grid>> documentation page for more information on the `GridColumn` type.

The following example uses the `customColumns` property to render a custom column that concatenates and displays the product's supplier `name` and `headquarterCity` properties in the same column:

.Auto Grid with Custom Supplier Column
[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-custom-columns.tsx[render,tags=snippet,indent=0,group=React]
----

.Customizing vs. Adding Columns
[NOTE]
In general, when it comes to customizing the automatically rendered columns, you can use the `columnOptions` property. As for adding or customizing the custom columns, use `customColumns`.


== Filtering

Auto Grid has column-based filtering enabled by default. You can disable the built-in column filters by setting the `noHeaderFilters` flag.

.Auto Grid using `noHeaderFilters={true}`
[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-no-header-filters.tsx[render,tags=snippet,indent=0,group=React]
----

Auto Grid supports external filtering by using the criteria specified by the `experimentalFilter` property.

.Experimental Feature
[WARNING]
External Auto Grid filtering is an experimental feature. The `experimentalFilter` property API may be changed or removed in future releases.

In the example below, the data in Auto Grid is filtered using the _contains_ matcher for the `name` property, combined with the _equals_ matcher for `category` when a specific category is selected:

.Auto Grid with a Filter
[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-filtering.tsx[render,tags=snippet,indent=0,group=React]
----

You can combine several filtering criteria by using the `{t: 'and' | 'or', children: []}` composite filter type.


== Grid Properties

You can also customize the underlying Grid component properties in Auto Grid.

The example here enables single-row selection in the Auto Grid by using a combination of the `onActiveItemChanged` event listener with the `selectedItems` property. Both are supported by the Grid component that Auto Grid uses internally.

.Auto Grid with a Filter
[source,tsx]
----
include::{root}/frontend/demo/component/auto-grid/react/auto-grid-selection.tsx[render,tags=snippet,indent=0,group=React]
----

You can read more on the properties, and use cases supported, on the <<../grid#,Grid component>> documentation page.


== Working with Plain Java Beans

Auto Grid supports working with plain, non-JPA beans. This can be useful, for example if you want to use the Data Transfer Object (DTO) pattern to decouple your domain from your presentation logic, or want to avoid serializing your JPA entities to the client-side due to performance concerns.

To use Auto Grid with plain Java classes, you need to provide a custom implementation of the `ListService<T>` interface, as the `ListRepositoryService<T>` base class only works with JPA entities. The implementation must handle pagination, sorting, and filtering of the data.

=== Creating a Service Backed by JPA

In case you are using JPA as data layer, and only want to map JPA entities to another bean class before passing them to the client-side, it is possible to reuse existing functionality of the `ListRepositoryService` to implement pagination, sorting and filtering. The following example demonstrates how to do this:

[source,java]
----
import com.vaadin.flow.server.auth.AnonymousAllowed;
import dev.hilla.BrowserCallable;
import dev.hilla.crud.ListService;
import dev.hilla.crud.JpaFilterConverter;
import dev.hilla.crud.filter.Filter;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;

@BrowserCallable
@AnonymousAllowed
public class ProductDtoListService implements ListService<ProductDto> {
    private final ProductRepository productRepository;
    private final JpaFilterConverter jpaFilterConverter;

    public ProductDtoService(ProductRepository productRepository, JpaFilterConverter jpaFilterConverter) {
        this.productRepository = productRepository;
        this.jpaFilterConverter = jpaFilterConverter;
    }

    @Override
    public List<ProductDto> list(Pageable pageable, Filter filter) {
        // Use the Hilla JpaFilterConverter to create a JPA specification from the filter
        Specification<Product> spec = jpaFilterConverter.toSpec(filter, Product.class);
        // Query the JPA repository
        Page<Product> products = productRepository.findAll(spec, pageable);
        // Map entities to DTOs and return result
        return products.stream().map(ProductDto::fromEntity).toList();
    }
}
----

=== Creating a Service Backed by a Custom Data Source

When using a custom data source you are responsible for converting the paging, sorting and filter parameters provided to the service into some data structure that your data source understands. The service receives a `org.springframework.data.domain.Pageable` and `dev.hilla.crud.filter.Filter` instances as parameters, which can be used to extract the following information:

* `Pageable.getOffset`: The offset of the first item to fetch
* `Pageable.getPageSize`: The maximum number of items to fetch
* `Pageable.getSort`: The sort order of the items. Each sort order contains the property to sort by (`Sort.Order.getProperty()`), and the direction (`Sort.Order.getDirection()`)
* `Filter`: The filter to apply to the items. The filter is a tree structure of `Filter` instances, where each `Filter` instance is either an `AndFilter`, an `OrFilter`, or a `PropertyStringFilter`:
** `AndFilter` contains a list of nested filters (`AndFilter.getChildren()`) that should all match.
** `OrFilter` contains a list of nested filters (`AndFilter.getChildren()`) of which at least one should match.
** `PropertyStringFilter` filters an individual property against a value. It contains the name of the property to filter (`PropertyStringFilter.getPropertyId()`), the value to filter against (`PropertyStringFilter.getFilterValue()`), and the matcher to use (`PropertyStringFilter.getMatcher()`). The filter value is always a string and needs to be converted into a respective type or format that works with the type of the property. The matcher specifies the type of filter operation, such as `EQUALS`, `CONTAINS`, `GREATER_THAN`, etc.

When using the default header filters in `AutoGrid`, the filter is always an `AndFilter` with a list of `PropertyStringFilter` instances. The `PropertyStringFilter` instances are created based on the filter values entered by the user in the header filters. When using an external filter, the filter can be of any structure.

The following snippet shows how to convert the parameters into a query params that could then be used to call an external REST API to retrieve a list of paginated, sorted and filtered products:
[source,java]
----
import com.vaadin.flow.server.auth.AnonymousAllowed;
import dev.hilla.BrowserCallable;
import dev.hilla.crud.ListService;
import dev.hilla.crud.filter.Filter;
import org.springframework.data.domain.Pageable;

@BrowserCallable
@AnonymousAllowed
public class ProductListService implements ListService<Product> {
    public List<Product> list(Pageable pageable, Filter filter) {
        Map<String, String> queryParams = new HashMap<>();

        // Pagination
        queryParams.put("offset", String.valueOf(pageable.getPageNumber()));
        queryParams.put("limit", String.valueOf(pageable.getPageSize()));

        // Sorting
        pageable.getSort().stream()
            .findFirst()
            .ifPresent(sortOrder -> {
                queryParams.put("sort", sortOrder.getProperty());
                queryParams.put("direction", sortOrder.getDirection().name());
            });

        // Filtering
        if (filter != null && filter instanceof AndFilter andFilter) {
            // Add a query param for each property filter
            // To keep the example simple, only support the equals matcher
            andFilter.getChildren().stream()
                .filter(f -> f instanceof PropertyStringFilter)
                .map(f -> (PropertyStringFilter)f)
                .filter(f -> f.getMatcher() == PropertyStringFilter.Matcher.EQUALS)
                .forEach(f -> queryParams.put(f.getPropertyId(), f.getFilterValue()));
        }

        // Execute request with query params
        return makeRequest(queryParams);
    }

    private List<Product> makeRequest(Map<String, String> queryParams) {
        // Encode params into URL, call external API, map response...
    }
}
----


++++
<style>
[class^=PageHeader-module--descriptionContainer] {display: none;}
</style>
++++
