---
title: Handling Long-Running Tasks
description: Learn how to handle long-running tasks in Vaadin applications.
order: 175
layout: page
---


= Handling Long-Running Tasks

Often, server-side tasks can take a long time to complete.
For example, a task that requires fetching a large amount of data from the database can take a long time until it is finished.
In such cases, a poorly designed application can freeze the UI and prevent the user from interacting with the application.

This guide will show you how to handle long-running tasks in Vaadin applications in a way that:

. Allows the user to continue interacting with the application while the task is running, possibly allowing the user to cancel the task.
. Allows the user to see the progress of the task.

Note that the examples used here are based on Spring Boot, but a similar approach can be used with other technologies.

== A Poorly Designed Example

To illustrate how a poorly designed handling of long-running tasks can affect users, consider the following backend service that simulates a long-running task.

.BackendService.java
[source,java]
----
@Service
public class BackendService {

    public String longRunningTask() {
        try {
            // Simulate a long running task
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Some result";
    }

}
----

Consider also that the [methodname]`BackendService.longRunningTask()` method is being called from the following Vaadin UI:

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    public MainView(BackendService backendService) {
        Button startButton = new Button("Start long-running task", e -> {
            String result = backendService.longRunningTask();
            Notification.show(result);
        });
        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, otherComponent);
    }

}
----

In this example, if the user clicks the "Start long-running task" button, the application will freeze the UI and prevent the user from interacting with the other parts of the application (for example, with the `otherComponent` button).
This happens because Vaadin is waiting for the long-running task to finish before it sends back the response to the user, at which point the user can continue interacting with the application.

== Handling Long-Running Tasks Asynchronously

The recommended way to handle long-running tasks is to use an asynchronous approach.
This means that the long-running task is executed in a separate thread, and the UI is not blocked while the task is running. 

There are several ways to achieve an asynchronous model.
But in the context of a Spring Boot application, one simple way is to use the [annotationname]`@Async` annotation.
The [annotationname]`@Async` annotation is used to mark a method as an asynchronous task.
From the side of Vaadin UI, a response to the user request is immediately sent back to the browser, and thus the user can continue interacting with the application right away without being blocked by the long-running task.
When the asynchronous task is finished, Vaadin uses <<{articles}/advanced/server-push#, Server Push>> to let the user know that the task is completed.

The following example shows how the [methodname]`BackendService.longRunningTask()` method can be adjusted to run asynchronously in a separate thread.

.BackendService.java
[source,java]
----
@Service
public class BackendService {

    @Async
    public ListenableFuture<String> longRunningTask() {
        try {
            // Simulate a long running task
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return AsyncResult.forValue("Some result");
    }

}
----

Now the [methodname]`BackendService.longRunningTask()` method is annotated with the [annotationname]`@Async` annotation, and the long-running task is executed in a separate thread.
Note also that the [methodname]`BackendService.longRunningTask()` method now returns a [interfacename]`ListenableFuture<String>` instead of a `String` (returning a [interfacename]`ListenableFuture` or a [interfacename]`CompletableFuture` is a requirement for any asynchronous service).
The [interfacename]`ListenableFuture` is a special type of [interfacename]`Future` that allows the caller to register a callback to be notified when the task is completed.

With these changes in place, we can change the UI to allow the user to start the long-running task and still be able to interact with the application.
Vaadin can then use the [interfacename]`ListenableFuture` and the [methodname]`UI.access()` method of <<{articles}/advanced/server-push#, Server Push>> to notify the user when the task is completed.
This is how [filename]#MainView.java# could look like now:

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    public MainView(BackendService backendService) {
        Button startButton = new Button("Start long-running task", e -> {
            UI ui = UI.getCurrent();
            ListenableFuture<String> future = backendService.longRunningTask();
            future.addCallback(
                    s -> updateUi(ui, "Task finished: " + s),
                    ex -> updateUi(ui, "Task failed: " + ex.getMessage())
            );
        });
        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, otherComponent);
    }

    private void updateUi(UI ui, String s) {
        ui.access(() -> {
            Notification.show(s);
        });
    }

}
----

*We are still not done.*
For the above example to work as intended, we need two extra annotations for the [annotationname]`@Async` annotation and the [methodname]`UI.access()` method to work.

* For the [annotationname]`@Async` annotation, we need to add the [annotationname]`@EnableAsync` annotation to the application.
* For the [methodname]`UI.access()` method, we need to add the [annotationname]`@Push` annotation to the class implementing the [interfacename]`AppShellConfigurator` interface.

We can do both changes in the same class as illustrated in the following [classname]`Application` class (which both extends [classname]`SpringBootServletInitializer` and implements [interfacename]`AppShellConfigurator`):

.Application.java
[source,java]
----
@Push
@EnableAsync
public class Application extends SpringBootServletInitializer implements AppShellConfigurator {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
----

== Showing Progress to the User

TO DO (by adjusting the MainView.java file above)
