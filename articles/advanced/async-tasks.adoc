---
title: Handling Long-Running Tasks
description: Learn how to handle long-running tasks in Vaadin applications.
order: 175
layout: page
---


= Handling Long-Running Tasks

Often, server-side tasks can take a long time to complete.
For example, a task that requires fetching a large amount of data from the database can take a long time until it is finished.
In such cases, a poorly designed application can freeze the UI and prevent the user from interacting with the application.

This guide will show you how to handle long-running tasks in Vaadin applications in a way that:

. Allows the user to continue interacting with the application while the task is running, possibly allowing the user to cancel the task.
. Allows the user to see the progress of the task.

Note that the examples used here are based on Spring Boot, but a similar approach can be used with other technologies.

== The Problem With Long-Running Tasks

To illustrate how a poorly designed handling of long-running tasks can affect users, consider the following backend service that simulates a long-running task.

.BackendService.java
[source,java]
----
@Service
public class BackendService {

    public String longRunningTask() {
        try {
            // Simulate a long running task
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Some result";
    }

}
----

Consider also that the [methodname]`BackendService.longRunningTask()` method is being called from the following Vaadin UI:

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    public MainView(BackendService backendService) {
        Button startButton = new Button("Start long-running task", e -> {
            String result = backendService.longRunningTask();
            Notification.show(result);
        });
        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, otherComponent);
    }

}
----

In this example, if the user clicks the "Start long-running task" button, the application will freeze the UI and prevent the user from interacting with the other parts of the application (for example, with the `otherComponent` button).
This happens because Vaadin is waiting for the long-running task to finish before it sends back the response to the user, at which point the user can continue interacting with the application.

== Handling Long-Running Tasks Asynchronously

The recommended way to handle long-running tasks is to use an asynchronous approach.
This means that the long-running task is executed in a separate thread, and the UI is not blocked while the task is running. 

There are several ways to achieve an asynchronous model.
But in the context of a Spring Boot application, one simple way is to use the [annotationname]`@Async` annotation.
The [annotationname]`@Async` annotation is used to mark a method as an asynchronous task.
From the side of Vaadin UI, a response to the user request is immediately sent back to the browser, and thus the user can continue interacting with the application right away without being blocked by the long-running task.
When the asynchronous task is finished, Vaadin uses <<{articles}/advanced/server-push#, Server Push>> to let the user know that the task is completed.

The following example shows how the [methodname]`BackendService.longRunningTask()` method can be adjusted to run asynchronously in a separate thread.

.BackendService.java
[source,java]
----
@Service
public class BackendService {

    @Async // <1>
    public ListenableFuture<String> longRunningTask() { // <2>
        try {
            // Simulate a long running task
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return AsyncResult.forValue("Some result"); // <3>
    }

}
----
<1> [annotationname]`@Async` annotation to mark the method for asynchronous execution.
<2> The method now returns a [classname]`ListenableFuture` object.
<3> The method's return value is a [classname]`ListenableFuture` object that contains the result of the asynchronous task.

Now the [methodname]`BackendService.longRunningTask()` method is annotated with the [annotationname]`@Async` annotation, and the long-running task is executed in a separate thread.
Note also that the [methodname]`BackendService.longRunningTask()` method now returns a [interfacename]`ListenableFuture<String>` instead of a `String` (returning a [interfacename]`ListenableFuture` or a [interfacename]`CompletableFuture` is a requirement for any asynchronous service).
The [interfacename]`ListenableFuture` is a special type of [interfacename]`Future` that allows the caller to register a callback to be notified when the task is completed.

With these changes in place, we can change the UI to allow the user to start the long-running task and still be able to interact with the application.
Vaadin can then use the [interfacename]`ListenableFuture` and the [methodname]`UI.access()` method of <<{articles}/advanced/server-push#, Server Push>> to notify the user when the task is completed.
This is how [filename]#MainView.java# could look like now:

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    public MainView(BackendService backendService) {
        Button startButton = new Button("Start long-running task", e -> {
            UI ui = UI.getCurrent(); // <1> 
            ListenableFuture<String> future = backendService.longRunningTask();
            future.addCallback(
                    s -> updateUi(ui, "Task finished: " + s), // <2> 
                    ex -> updateUi(ui, "Task failed: " + ex.getMessage()) // <3>
            );
        });
        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, otherComponent);
    }

    private void updateUi(UI ui, String s) {
        ui.access(() -> { // <4>
            Notification.show(s);
        });
    }

}
----
<1> We save the current UI in a local variable, so that we can use it later to update the UI through the [methodname]`UI.access()` method.
<2> The callback is called when the task is completed successfully.
<3> The callback is called if the task failed.
<4> The [methodname]`UI.access()` method is used to update the UI in a thread-safe manner through server-side push.

*We are still not done.*
For the above example to work as intended, we need two extra annotations for the [annotationname]`@Async` annotation and the [methodname]`UI.access()` method to work.

* For the [annotationname]`@Async` annotation, we need to add the [annotationname]`@EnableAsync` annotation to the application.
* For the [methodname]`UI.access()` method, we need to add the [annotationname]`@Push` annotation to the class implementing the [interfacename]`AppShellConfigurator` interface.

We can do both changes in the same class as illustrated in the following [classname]`Application` class (which both extends [classname]`SpringBootServletInitializer` and implements [interfacename]`AppShellConfigurator`):

.Application.java
[source,java]
----
@SpringBootApplication
@Push
@EnableAsync
public class Application extends SpringBootServletInitializer implements AppShellConfigurator {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
----

== Showing Progress to the User

With the Vaadin component <<{articles}/components/progress-bar#, ProgressBar>>, you can easily provide an indicator that a long-running action is currently in progress.
The following adjusts the above [classname]`MainView` example to show a progress bar when the user clicks the "Start long-running task" button.

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    private ProgressBar progressBar = new ProgressBar(); // <1>

    public MainView(BackendService backendService) {
        // initial setup
        progressBar.setWidth("15em");
        progressBar.setIndeterminate(true);
        progressBar.setVisible(false); // <2>

        Button startButton = new Button("Start long-running task", e -> {
            progressBar.setVisible(true); // <3>
            UI ui = UI.getCurrent();
            ListenableFuture<String> future = backendService.longRunningTask();
            future.addCallback(
                    s -> updateUi(ui, "Task finished: " + s, progressBar),
                    ex -> updateUi(ui, "Task failed: " + ex.getMessage(), progressBar)
            );
        });

        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, progressBar, otherComponent); // <4>
    }

    private void updateUi(UI ui, String s, ProgressBar p) { // <5>
        ui.access(() -> {
            p.setVisible(false); // <6>
            Notification.show(s);
        });
    }

}
----
<1> First, we create a [classname]`ProgressBar` object.
<2> After configuring the [classname]`ProgressBar`, we need to set it to invisible initially.
<3> When the button is clicked to start the long-running task, we show the [classname]`ProgressBar`.
<4> Make sure that you add the [classname]`ProgressBar` to the parent layout.
<5> We need to modify the `updateUi()` method to additionally receive the [classname]`ProgressBar` argument.
<6> When the long-running task is completed or errors out, we set the [classname]`ProgressBar` back to invisible again.

Here is the animation of the [classname]`MainView` showing the progress bar.

image::images/async-progress-bar.gif[Long-Running ProgressBar, width=50%]


[.discussion-id]
F2F7864F-F727-4333-AF3E-1E05597483DC

== Canceling a Long Running Task

For your task to be cancellable, the following conditions must be met:

. Your [annotationname]`@Async` method must return a [interfacename]`Future`.
. The running task must be https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/Future.html#cancel(boolean)[interruptable].

The modified [classname]`MainView` class below shows how to add a [classname]`Button` to cancel the long-running task.

.MainView.java
[source,java]
----
@Route("")
public class MainView extends VerticalLayout {

    private ProgressBar progressBar = new ProgressBar();

    public MainView(BackendService backendService) {
        // initial setup
        progressBar.setWidth("15em");
        progressBar.setIndeterminate(true);
        progressBar.setVisible(false);

        Button startButton = new Button("Start long-running task", e -> {
            progressBar.setVisible(true);
            UI ui = UI.getCurrent();
            ListenableFuture<String> future = backendService.longRunningTask();

            Button cancelButton = new Button("Cancel", _e -> {
                future.cancel(true);
            }); // <1>

            add(cancelButton); // <2>

            future.addCallback(
                    s -> updateUi(ui, "Task finished: " + s, progressBar, cancelButton),
                    ex -> updateUi(ui, "Task failed: " + ex.getMessage(), progressBar, cancelButton)
            );
        });

        Button otherComponent = new Button("Another component", e -> {
            Notification.show("Clicked");
        });

        add(startButton, progressBar, otherComponent);
    }

    private void updateUi(UI ui, String s, ProgressBar p, Button cancelButton) {
        ui.access(() -> {
            p.setVisible(false);
            Notification.show(s);
            remove(cancelButton); // <3>
        });
    }

}
----

<1> Add a callback to the *Cancel* [classname]`Button`.
<2> Add this [classname]`Button` to the layout.
<3> When the task is completed or canceled, we remove the cancel [classname]`Button`.
