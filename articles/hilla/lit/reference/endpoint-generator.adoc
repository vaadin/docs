---
title: TypeScript Generator
page-title: How to use the TypeScript generator in Hilla | Vaadin
description: The TypeScript generator produces TypeScript files that map to Java services annotated with [annotationname]`@BrowserCallable` or [annotationname]`@Endpoint`.
meta-description: Discover how to generate endpoints for Hilla applications efficiently.
---
// tag::content[]

= TypeScript Generator
:toclevels: 2

The TypeScript generator produces TypeScript files that map to Java services annotated with [annotationname]`@BrowserCallable` or [annotationname]`@Endpoint`.
Those files retain the properties and types of the Java classes to provide type safety in the frontend.

Those annotated services are commonly named *endpoints*, although there is a single REST endpoint in Hilla, which in turn calls the browser-callable services. The term "endpoints" is used in this context to refer to those annotated Java services.

== Features

The generator has the following noteworthy features:

- [since:dev.hilla:hilla@v1.2]*Support for multi-module projects*: you can use standard Maven modules in your application, or even external dependencies, as there is no need for endpoints and entity classes to be in the same project as the Hilla application;

- *Designed to be flexible*: all parts of the generator are pluggable, which allows you to alter the default behavior or add a new one.

[NOTE]
Spring Boot enables a Java compiler option to retain parameter names in class files. If generated classes are missing parameter names, you might need to enable this option in your project.
Use the `javac -parameters` option to enable support for multi-module projects and all JVM languages. See <<configuration#java-compiler-options,Configuration>> for details.


== Generator Architecture

The generator consists of three parts:

*Java bytecode parser*::
The parser reads the Java bytecode and generates an OpenAPI scheme.

*TypeScript Abstract Syntax Tree (AST) generator*::
The AST generator reads the OpenAPI scheme and generates TypeScript endpoints that could be used in further frontend development.

*Runtime controller*::
The runtime controller provides runtime communication between the server and the client.

Hilla uses the https://github.com/OAI/OpenAPI-Specification[OpenAPI Specification] as a middle layer between endpoints and TypeScript endpoint clients.
The implementation is based on OpenAPI specification 3.0.
For details, see <<appendix, the appendix at the end of this page>>.


== Examples

=== Generated TypeScript Endpoint


The `UserEndpoint.ts` class is generated from the `UserEndpoint.java` class.
[.example]
--
[[user-endpoint-ts]]
.`UserEndpoint.ts`
[source,typescript]
----
/**
 * User endpoint.
 *
 * This module has been generated from UserEndpoint.java
 * @module UserEndpoint
 */
import client from './connect-client.default'; // <1>

/**
 * Check if a user is admin or not.
 *
 * @param id User id to be checked
 * Return Return true if the given user is an admin, otherwise false.
 */
export async function isAdmin( // <2>
  id?: number
) {
  return await client.call('UserEndpoint', 'isAdmin', {id});
}
----

.`UserEndpoint.java`
[source,java]
----
/**
 * User endpoint.
 */
@Endpoint
public class UserEndpoint {
    /**
     * Check if a user is admin or not.
     *
     * @param id
     *            User id to be checked
     * @return Return true if the given user is an admin, otherwise false.
     */
    public boolean isAdmin(long id) {
        return id == 0;
    }
}
----
--
<1> This line is a static part of any generated TypeScript class. [filename]`connect-client.default.ts` is another generated file, which includes default configurations for the [classname]`ConnectClient` and exports its instance as `client`.
<2> Each method in the generated TypeScript class corresponds to a Java method in the `@Endpoint`-annotated class.

For more information about type mapping between Java and TypeScript, see <<type-conversion#, Type conversion>>. You may also want to learn about <<type-nullability#, Type nullability>>.





[[appendix]]
== Appendix: How a TypeScript class is generated from the OpenAPI specification

=== Modules / Classes

The generator collects all the `tags` fields of all operations in the OpenAPI document.
Each tag generates a corresponding TypeScript file.
The tag name is used for TypeScript module/class name, as well as the file name.

=== Methods

Each exported method in a module corresponds to a https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject[POST operation] of a https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#pathItemObject[path item] in https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#pathsObject[paths object].

[NOTE]
The generator only supports the `POST` operation.
If a path item contains operations other than `POST`, the generator stops processing.

The path *must* start with `/`, as described in https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#patterned-fields[Patterned Fields].
It's parsed as `/<endpoint name>/<method name>`, which is used as a parameter to call to Java endpoints in the backend.
The method name from the path is also reused as the method name in the generated TypeScript file.

==== Method Parameters

The parameters of the method are taken from the `application/json` content of the https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#requestBodyObject[request body object].
To get the result as <<user-endpoint-ts>>, the request body content should be:

[[request-body]]
.Request body
[source,json]
----
{
 "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          }
        }
      }
    }
  }
}
----

[NOTE]
====
All the other content types of the request body object are ignored by the Hilla generator.
This means that a method that doesn't have the `application/json` content type is considered to be one with no parameters.
====

==== Method Return Type

The return type is taken from the `200` https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#responseObject[response object].
As with the request body object, the generator is only interested in the `application/json` content type.
Here is an example of a https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#responsesObject[response object]:

[[response-object]]
.Response object
[source,json]
----
{
  "200": {
    "description": "Return true if the given user is an admin, otherwise false.",
    "content": {
      "application/json": {
        "schema": {
          "type": "boolean"
        }
      }
    }
  }
}
----

[NOTE]
====
Currently, the generator only recognizes `200` response objects.
Other response objects are ignored.
====

.Post Operation
[source,json]
----
{
  "tags": ["UserEndpoint"], // <1>
  "requestBody": {
    "content": {
      "application/json": {
        "schema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number"
            }
          }
        }
      }
    }
  },
  "responses": {
    "200": {
      "content": {
        "application/json": {
          "schema": {
            "type": "boolean"
          }
        }
      }
    }
  }
}
----

<1> As mentioned in the https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject[operation object] specification, in the Hilla generator, `tags` are used to classify operations into TypeScript files.
This means that each tag has a corresponding generated TypeScript file.
Operations that contain more than one tag appear in all the generated files.
Operations with empty tags are placed in the [filename]`Default.ts` file.

[NOTE]
Although multiple tags don't break the generator, it might be confusing at development time if there are two identical methods in different TypeScript files.
It's recommended to have only one tag per operation.

Here is an example OpenAPI document that could generate previous [filename]`UserEndpoint.ts`.

.User endpoint OpenAPI document
[source,json]
----
{
  "openapi" : "3.0.1",
  "info" : {
    "title" : "My example application",
    "version" : "1.0.0"
  },
  "servers" : [ {
    "url" : "https://myhost.com/myendpoint"
  } ],
  "tags" : [ {
    "name" : "UserEndpoint"
  } ],
  "paths" : {
    "/UserEndpoint/isAdmin" : {
      "post": {
        "tags": ["UserEndpoint"],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [ "id" ],
                "properties": {
                  "id": {
                    "type": "number"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    }
  }
}
----

// end::content[]
