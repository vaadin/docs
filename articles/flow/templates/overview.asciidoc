---
title: Overview
order: 1
layout: page
---

= Using Templates

In Vaadin, you have different options on how to build your views:

. Build your views purely with Java
. Define the layouts of your views declaratively and implement the UI logic in Java
. Build your views purely client-side with TypeScript and LitElement

These ways to build views can be mixed and matched within an application.
All Vaadin components are available through the Java API and declaratively in HTML.
The most appropriate option depends on your use case and preferences.
This chapter describes the second option: how to build your UIs declaratively, while implementing the logic in Java.

== Benefits of Using Templates

Defining the layout of a view separately from its logic results in clear, maintainable code.
It makes it easier to see how the view is defined and where it is updated.
HTML templates are a robust way of defining the UI structure, whereas Java is a great way to define the logic of the view.

Vaadin has support for two declarative template languages: Polymer and LitElement.
The LitElement library is the successor to the Polymer library.
Vaadin will continue support both Polymer and LitElement for the foreseeable future.
We recommend choosing LitElement as the template language when building new templates for your Vaadin applications.
The LitElement template language is lightweight, more focused, and more future-proof.

Vaadin can refer to and access components defined by a template from Java.
When you give unique IDs to components in the template, any component with an ID can be accessed through the Java API to configure the logic further.
You can add Java-only components such as compositions to a template by giving a layout an ID in the template and adding the component in Java code.

For example, `<vaadin-button id="my-button">Press me</vaadin-button>` can be accessed with `@Id("my-button") Button button;` in Java.

The framework parses the elements and their attributes inside a template to make the initial state of each mapped server-side component consistent with the attributes set in the template.

For instance, consider a template containing the text field `<vaadin-text-field id="name-field" placeholder="Enter name"></vaadin-text-field>`, which is mapped as the class member `@Id("name-field") TextField nameField` in Java.
After the server-side component is created, [methodname]#nameField.getPlaceholder()# returns the placeholder text (`"Enter name"`) immediately.

Declarative layouts are a robust and maintainable way of defining views.
This is why https://vaadin.com/designer[Vaadin Designer], the visual tool for building UI for Vaadin applications, uses them as its format.

== Known Limitations of Templates

The template API has limitations that you need to be aware of before using it.

* The framework considers any attribute other than `theme` or one of the https://www.w3.org/TR/html52/dom.html#global-attributes[HTML 5 global attributes] for server-side initialization.
However, if the attribute value is not a constant, that is, it contains bindings such as `${...}` and `{{...}}`, it is not parsed and the property is not initialized on the server side.
Only attributes are parsed.
Properties defined by nested elements, such as grid columns and items, are not parsed from the template but must be initialized on the server side.
* You can add components and elements to a template structure, but you cannot remove anything present in the original template.
However, overriding component properties is possible.
 * For `LitTemplate`, you cannot configure the column renderers for `Grid`, `TreeGrid` or `GridPro` in HTML.
The column configuration and driving of data needs to happen from Java to the `@Id`-mapped component.
`LitTemplate` differs `PolymerTemplate` in this regard.
* Calling [methodname]#setText()# from Java on a template-based component causes the removal of child elements.
For example, if the template is `<div id="myDiv">Some text<vaadin-button id="myButton">My Button</vaadin-button></div>`, calling [methodname]#myDiv.setText()# causes the `myButton` element to be removed.
To keep children, instead wrap the text content in a separate child alongside `myButton`, and call [methodname]#setText()# on that element: `<div id="myDiv"><span id="myTest">Some text</span><vaadin-button id="myButton">My Button</vaadin-button></div>`.

== Separating Structure and Logic

Try to only define things that do not change in the template, and leave all the dynamic parts to Java.
As an example, in the template you can have attributes that never change, captions for components like `Button` and `TextField` that always stay the same, or styling for the view.
For instance, if the caption of a `Button` changes depending on user interaction, then leave it empty in the template and define the initial value in Java.

With `Grid`, defining columns may seem like a static part, but columns and data are strongly related.
When using `vaadin-grid` inside a `LitTemplate`, the column configuration and driving of data must happen from the server-side Java code.

See <<basic#,Creating a Simple Component Using Templates>> for a full example with an HTML template and Java logic.
