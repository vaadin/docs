---
title: Remote Procedure Calls
page-title: How to use Remote Procedure Calls | Vaadin
description: Calling client-side functions from the server, and server-side methods from the client.
meta-description: Implement client-server communication using Remote Procedure Calls with Vaadin's element API.
order: 11
---


= Remote Procedure Calls
:toclevels: 2

Remote procedure calls (RPCs) are a way to run procedures or subroutines in a different address space, typically on another machine. Vaadin handles server-client communication by allowing RPC calls from the server to the client -- and vice versa.


== Calling Client-Side Functions from the Server

Use the Element API to call client-side functions from the server. This is covered in the <<element-api/calling-javascript#,Calling JavaScript from the Server>> reference guide.

*Example:* Calling the `this.clearSelection()` JavaScript function from the server side:

[source,java]
----
public void clearSelection() {
    getElement().callJsFunction("clearSelection");
}
----


== Calling Server-Side Methods from the Client

The `@ClientCallable` annotation allows you to invoke a server-side method from the client side.

Any method in the component class annotated with [annotationname]`@ClientCallable` can be called from the client side using [methodname]`element.$server.methodName(args)`, where `element` is the root element of the component.

You can use it anywhere in your client-side implementation, and you can pass your own arguments to the method. The types should match the method declaration on the server side. The supported argument types are:

- `boolean` , `int`, `double`, their boxed types (i.e., `Boolean` , `Integer`, `Double`);
- `String`;
- `JsonValue`; and
- enumeration types mapped to strings on the client side

*Example*: Making the `getGreeting(String)` method callable from the client side:

[source,java]
----
@ClientCallable
public String getGreeting(String name) {
    return "Hello " + name;
}
----

The client-side method returns a `Promise`, which is resolved asynchronously with the return value from the server. If the server-side return type is `void`, the promise is resolved with the return value `null`.

*Example*: Calling the `getGreeting(String)` method from a client-side `async` JavaScript function:

[source,javascript]
----
async getServerGreeting() {
  let greeting = await this.$server.getGreeting("JavaScript");
  console.log(greeting);
}
----

*Example*: Calling the `getGreeting(String)` method from a client-side JavaScript function using a callback:

[source,javascript]
----
getServerGreeting() {
  let greetingPromise = this.$server.getGreeting("JavaScript");
  greetingPromise.then(greeting => console.log(greeting));
}
----

.Hidden and Disabled Components
[IMPORTANT]
If a component is hidden or disabled, client-side method calls to the server are automatically blocked. See the <<enabled-state#,Component Enabled State>> and <<visibility#,Component Visibility>> reference guides for more information.


=== Server-Side Modality and `@ClientCallable`

If a component with a [annotationname]`@ClientCallable` method is underneath a modal dialog or component, it's considered _inert_. That means it's not available for interaction, including RPC calls. 

If you want the [annotationname]`@ClientCallable` method to be available when a component is inert, you'll need to annotate it with the [annotationname]`@AllowInert` annotation. Consult the <</flow/advanced/server-side-modality#,Server-Side Modality>> reference guide for more information.

*Example*: Allowing calls to `getGreeting()` even when the component is inert:

[source,java]
----
@ClientCallable
@AllowInert
public String getGreeting(String name) {
    return "Hello " + name;
}
----


[discussion-id]`AB7EDF45-DB22-4560-AF27-FF1DC6944482`
