---
title: Shared Signals
page-title: Shared Signals for Multi-User State in Vaadin Flow
description: Using shared signals for thread-safe, multi-user state management in Vaadin Flow applications.
meta-description: Learn how to use SharedValueSignal, SharedNumberSignal, SharedListSignal, and other shared signal types.
order: 30
---


= Shared Signals

Shared signals provide thread-safe, transactional state management for scenarios where state needs to be synchronized across multiple users or sessions. They are ideal for collaborative features, real-time dashboards, and any state that multiple users need to access concurrently.

:preview-feature: Signals
:feature-flag: com.vaadin.experimental.flowFullstackSignals
include::{articles}/_preview-banner.adoc[opts=optional]

All shared signal types are available in the `com.vaadin.signals.shared` package.


[.collapsible-list]
== Shared Signal Types

Several shared signal types are available for different use cases.


.SharedValueSignal
[%collapsible]
====
A signal containing a single value. The value is updated as a single atomic change.

[source,java]
----
import com.vaadin.signals.shared.SharedValueSignal;

SharedValueSignal<String> name = new SharedValueSignal<>(String.class);
name.value("John Doe"); // Set the value
String currentName = name.value(); // Get the value
----
====


.SharedNumberSignal
[%collapsible]
====
A specialized signal for numeric values with support for atomic increments and decrements. The signal value is represented as a `double` and there are methods to access the value as an `int`.

[source,java]
----
import com.vaadin.signals.shared.SharedNumberSignal;

SharedNumberSignal counter = new SharedNumberSignal();
counter.value(5); // Set the value
counter.incrementBy(1); // Increment by 1
counter.incrementBy(-2); // Decrement by 2
int count = counter.valueAsInt(); // Get the value as int
----
====


.SharedListSignal
[%collapsible]
====
A signal containing a list of values. Each value in the list is accessed as a separate [classname]`SharedValueSignal`. This is different from `SharedValueSignal<List<T>>` - a [classname]`SharedListSignal` tracks both structural changes (additions, removals, reordering) and individual item changes, while `SharedValueSignal<List<T>>` only notifies when the entire list is replaced.

[source,java]
----
import com.vaadin.signals.shared.SharedListSignal;

SharedListSignal<Person> persons = new SharedListSignal<>(Person.class);
persons.insertFirst(new Person("Jane", 25)); // Add to the beginning
persons.insertLast(new Person("John", 30)); // Add to the end
persons.insert(1, new Person("Bob", 20)); // Insert at specific index
List<SharedValueSignal<Person>> personList = persons.value(); // Get all persons
personList.get(0).value(new Person("Alice", 22)); // Update the value of a child signal
----
====


.SharedMapSignal
[%collapsible]
====
A signal containing a map of values with string keys (keys are always `String` type). Each value in the map is accessed as a separate [classname]`SharedValueSignal`.

[source,java]
----
import com.vaadin.signals.shared.SharedMapSignal;

SharedMapSignal<String> properties = new SharedMapSignal<>(String.class);
properties.put("name", "John"); // Add or update a property
properties.putIfAbsent("age", "30"); // Add only if not present
SharedValueSignal<String> nameSignal = properties.get("name"); // Get signal for a key
Map<String, SharedValueSignal<String>> propertyMap = properties.value(); // Get all properties
properties.remove("age"); // Remove an entry
----
====


.SharedNodeSignal
[%collapsible]
====
A signal representing a node in a tree structure. A node can have its own value and child signals accessed by order or by key. A child node is always either a list child or a map child, but it cannot have both roles at the same time.

[source,java]
----
import com.vaadin.signals.shared.SharedNodeSignal;

SharedNodeSignal user = new SharedNodeSignal();
user.putChildWithValue("name", "John Doe"); // Add a map child
user.putChildWithValue("age", 30); // Add another map child
user.insertChildWithValue("Reading", ListPosition.last()); // Add a hobby as a list child

user.value().mapChildren().get("name").asValue(String.class).value(); // Access 'John Doe'
user.value().mapChildren().get("age").asValue(Integer.class).value(); // Access 30
user.value().listChildren().getLast().asValue(String.class).value(); // Access 'Reading'

SharedMapSignal<String> mapChildren = user.asMap(String.class); // Access all map children
mapChildren.value().get("name"); // Alternative way of accessing 'John Doe'
----
====


== Signal Factory

The [classname]`SignalFactory` interface provides methods for creating signal instances based on a string key, value type, and initial value. It supports different strategies for creating instances:


=== IN_MEMORY_SHARED

Returns the same signal instance for the same name within the same JVM. This is similar to running the respective constructor to initialize a `static final` field.

[source,java]
----
SharedNodeSignal shared = SignalFactory.IN_MEMORY_SHARED.node("myNode");
SharedNumberSignal counter = SignalFactory.IN_MEMORY_SHARED.number("globalCounter");
SharedValueSignal<String> name = SignalFactory.IN_MEMORY_SHARED.value("userName", String.class);
----


=== IN_MEMORY_EXCLUSIVE

Always creates a new instance. Directly running the respective constructor typically leads to clearer code, but this factory can be used in cases where the same method supports multiple strategies.

[source,java]
----
SharedNodeSignal exclusive = SignalFactory.IN_MEMORY_EXCLUSIVE.node("myNode");
----

The [classname]`SignalFactory` interface is the extension point for creating custom signal factories. Additional factory implementations are planned for creating signal instances that are shared across multiple JVMs in a cluster.


== Reading Values


=== value() Method

The `value()` method returns the current locally-known value of the signal:

[source,java]
----
SharedValueSignal<String> signal = new SharedValueSignal<>(String.class);
String current = signal.value();
----


=== peek() Method

Use `peek()` to read a value without registering a dependency in effects or computed signals:

[source,java]
----
ComponentEffect.effect(component, () -> {
    // peek() doesn't register a dependency
    String peeked = signal.peek();
    // This effect won't re-run when signal changes
});
----


=== peekConfirmed() Method

The `peekConfirmed()` method returns the last value that has been confirmed by the cluster. This is useful in distributed scenarios where you need to know the definitive server-confirmed state:

[source,java]
----
SharedValueSignal<String> signal = new SharedValueSignal<>(String.class);

// Get the locally-known value (may include optimistic updates)
String optimistic = signal.value();

// Get only the cluster-confirmed value
String confirmed = signal.peekConfirmed();
----

In single-server deployments, `peekConfirmed()` typically returns the same value as `value()`. In clustered environments, there may be a brief delay between optimistic local updates and cluster confirmation.


== Subscribing to Changes

Use the `subscribe()` method to react to signal value changes outside of effects:

[source,java]
----
SharedValueSignal<String> signal = new SharedValueSignal<>(String.class);

signal.subscribe(() -> {
    System.out.println("Signal value changed to: " + signal.value());
});
----

For UI updates, prefer using <<effects-computed#,ComponentEffect>> which automatically manages the subscription lifecycle based on component attachment.


== Writing Values

All shared signals provide atomic write operations:

[source,java]
----
SharedValueSignal<String> signal = new SharedValueSignal<>(String.class);

// Direct value assignment
signal.value("New value");

// Update based on current value
signal.update(current -> current.toUpperCase());

// Replace only if current value matches expected
signal.replace("expected", "newValue");
----


== Thread Safety

Shared signals are designed for concurrent access from multiple threads and users. All operations are atomic and thread-safe. Signals handle UI updates automatically, so you don't need to wrap signal operations in `ui.access()`:

[source,java]
----
// Safe to use from any thread - no ui.access() needed
SharedNumberSignal counter = SignalFactory.IN_MEMORY_SHARED.number("counter");

// Multiple users can safely increment concurrently
counter.incrementBy(1); // Atomic operation, UI updates automatically
----


== Best Practices


=== Use Immutable Values

Signals work best with immutable values. This ensures that changes to signal values are always made through the signal API, which maintains consistency and reactivity.

[source,java]
----
SharedValueSignal<User> user = new SharedValueSignal<>(User.class);

// Good: Creating a new immutable object
user.update(u -> new User(u.getName(), u.getAge() + 1));

// Bad: Modifying the object directly
User u = user.value();
u.setAge(u.getAge() + 1); // This won't trigger reactivity!
----

Use Java Records for simple data structures:

[source,java]
----
record Person(String name, int age) {}

SharedValueSignal<Person> person = new SharedValueSignal<>(Person.class);
person.value(new Person("John", 30));

// Update creates a new record
person.update(p -> new Person(p.name(), p.age() + 1));
----


=== Store Signals as Fields

Always store signals as class fields, not local variables. Local signal variables may be garbage collected, causing computed signals and subscriptions to stop working:

[source,java]
----
public class MyView extends VerticalLayout {
    // Good: Signal stored as a field
    private final SharedValueSignal<String> nameSignal =
            SignalFactory.IN_MEMORY_SHARED.value("name", String.class);

    // Good: Computed signal stored as a field
    private final Signal<String> greeting = nameSignal.map(n -> "Hello, " + n);

    public MyView() {
        // Bad: Local computed signal may be garbage collected
        // Signal<String> localComputed = nameSignal.map(n -> "Hi, " + n);

        Span greetingSpan = new Span();
        ComponentEffect.bind(greetingSpan, greeting, Span::setText);
        add(greetingSpan);
    }
}
----


== Usage Examples


.Shared Counter Example
[example]
====
This example demonstrates a counter shared across all connected users:

[source,java]
----
public class SharedCounter extends VerticalLayout {
    private final SharedNumberSignal counter =
            SignalFactory.IN_MEMORY_SHARED.number("sharedCounter");

    public SharedCounter() {
        Button button = new Button();
        button.addClickListener(click -> counter.incrementBy(1));
        add(button);

        ComponentEffect.effect(button,
            () -> button.setText(String.format("Clicked %.0f times", counter.value())));
    }
}
----
====


.Shared Text Field Example
[example]
====
[source,java]
----
public class SharedText extends FormLayout {
    private final SharedValueSignal<String> value =
            SignalFactory.IN_MEMORY_SHARED.value("sharedText", String.class);

    public SharedText() {
        TextField field = new TextField("Value");

        ComponentEffect.bind(field, value, TextField::setValue);

        field.addValueChangeListener(event -> {
            // Only update signal if value changed to avoid infinite loop detection
            if (!event.getValue().equals(value.peek())) {
               value.value(event.getValue());
            }
        });

        add(field);
    }
}
----

Note that you need to <<{articles}/flow/advanced/server-push#push.configuration.enabling,enable push>> for your application to ensure changes are pushed out for all users immediately when one user makes a change.
====


.Shared List Example
[example]
====
[source,java]
----
public class PersonList extends VerticalLayout {
    private final SharedListSignal<String> persons =
            SignalFactory.IN_MEMORY_SHARED.list("persons", String.class);

    public PersonList() {
        Button addButton = new Button("Add Person", click -> {
            persons.insertFirst("New person");
        });

        Button updateButton = new Button("Update first Person", click -> {
            SharedValueSignal<String> first = persons.value().get(0);
            first.update(text -> text + " updated");
        });

        UnorderedList list = new UnorderedList();
        ComponentEffect.effect(list, () -> {
            list.removeAll();
            persons.value().forEach(personSignal -> {
                ListItem li = new ListItem();
                ComponentEffect.bind(li, personSignal, ListItem::setText);
                list.add(li);
            });
        });

        add(addButton, updateButton, list);
    }
}
----

The effect that creates new list item components runs only when a new item is added to the list, not when the value of an existing item is updated.
====


== Read-Only Signals

You can create read-only versions of signals that don't allow modifications. The original signal remains writeable and the read-only instance is also updated for any changes made to the original instance.

[source,java]
----
SharedValueSignal<String> name = SignalFactory.IN_MEMORY_SHARED.value("name", String.class);
SharedValueSignal<String> readOnlyName = name.asReadonly();

// readOnlyName.value("new") would throw an exception
----
