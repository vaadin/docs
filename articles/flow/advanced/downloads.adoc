---
title: Downloads
page-title: How to download from server to browser in Vaadin
description: Download a file or arbitrary content from server to browser.
meta-description: Learn how to handle download requests on server and transfer a content to browser in Vaadin Flow applications.
order: 110
---

= Handle Downloads
:toc:

The [classname]`DownloadHandler` API provides a flexible high-level abstraction to implement file and arbitrary contents downloads from server to browser in Vaadin applications.
This API supports various download scenarios, from simple file downloads to complex streaming with progress tracking.

[classname]`DownloadHandler` is supported by multiple Vaadin components where applicable.

This documentation covers the main features of the `DownloadHandler` API, including:

* <<#helpers,Static helper methods for common download scenarios>>
* <<#custom,Creating custom download handlers>>
* <<#progress,Download progress tracking>>
* <<#low-level,Low-level API features>>

[#helpers]
== Common Download Scenarios

The `DownloadHandler` API provides several static helper methods to simplify common download scenarios.

=== Download a Classpath Resource

The `forClassResource` method allows you to serve resources from the classpath.
For instance, for the file [filename]`src/main/resources/com/example/ui/vaadin.jpeg` and class [classname]`com.example.ui.MainView` the code would be:

[source,java]
----
Image logoImage = new Image(DownloadHandler.forClassResource(
        MainView.class, "vaadin.jpeg"), "Vaadin Logo");
----

This method is useful for serving static resources like images, CSS, or JavaScript files that are packaged with your application.

If the resource name starts with `/`, it will then look from `/src/main/resources` without the class path prepended.

=== Download A File From File System

The `forFile` method allows you to serve files from the server's file system.

[source,java]
----
Anchor download = new Anchor(DownloadHandler.forFile(new File("/path/to/terms-and-conditions.md")), "Download Terms and Conditions");
----

This method is useful for serving files that are stored on the server's file system.

=== Download Content from InputStream

The `fromInputStream` method allows you to serve content from any [classname]`InputStream`.
This is the most flexible helper method as it can be used with any data source that can provide an `InputStream`.

[source,java]
----
Anchor downloadAttachment = new Anchor(DownloadHandler.fromInputStream((event) -> {
    try {
        Attachment attachment = attachmentsRepository.findById(attachmentId);
        return new DownloadResponse(attachment.getData().getBinaryStream(),
                attachment.getName(), attachment.getMime(), attachment.getSize());
    } catch (Exception e) {
        return DownloadResponse.error(500);
    }
}, "attachment.txt"), "Download attachment");

@Entity
@Table(name = "attachment")
public class Attachment {
    @Lob
    @Column(name = "data", nullable = false)
    private Blob data;

    @Column(name = "size", nullable = false)
    private Integer size;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "mime", nullable = false)
    private String mime;

    public Blob getData() { return data; }
    public Integer getSize() { return size; }
    public String getName() { return name; }
    public String getMime() { return mime; }

    // other class fields and methods are omitted
}

public interface AttachmentRepository extends
    JpaRepository<Attachment, Long>, JpaSpecificationExecutor<Attachment> {
    Attachment findById(long id);

    // other class fields and methods are omitted
}
----

This method is particularly useful for:

* Serving content from databases or file storage
* Generating dynamic content
* Streaming large files

[#custom]
== Custom Download Handlers

For more complex download scenarios, you can create custom download handlers by implementing the `DownloadHandler` interface or extending existing implementations.

=== Implementing DownloadHandler Interface Using Lambda Expression

The [interfacename]`DownloadHandler` is a [annotationname]`FunctionalInterface` and can be created using a lambda expression or by creating an implementation.
Creating an implementation is needed only when overriding some of the default methods from the interface, e.g. [methodname]`getUrlPostfix`, [methodname]`isAllowInert` or [methodname]`getDisabledUpdateMode`:

[source,java]
----
Anchor downloadLink = new Anchor(new DownloadHandler() {
    @Override
    public void handleDownloadRequest(DownloadEvent event) {
        // Custom download handling logic
    }

    @Override
    public String getUrlPostfix() {
        return "custom-download.txt";
    }
}, "Download me!");
----

=== Custom Download Handler Examples

Here's an example of how a custom download handler can be written with lambda.
It adds a checksum header, updates the UI and tracks the number of downloads per session:

[source,java]
----
var filename = getFileName();
var contentType = getContentType();
LinkWithMD5Validation link = new LinkWithMD5Validation(event -> {
    try {
        event.setFileName(filename);
        event.setContentType(contentType);
        var data = loadFileFromS3(filename, contentType);
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        byte[] digest = md5.digest(data);
        String base64Md5 = Base64.getEncoder().encodeToString(digest);
        event.getResponse().setHeader("Content-MD5", base64Md5);
        event.getOutputStream().write(data);
        event.getUI().access(() -> Notification.show(
                "Download completed, number of downloads: " +
                    numberOfDownloads.incrementAndGet()));
        event.getSession().lock();
        try {
            event.getSession().setAttribute("downloads-number-" + event.getFileName(),
                    numberOfDownloads.get());
        } finally {
            event.getSession().unlock();
        }
    } catch (NoSuchAlgorithmException | IOException e) {
        event.getResponse().setStatus(500);
    }
}, "Download from S3");

private byte[] loadFileFromS3(String fileName, String contentType) {
    byte[] bytes = new byte[1024 * 1024 * 10]; // 10 MB buffer
    // load from file storage by file name and content type
    return bytes;
}

private static class LinkWithMD5Validation extends Anchor {
     // JS customizations in <a> for checksum checking on the client-side
}
----

This example shows how to:

* Set file meta-data with helpers in [classname]`DownloadEvent`
* Set the MD5 checksum header to the response
* Write data directly to the response output stream
* Update the UI after the download completes
* Store download statistics in the session

The [classname]`DownloadEvent` gives the access to the following information and helper methods:
* [classname]`VaadinRequest`, [classname]`VaadinResponse`, [classname]`VaadinSession` instances
* [methodname]`getOutputStream` method to write the download content represented as a stream of bytes to response
* [methodname]`getWriter` method to write the download content represented as a formatted text to response
* The owner component and element of the download that you can change when download is in progress, e.g. disable the component, or get attributes or properties
* [classname]`UI` instance that you can use to call `UI.access()` for asynchronous updates
* The helper [methodname]`setFileName` method sets the file name for the download, empty name gives a default name and `null` value doesn't set anything
* The helper [methodname]`setContentType` method sets the content type for the download
* The helper [methodname]`setContentLength` method sets the content length for the download or does nothing if the `-1` value is given

[NOTE]
`UI.access` is needed for updating the UI and also session locking if you want to access the session.

[NOTE]
Methods [methodname]`getOutputStream` and [methodname]`getWriter` cannot be used simultaneously for the same response, either one or the other.

Another example is how to generate and render a dynamic content using a [classname]`DownloadHandler`.

[source,java]
----
TextField name = new TextField("Input a name...");
HtmlObject image = new HtmlObject();
image.setType("image/svg+xml");
image.getStyle().set("display", "block");
Button button = new Button("Generate Image", click -> image.setData(
    DownloadHandler.fromInputStream(event -> new DownloadResponse(
            getImageInputStream(name), "image.svg", "image/svg+xml", -1))));
----

The `HtmlObject` component is used to render the SVG image in the browser that is generated dynamically based on the input from the `TextField`.
On a button click the [classname]`DownloadHandler` is created with the [methodname]`fromInputStream` method that is set to `HtmlObject` component and that sends content to a client.
And here is an example of how to generate an svg image and create an input stream:

[source,java]
----
private InputStream getImageInputStream(TextField name) {
    String value = name.getValue();
    if (value == null) {
        value = "";
    }
    String svg = "<?xml version='1.0' encoding='UTF-8' standalone='no'?>"
        + "<svg xmlns='http://www.w3.org/2000/svg' "
        + "xmlns:xlink='http://www.w3.org/1999/xlink'>"
        + "<rect x='10' y='10' height='100' width='100' "
        + "style=' fill: #90C3D4'/><text x='30' y='30' fill='red'>"
        + value + "</text>" + "</svg>";
    return new ByteArrayInputStream(svg.getBytes(StandardCharsets.UTF_8));
}
----

[#progress]
== Download Progress Listeners

The `DownloadHandler` API provides two ways to track download progress:

1. Using the fluent API with shorthand methods
2. Implementing the [classname]`TransferProgressListener` interface

Asynchronous UI updates in progress listeners are automatically wrapped into `UI.access()` calls by Vaadin, thus you don't need to call it manually.
Vaadin `@Push` should be enabled in your application to be able to see UI updates while download is in progress.

=== Fluent API for Progress Tracking

The fluent API provides a concise way to track download progress using method chaining.

[source,java]
----
InputStreamDownloadHandler handler = DownloadHandler.fromInputStream(event ->
        new DownloadResponse(getInputStream(), "download.bin",
            "application/octet-stream", contentSize))
    .whenStart(() -> {
        Notification.show("Download started", 3000, Notification.Position.BOTTOM_START);
        progressBar.setVisible(true);
    })
    .onProgress((transferred, total) -> progressBar.setValue((double) transferred / total))
    .whenComplete(success -> {
        progressBar.setVisible(false);
        if (success) {
            Notification.show("Download completed", 3000, Notification.Position.BOTTOM_START)
                .addThemeVariants(NotificationVariant.LUMO_SUCCESS);
        } else {
            Notification.show("Download failed", 3000, Notification.Position.BOTTOM_START)
                    .addThemeVariants(NotificationVariant.LUMO_ERROR);
        }
    });
----

The fluent API provides the following methods:

* `whenStart(Runnable)`: Called when the download starts
* `onProgress(BiConsumer<Long, Long>)`: Called during the download with transferred and total bytes
* `onProgress(BiConsumer<Long, Long>, Long)`: Called during the download with transferred and total bytes and with the given progress interval in bytes
* `whenComplete(Consumer<Boolean>)`: Called when the download completes successfully or with a failure

These methods have overloads that accept also the [classname]`TransferContext` object that gives more information and references:
* [classname]`VaadinRequest`, [classname]`VaadinResponse`, [classname]`VaadinSession` instances
* The owner component and element of the data transfer that you can change when transfer is in progress, e.g. disable the component, or get attributes or properties
* [classname]`UI` instance that you can use to call `UI.access()` for asynchronous updates in threads
* The name of the file being transferred, might be <code>null</code> if the file name is not known
* The content length of the file being transferred, might be <code>-1</code> if the content length is not known

=== TransferProgressListener Interface

For more control over download progress tracking, you can implement the `TransferProgressListener` interface.

[source,java]
----
InputStreamDownloadHandler handler = DownloadHandler.fromInputStream(event ->
        new DownloadResponse(getInputStream(), "download.bin",
            "application/octet-stream", contentSize),
        "download.bin", new TransferProgressListener() {
    @Override
    public void onStart(TransferContext context) {
        Notification.show("Download started for file " + context.fileName(),
                3000, Notification.Position.BOTTOM_START);
        progressBar.setVisible(true);
    }

    @Override
    public void onProgress(TransferContext context, long transferredBytes,
                             long totalBytes) {
        progressBar.setValue((double) transferredBytes / totalBytes);
    }

    @Override
    public void onError(TransferContext context, IOException reason) {
        progressBar.setVisible(false);
        Notification.show("Download failed, reason: " + reason.getMessage(),
                3000, Notification.Position.BOTTOM_START);
    }

    @Override
    public void onComplete(TransferContext context, long transferredBytes) {
        progressBar.setVisible(false);
        Notification.show("Download completed, total bytes " + transferredBytes,
                        3000, Notification.Position.BOTTOM_START);
    }

    @Override
    public long progressReportInterval() {
        return 1024 * 1024 * 2; // 2 MB
    }
});
----

The `TransferProgressListener` interface provides the following methods:

* `onStart(TransferContext)`: Called when the download starts
* `onProgress(TransferContext, long, long)`: Called during the download with transferred and total bytes
* `onError(TransferContext, IOException)`: Called when the download fails with an exception
* `onComplete(TransferContext, long)`: Called when the download completes with the total transferred bytes
* `progressReportInterval()`: Defines how often progress updates are sent (in bytes)

The [classname]`TransferContext` objects are the same as in the fluent API.

[#low-level]
== Low-Level DownloadHandler API

The `DownloadHandler` API provides several low-level features for advanced use cases.

=== Inert Property

The `inert` property controls whether the download should be handled when the owner component is in an inert state, e.g. when a modal dialog is opened while the owner component is on the underlined page.
See the <<../advanced/server-side-modality.adoc#,Server-Side Modality>> for details.

[classname]`DownloadHandler` allows to handle download request from inert component by overriding the [methodname]`isAllowInert()` method.

=== Disabled Update Mode

The [classname]`DisabledUpdateMode` controls whether downloads are allowed when the owner component is disabled.

The available modes are:

* `ONLY_WHEN_ENABLED`: Download handling is rejected when the owner component is disabled (default)
* `ALWAYS`: Download handling is allowed even when the owner component is disabled

[classname]`DownloadHandler` allows to override this mode by overriding the [methodname]`getDisabledUpdateMode()` method.

=== URL Postfix

The [methodname]`getUrlPostfix()` method allows you to specify an optional URL postfix that appends application-controlled string, e.g. the logical name of the target file, to the end of the otherwise random-looking download URL.
If defined, requests that would otherwise be servable are still rejected if the postfix is missing or invalid.

This is useful for:

* Providing a meaningful filename into the download handler callback
* Making the download request URL look more user-friendly as otherwise it is a random-looking URL

[source,java]
----
Anchor downloadLink = new Anchor(new DownloadHandler() {
    @Override
    public void handleDownloadRequest(DownloadEvent event) {
        // download handling...
    }

    @Override
    public boolean allowInert() {
        return true; // default is false
    }

    @Override
    public DisabledUpdateMode getDisabledUpdateMode() {
        return DisabledUpdateMode.ALWAYS; // the default is ONLY_WHEN_ENABLED
    }

    @Override
    public String getUrlPostfix() {
        return "meeting-notes.txt";
    }
}, "Download meeting notes");
----
