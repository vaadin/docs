---
title: Server Push
page-title: Server Push Configuration Reference - Vaadin Docs
description: Configuration reference for server push in Vaadin Flow applications.
meta-description: Reference documentation for server push configuration options, annotations, and transport modes in Vaadin Flow.
order: 620
---


[[push.configuration]]
= Server Push Configuration

Server push is based on a client-server connection established by the client. The server can then use the connection to send updates to the client. Vaadin uses the link:https://github.com/Atmosphere/atmosphere[Atmosphere framework] internally for server push communication.

For practical usage guides and patterns, see <<{articles}/building-apps/server-push#,Server Push>> in the Building Apps section.


[[push.configuration.annotation]]
== The @Push Annotation

Enable server push by adding the `@Push` annotation to a class implementing `AppShellConfigurator`:

[source,java]
----
@Push
public class Application implements AppShellConfigurator {
  ...
}
----

The annotation supports the following parameters:

[cols="1,1,3"]
|===
|Parameter |Default |Description

|`value`
|`PushMode.AUTOMATIC`
|The push mode. See <<push.configuration.pushmode>>.

|`transport`
|`Transport.WEBSOCKET_XHR`
|The transport mechanism. See <<push.configuration.transport>>.
|===


[[push.configuration.pushmode]]
== Push Modes

Server push operates in one of two modes:

[cols="1,3"]
|===
|Mode |Description

|`PushMode.AUTOMATIC`
|Changes are pushed to the browser automatically after `UI.access()` finishes. This is the default mode.

|`PushMode.MANUAL`
|Changes are pushed only when you explicitly call `UI.push()`. Use this for fine-grained control over when updates are sent.
|===

Example with manual mode:

[source,java]
----
@Push(PushMode.MANUAL)
public class Application implements AppShellConfigurator {
  ...
}
----


[[push.configuration.transport]]
== Transport Options

// Allow XHR
pass:[<!-- vale Vaadin.Abbr = NO -->]

Server push supports three transport mechanisms:

[cols="1,3"]
|===
|Transport |Description

|`Transport.WEBSOCKET_XHR`
|Combined WebSockets and XHR. This is the default and recommended transport.

|`Transport.WEBSOCKET`
|Pure WebSocket connection.

|`Transport.LONG_POLLING`
|HTTP long polling. Use this if WebSocket connections are blocked by proxies or firewalls.
|===

pass:[<!-- vale Vaadin.Abbr = YES -->]

Example with long polling:

[source,java]
----
@Push(transport = Transport.LONG_POLLING)
public class Application implements AppShellConfigurator {
  ...
}
----


[[push.configuration.servlet]]
== Servlet Configuration

If you're manually configuring your servlet, set the `async-supported` parameter to enable push support.

You can also configure push mode for the entire application in the servlet configuration with the `pushMode` parameter in the `web.xml` deployment descriptor, or a corresponding `@WebServlet` annotation.

On the server side, the push endpoint is mapped to the `VAADIN/push` path. This mapping is added either under context root, context path, or the first URL mapping (sorted by natural order and ignoring `/VAADIN/{empty}*` and `/vaadinServlet/{empty}*`) of the Vaadin servlet, depending on application deployment configuration. For multiple servlet mappings, configure the `pushServletMapping` parameter to match the desired mapping.


[[push.access]]
== UI.access() Method

Making changes to a UI from another thread requires locking the user session to prevent conflicts with regular event-driven updates. Use the `UI.access()` method to safely update the UI from background threads:

[source,java]
----
ui.access(() -> statusLabel.setText(statusText));
----

With manual push mode, call `UI.push()` explicitly:

[source,java]
----
ui.access(() -> {
    statusLabel.setText(statusText);
    ui.push();
});
----

For detailed patterns and best practices for using `UI.access()`, including how to avoid memory leaks and flooding, see <<{articles}/building-apps/server-push/updates#,Pushing UI Updates>>.

[discussion-id]`77E22B23-4E6A-4D32-AFCC-2423F633F81D`
