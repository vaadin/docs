---
title: View Based Access Control
order: 25
layout: page
---

= View-Based Access Control

[role="since:com.vaadin:vaadin@V21 standalone"]
--
--

Vaadin Flow applications can use a view-based access control mechanism out of the box.
If an application is based on Spring Boot, this mechanism can be enabled by using a set of annotations and with minimum Spring Security configurations.
However, it is also possible to use it in Vaadin Spring applications that are not based on Spring Boot, with some extra configurations.

== Introduction

You can protect restricted views in Spring-based Vaadin Flow applications in the following ways:

- By using Spring Security's URL pattern based HTTP security configurations
- By adding View-Based Access Control mechanism

Navigating between routes of a Vaadin Flow application does not send traditional page requests to the server. 
So checking authorized access to views using only the Spring Security URL-based-filtering mechanism would either secure only the first requested route, or there would simply be no security at all for the views.
This happens generally for any single-page application that tries to secure its routes using only Spring Security.

.Do not rely on Spring Security's URL-based authorization in single-page applications
[NOTE]
View-based access control is the main mechanism for restricting access to views.
You should not use the traditional Spring Security URL-based [classname]#HttpSecurity# configurations as a mechanism for securing views at all (except for static resources, as URLs are the only way to load them).


*This is where view-based access control comes in*, to fully secure views in Vaadin Flow applications in a very flexible way, based on different access level annotations.
The view-based access control mechanism uses the `@AnonymousAllowed`, `@PermitAll`, `@RolesAllowed`, and `@DenyAll` annotations on view classes to define the access control rules.

.The use of annotations in Vaadin Fusion
[TIP]
Although the same set of annotations are used to define the security access control rules on endpoints of a <<{articles}/fusion/overview#,Vaadin Fusion>> application, this document does not describe how to secure client-side views.
You can find out more about security in a Vaadin Fusion application <<{articles}/fusion/security/configuring#,here>>.

The approach of the <<View-Based Access Control in Spring Boot-Based Applications,first part of this documentation>> is based on Vaadin's Spring Boot and Spring Security autoconfiguration.
If you are not using Spring Boot in your Vaadin Flow application, you may need extra configurations to enable this access control mechanism. There is more information on this in <<View-Based Access Control in Spring-Based Applications>> (without Spring Boot).

== View-Based Access Control in Spring Boot-Based Applications

As mentioned in the <<Introduction,Introduction>>, the mechanism is based on Spring Security and Vaadin's Spring Boot autoconfiguration.
To enable the mechanism in a Vaadin Flow Spring Boot application without any security, add the following to the project (if they do not exist already):

- A Login view.
- Spring Security dependencies.
- A security configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
- Annotate the view classes with the `@AnonymousAllowed`, `@PermitAll`, or `@RolesAllowed` annotations.

.Source for the complete example code
[TIP]
A complete example project, including the source code from this document, is available https://github.com/vaadin-learning-center/crm-tutorial/tree/latest[here].

=== Login View

Having a login view is a basic requirement of many authentication and authorization mechanisms, in order to be able to redirect anonymous users to that page before giving access to view any protected resources.

.`LoginView.java`
[source,java]
----
@Route("login")
@PageTitle("Login")
public class LoginView extends VerticalLayout implements BeforeEnterObserver {

    private LoginForm login = new LoginForm();

    public LoginView() {
        addClassName("login-view");
        setSizeFull();

        setJustifyContentMode(JustifyContentMode.CENTER);
        setAlignItems(Alignment.CENTER);

        login.setAction("login");

        add(new H1("Test Application"), login);
    }

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        if(beforeEnterEvent.getLocation()
            .getQueryParameters()
            .getParameters()
            .containsKey("error")) {
            login.setError(true);
        }
    }
}
----

.Usage of Vaadin's LoginForm component
[NOTE]
In this example, we use Vaadin's `LoginForm` component for the sake of brevity in this implementation.
However, there is no obligation to do so; feel free to implement your own Login view, as you wish.

=== Spring Security Dependencies

To enable Spring Security in a Spring Boot application there are certain dependencies that should be added to the project.
_As this part of the documentation is based on a Spring Boot project, we recommend adding the following dependency_:

.Spring Boot Starter Security dependency that should be added to the `pom.xml` file:
[source,XML]
----
<dependencies>
    <!-- other dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- other dependencies -->
</dependencies>
----

=== Security Configuration Class

The next step is to have a Spring Security Configuration class that extends `VaadinWebSecurityConfigurerAdapter`.
There is no convention for naming this class, so in this documentation it is named `SecurityConfiguration`.
However, take care with Spring Security annotations.
Here is a minimal implementation of such a class:

.`SecurityConfiguration.java`
[source,java]
----
@EnableWebSecurity
@Configuration
public class SecurityConfiguration extends VaadinWebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Delegating the responsibility of general configurations
        // of http security to the super class. It is configuring
        // the followings: Vaadin's CSRF protection by ignoring
        // framework's internal requests, default request cache,
        // ignoring public views annotated with @AnonymousAllowed,
        // restricting access to other views/endpoints, and enabling
        // ViewAccessChecker authorization.
        // You can add any possible extra configurations of your own
        // here (the following is just an example):

        // http.rememberMe().alwaysRemember(false);

        super.configure(http);

        // This is important to register your login view to the
        // view access checker mechanism:
        setLoginView(http, LoginView.class);
    }

    /**
     * Allows access to static resources, bypassing Spring security.
     */
    @Override
    public void configure(WebSecurity web) throws Exception {
        // Configure your static resources with public access here:
        web.ignoring().antMatchers(
                "/images/**"
        );

        // Delegating the ignoring configuration for Vaadin's
        // related static resources to the super class:
        super.configure(web);
    }

    /**
     * Demo UserDetailService which only provide two hardcoded
     * in memory users and their roles.
     * NOTE: This should not be used in real world applications.
     */
    @Bean
    @Override
    public UserDetailsService userDetailsService() {
        UserDetails user =
                User.withUsername("user")
                        .password("{noop}user")
                        .roles("USER")
                        .build();
        UserDetails admin =
                User.withUsername("admin")
                        .password("{noop}admin")
                        .roles("ADMIN")
                        .build();
        return new InMemoryUserDetailsManager(user, admin);
    }
}
----

Before we go any further, it is worth noticing the `@EnableWebSecurity` and `@Configuration` annotations on top of the above class.
As their names imply, they tell Spring to enable its security features.

The next thing to notice is the parent class: `VaadinWebSecurityConfigurerAdapter`.
If you are familiar with Spring Boot and Spring Security, you may be aware that you can extend Spring's `WebSecurityConfigurerAdapter` directly and configure a lot of things from scratch.
However, there are some benefits to extending from `VaadinWebSecurityConfigurerAdapter`:

- The default implementation of the `configure` methods takes care of all the Vaadin-related configurations, for example ignoring static resources, or enabling `CSRF` checking while ignoring unnecessary checking for Vaadin internal requests, etc.
- The view-based access control mechanism is enabled by default.
- The login view can be configured simply via the provided `setLoginView` method.

.Never use hard-coded credentials in production
[WARNING]
The implementation of `userDetailsService` method is obviously just an in-memory implementation for the sake of brevity in this documentation.
In a real-world application, you can change the Spring Security configuration to use an authentication provider for LDAP, JAAS, and other real-world sources. https://dzone.com/articles/spring-security-authentication[Read more about Spring Security authentication providers].

The most important configuration in the above example is the call to the `setLoginView(http, LoginView.class);` inside the first configure method.
This is how the view-based access control mechanism knows where to redirect the users when they attempt to navigate to a protected view.

Now that the `LoginView` is ready, and it is set as the login view in the security configuration, it is time to move forward and see how the security annotations work on the views.

=== Annotating the View Classes

Before we provide some usage examples of the access annotations, it would be useful to have a closer look at the annotations, and their meaning when applied to a view:

- `@AnonymousAllowed` permits anyone to navigate to the view without any authentication or authorization.
- `@PermitAll` allows any *authenticated* user to navigate to the view.
- `@RolesAllowed` grants access to users having the roles specified in the annotation value.
- `@DenyAll` disallows everyone from navigating to the view.
This is the default, which means that, if a view is not annotated at all, the `@DenyAll` logic is applied.

Note that when the security configuration class extends from `VaadinWebSecurityConfigurerAdapter`, Vaadin's `SpringSecurityAutoConfiguration` comes into play and *enables the view-based access control* mechanism.
Therefore, none of the views are accessible until one of the above annotations (except `@DenyAll`) is applied to them.

Some examples:

.Example of using @AnonymousAllowed to enable all users to navigate to this view
[source,java]
----
@Route(value = "", layout = MainView.class)
@PageTitle("Public View")
@AnonymousAllowed
public class PublicView extends VerticalLayout {
    // ...
}
----

.Example of using @PermitAll to allow only authenticated users (with any role) to navigate to this view
[source,java]
----
@Route(value = "private", layout = MainView.class)
@PageTitle("Private View")
@PermitAll
public class PrivateView extends VerticalLayout {
    // ...
}
----

.Example of using @RolesAllowed to enable only the users with `ADMIN` role to navigate to this view
[source,java]
----
@Route(value = "admin", layout = MainView.class)
@PageTitle("Admin View")
@RolesAllowed("ADMIN") // <- Should match one of the user's roles (case-sensitive)
public class AdminView extends VerticalLayout {
    // ...
}
----

If multiple annotations are specified on a single view, the following rules are applied:

- `DenyAll` overrides other annotations
- `AnonymousAllowed` overrides `RolesAllowed` and `PermitAll`
- `RolesAllowed` overrides `PermitAll`

However, specifying more than one of the above access annotations on a view class is not recommended, as it is confusing and there is probably no logical reason to do so.

== Limitations
Mixing any of the view access annotations with Spring's URL-based HTTP security (which probably exist in older Vaadin Spring Boot applications) may result in unwanted access configurations or unnecessary complications.

.Do not mix Spring's URL-based HTTP security and view-based access control on a single view
[IMPORTANT]
Vaadin strongly recommends *not* mixing Spring's URL-pattern-based HTTP security and this view-based access control mechanism targeting the same views, since it may lead to unwanted access configurations, or at the very least an unnecessary complication in the authorization of views.
