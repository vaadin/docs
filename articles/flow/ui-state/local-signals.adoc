---
title: Local Signals
page-title: Local Signals for UI-Only State in Vaadin Flow
description: Using local signals for UI-only state management.
meta-description: Learn how to use local ValueSignal for managing UI-only state in Vaadin Flow.
order: 20
---


= Local Signals

Local signals provide lightweight, UI-only state management for scenarios where state doesn't need to be shared across users or sessions. They are ideal for managing component-level state like visibility toggles, form state, or local UI preferences.


== Overview

The [classname]`ValueSignal` class is a writable signal that holds a reference to a value. Local signals are scoped to a single UI session, providing a simple and efficient way to manage component-level state.

[source,java]
----
import com.vaadin.signals.local.ValueSignal;

ValueSignal<String> localName = new ValueSignal<>("Initial value");
----


== Creating Local Signals

Local signals can be created with or without an initial value:

[source,java]
----
// With initial value
ValueSignal<String> nameSignal = new ValueSignal<>("John");

// Without initial value (null)
ValueSignal<User> userSignal = new ValueSignal<>();
----


== Reading and Writing Values

Use the `value()` method to both read and write signal values:

[source,java]
----
ValueSignal<String> signal = new ValueSignal<>("Hello");

// Read the current value
String current = signal.value();

// Write a new value
signal.value("World");
----


== Updating Values

The `update()` method allows you to update a value based on its current state:

[source,java]
----
ValueSignal<Integer> counter = new ValueSignal<>(0);

// Update based on current value
counter.update(current -> current + 1);
----

This is particularly useful for updating records or beans where you need to create a new instance with modified properties:

[source,java]
----
record Task(String text, TaskState state) {}

ValueSignal<Task> taskSignal = new ValueSignal<>(new Task("Write docs", TaskState.PENDING));

// Update task state by creating a new record with the modified value
taskSignal.update(t -> new Task(t.text(), TaskState.COMPLETED));
----


== Replacing Values

The `replace()` method performs a compare-and-set operation:

[source,java]
----
ValueSignal<String> status = new ValueSignal<>("pending");

// Only replaces if current value matches expected
boolean replaced = status.replace("pending", "complete");
----


== Working with Mutable Values

For mutable values, use the `modify(Consumer)` method to perform updates. This method ensures the signal properly tracks changes:

[source,java]
----
public class User {
    private String name;
    private int age;

    // getters and setters...
}

ValueSignal<User> userSignal = new ValueSignal<>(new User("Jane", 25));

// Correct: Use modify() for mutable objects
userSignal.modify(user -> user.setAge(26));

// Incorrect: Direct mutation won't trigger reactivity
User user = userSignal.value();
user.setAge(27); // This change won't be detected!
----

[WARNING]
Direct mutation of objects retrieved from a signal won't trigger reactive updates. Always use `modify()` for mutable values, or preferably use immutable types like Java records.


== Thread Safety

Local signals are thread-safe and can be updated from any thread without wrapping calls in `ui.access()`. The signal handles UI synchronization internally:

[source,java]
----
public class MyView extends VerticalLayout {
    private final ValueSignal<String> localState = new ValueSignal<>("");

    public MyView() {
        TextField field = new TextField();
        field.bindValue(localState);

        Span output = new Span();
        output.bindText(localState);
        add(field, output);
    }
}
----

[NOTE]
When updating signals from background threads, ensure your application has the `@Push` annotation enabled. This allows the server to push UI updates to the client when signal values change asynchronously.

However, local signals are scoped to a single server instance. Vaadin doesn't yet provide an integrated solution for sharing local signals within a cluster. If you need state that works across a cluster or is shared between users, use <<shared-signals#,Shared Signals>> instead.


== Transaction Limitations

Local signals cannot participate in signal transactions:

[source,java]
----
ValueSignal<String> local = new ValueSignal<>("value");

// This will throw an exception
Signal.runInTransaction(() -> {
    local.value("new value"); // Not allowed!
});
----

Use shared signals if you need transactional guarantees. See <<transactions#,Transactions>> for more information about signal transactions.


== Peeking Values

Use `peek()` to read a value without registering a dependency in effects or computed signals:

[source,java]
----
ValueSignal<String> signal = new ValueSignal<>("Hello");

ComponentEffect.effect(component, () -> {
    // peek() doesn't register a dependency
    String peeked = signal.peek();
    // This effect won't re-run when signal changes
});
----


== Transforming Signal Values

Use the `map()` method to create a computed signal that transforms the original value:

[source,java]
----
ValueSignal<String> name = new ValueSignal<>("john");
Signal<String> upperName = name.map(String::toUpperCase);

// upperName.value() returns "JOHN"
// When name changes, upperName automatically updates
----

Use `map()` for single-signal transformations. For transformations depending on multiple signals, use `Signal.computed()` instead.


== Organizing Signals as Fields

Storing signals as class fields is recommended for better code organization. It keeps all reactive state together at the top of the class, making it easier to understand the component's state at a glance:

[source,java]
----
public class MyView extends VerticalLayout {
    // State is clearly visible at the top of the class
    private final ValueSignal<String> nameSignal = new ValueSignal<>("");
    private final Signal<String> greeting = nameSignal.map(n -> "Hello, " + n);

    public MyView() {
        // Components can be local variables since they're added to the layout
        Span greetingSpan = new Span();
        greetingSpan.bindText(greeting);
        add(greetingSpan);
    }
}
----

This pattern also allows computed signals to be defined declaratively alongside their source signals, making the reactive dependencies clear.


== Use Cases

Local signals are ideal for:

- *UI toggle states*: Panel expansion, modal visibility, sidebar open/closed
- *Form state*: Current step in a wizard, validation state
- *Local filters*: Search text, sort order within a single view
- *Temporary state*: Editing mode, selection state

[source,java]
----
public class ExpandablePanel extends VerticalLayout {
    private final ValueSignal<Boolean> expanded = new ValueSignal<>(false);

    public ExpandablePanel(String title, Component content) {
        Button header = new Button(title);
        header.addClickListener(e -> expanded.update(v -> !v));

        // Reactively show/hide content
        content.bindVisible(expanded);

        add(header, content);
    }
}
----
