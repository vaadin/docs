---
title: Local Signals
page-title: Local Signals for UI-Only State in Vaadin Flow
description: Using local signals for UI-only state management.
meta-description: Learn how to use local ValueSignal and ListSignal for managing UI-only state in Vaadin Flow.
order: 20
---


= Local Signals

Local signals provide lightweight, UI-only state management for scenarios where state doesn't need to be shared across users or sessions. They are ideal for managing component-level state like visibility toggles, form state, or local UI preferences.


== Overview

Local signals are scoped to a single UI session, providing a simple and efficient way to manage component-level state. Two types of local signals are available:

* [classname]`ValueSignal<T>` - holds a single value
* [classname]`ListSignal<T>` - holds an ordered list of values with per-entry reactivity

[source,java]
----
import com.vaadin.signals.local.ValueSignal;
import com.vaadin.signals.local.ListSignal;

ValueSignal<String> name = new ValueSignal<>("Initial value");
ListSignal<String> items = new ListSignal<>();
----


== Creating Local Signals

Local signals can be created with or without an initial value:

[source,java]
----
// With initial value
ValueSignal<String> nameSignal = new ValueSignal<>("John");

// Without initial value (null)
ValueSignal<User> userSignal = new ValueSignal<>();
----


== Reading and Writing Values

Use the `value()` method to both read and write signal values:

[source,java]
----
ValueSignal<String> signal = new ValueSignal<>("Hello");

// Read the current value
String current = signal.value();

// Write a new value
signal.value("World");
----


== Updating Values

The `update()` method allows you to update a value based on its current state:

[source,java]
----
ValueSignal<Integer> counter = new ValueSignal<>(0);

// Update based on current value
counter.update(current -> current + 1);
----

This is particularly useful for updating records or beans where you need to create a new instance with modified properties:

[source,java]
----
record Task(String text, TaskState state) {}

ValueSignal<Task> taskSignal = new ValueSignal<>(new Task("Write docs", TaskState.PENDING));

// Update task state by creating a new record with the modified value
taskSignal.update(t -> new Task(t.text(), TaskState.COMPLETED));
----


== ListSignal

[classname]`ListSignal<T>` provides an ordered list of values where each entry is independently reactive. Changes to the list structure (adding or removing items) trigger list-level dependents, while changes to individual entry values only trigger that entry's dependents.

[source,java]
----
import com.vaadin.signals.local.ListSignal;

ListSignal<String> tags = new ListSignal<>();
----


=== Adding Items

Use [methodname]`insertFirst()`, [methodname]`insertLast()`, or [methodname]`insertAt()` to add items:

[source,java]
----
ListSignal<String> items = new ListSignal<>();

// Add to the end (most common)
ValueSignal<String> lastItem = items.insertLast("Last");

// Add to the beginning
ValueSignal<String> firstItem = items.insertFirst("First");

// Add at a specific position (0-indexed)
ValueSignal<String> middleItem = items.insertAt(1, "Middle");

// List is now: ["First", "Middle", "Last"]
----

Each insert method returns a [classname]`ValueSignal<T>` representing the entry. You can use this signal to update or remove the entry later.


=== Removing Items

Use [methodname]`remove()` to remove a specific entry, or [methodname]`clear()` to remove all entries:

[source,java]
----
ListSignal<String> items = new ListSignal<>();
ValueSignal<String> entry = items.insertLast("Item to remove");

// Remove a specific entry
items.remove(entry);

// Remove all entries
items.clear();
----


=== Reading List Contents

Use [methodname]`value()` to get a snapshot of the list:

[source,java]
----
ListSignal<String> items = new ListSignal<>();
items.insertLast("A");
items.insertLast("B");

// Get a snapshot list of ValueSignal entries
List<ValueSignal<String>> entries = items.value();

// Read values from entries
entries.forEach(entry -> System.out.println(entry.value()));
----


=== Updating Entry Values

Since each list entry is a [classname]`ValueSignal`, you can update individual entries without affecting other entries or the list structure:

[source,java]
----
ListSignal<String> items = new ListSignal<>();
ValueSignal<String> entry = items.insertLast("Original");

// Update the entry value
entry.value("Updated");

// The list still has one entry, but its value changed
----

This per-entry reactivity is efficient: only components bound to the changed entry update, not all components bound to the list.


=== ListSignal Example

Here's an example of dynamic phone number fields where users can add and remove entries:

[source,java]
----
public class PhoneNumbersEditor extends VerticalLayout {
    private final ListSignal<String> phoneNumbers = new ListSignal<>();

    public PhoneNumbersEditor() {
        VerticalLayout phoneList = new VerticalLayout();
        phoneList.setPadding(false);
        phoneList.setSpacing(false);

        ComponentEffect.bindChildren(phoneList, phoneNumbers, phoneSignal -> {
            HorizontalLayout row = new HorizontalLayout();
            row.setAlignItems(FlexComponent.Alignment.CENTER);

            TextField phoneField = new TextField();
            phoneField.setPlaceholder("Phone number");
            phoneField.bindValue(phoneSignal);

            Button removeButton = new Button(VaadinIcon.MINUS.create());
            removeButton.addClickListener(e -> phoneNumbers.remove(phoneSignal));

            row.add(phoneField, removeButton);
            return row;
        });

        Button addButton = new Button("Add phone number", e -> phoneNumbers.insertLast(""));
        add(phoneList, addButton);
    }
}
----


=== When to Use ListSignal vs SharedListSignal

Use [classname]`ListSignal` when:

- The list is only relevant to a single user's UI session
- You don't need to synchronize the list across users or browser tabs
- Examples: dynamic form fields, local shopping cart UI, tabs/panels, temporary selections

Use [classname]`SharedListSignal` when:

- Multiple users need to see the same list in real-time
- You need transactional guarantees for list operations
- Examples: collaborative todo lists, shared document comments, live dashboards


== Replacing Values

The `replace()` method performs a compare-and-set operation:

[source,java]
----
ValueSignal<String> status = new ValueSignal<>("pending");

// Only replaces if current value matches expected
boolean replaced = status.replace("pending", "complete");
----


== Working with Mutable Values

For mutable values, use the `modify(Consumer)` method to perform updates. This method ensures the signal properly tracks changes:

[source,java]
----
public class User {
    private String name;
    private int age;

    // getters and setters...
}

ValueSignal<User> userSignal = new ValueSignal<>(new User("Jane", 25));

// Correct: Use modify() for mutable objects
userSignal.modify(user -> user.setAge(26));

// Incorrect: Direct mutation won't trigger reactivity
User user = userSignal.value();
user.setAge(27); // This change won't be detected!
----

[WARNING]
Direct mutation of objects retrieved from a signal won't trigger reactive updates. Always use `modify()` for mutable values, or preferably use immutable types like Java records.


== Thread Safety

Local signals are thread-safe and can be updated from any thread without wrapping calls in `ui.access()`. The signal handles UI synchronization internally:

[source,java]
----
public class MyView extends VerticalLayout {
    private final ValueSignal<String> localState = new ValueSignal<>("");

    public MyView() {
        TextField field = new TextField();
        field.bindValue(localState);

        Span output = new Span();
        output.bindText(localState);
        add(field, output);
    }
}
----

[NOTE]
When updating signals from background threads, ensure your application has the `@Push` annotation enabled. This allows the server to push UI updates to the client when signal values change asynchronously.

However, local signals are scoped to a single server instance. Vaadin doesn't yet provide an integrated solution for sharing local signals within a cluster. If you need state that works across a cluster or is shared between users, use <<shared-signals#,Shared Signals>> instead.


== Transaction Limitations

Local signals ([classname]`ValueSignal` and [classname]`ListSignal`) cannot participate in signal transactions:

[source,java]
----
ValueSignal<String> localValue = new ValueSignal<>("value");
ListSignal<String> localList = new ListSignal<>();

// This will throw an exception
Signal.runInTransaction(() -> {
    localValue.value("new value"); // Not allowed!
    localList.insertLast("item");  // Not allowed!
});
----

Use shared signals if you need transactional guarantees. See <<transactions#,Transactions>> for more information about signal transactions.


== Peeking Values

Use `peek()` to read a value without registering a dependency in effects or computed signals:

[source,java]
----
ValueSignal<String> signal = new ValueSignal<>("Hello");

ComponentEffect.effect(component, () -> {
    // peek() doesn't register a dependency
    String peeked = signal.peek();
    // This effect won't re-run when signal changes
});
----


== Transforming Signal Values

Use the `map()` method to create a computed signal that transforms the original value:

[source,java]
----
ValueSignal<String> name = new ValueSignal<>("john");
Signal<String> upperName = name.map(String::toUpperCase);

// upperName.value() returns "JOHN"
// When name changes, upperName automatically updates
----

Use `map()` for single-signal transformations. For transformations depending on multiple signals, use `Signal.computed()` instead.


[[two-way-mapping]]
== Two-Way Signal Mapping

The read-only [methodname]`map()` method described above creates a derived signal that updates when the source changes, but changes to the derived signal don't propagate back. For two-way binding scenarios where you need changes to flow in both directions, use the two-way mapping variants.

This is particularly useful when binding a form field to a property of a complex object stored in a signal. For example, binding a checkbox directly to the `done` property of a `Todo` record.


=== Mapping Immutable Values (Records)

For immutable values like Java records, use [methodname]`map(getter, merger)`:

[source,java]
----
record Todo(String text, boolean done) {
    Todo withDone(boolean done) {
        return new Todo(this.text, done);
    }
}

ValueSignal<Todo> todoSignal = new ValueSignal<>(new Todo("Write docs", false));

// Create a two-way mapping to the 'done' property
WritableSignal<Boolean> doneSignal = todoSignal.map(Todo::done, Todo::withDone);

// Bind checkbox directly to the property
Checkbox checkbox = new Checkbox();
checkbox.bindValue(doneSignal);
// Checking the box updates the todo's done property
// Calling todoSignal.update(...) updates the checkbox
----

The `merger` function receives the current parent value and the new child value, and returns a new parent value with the child property updated. Using wither methods like `withDone()` is a common pattern for records.


=== Mapping Mutable Values (Beans)

For mutable beans with setters, use [methodname]`mapMutable(getter, modifier)`:

[source,java]
----
public class User {
    private String name;
    private int age;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}

ValueSignal<User> userSignal = new ValueSignal<>(new User());

// Create a two-way mapping to the 'name' property
WritableSignal<String> nameSignal = userSignal.mapMutable(User::getName, User::setName);

// Bind text field directly to the property
TextField nameField = new TextField("Name");
nameField.bindValue(nameSignal);
----

The `modifier` function receives the parent object and the new value, and mutates the parent in place. The signal framework handles change notification automatically.

[NOTE]
====
Prefer immutable records over mutable beans when possible. Records are easier to reason about, naturally thread-safe, and work better with reactive patterns. Use `mapMutable()` only when working with existing mutable bean classes.
====


=== Comparison: Read-Only vs Two-Way Mapping

[cols="1,1,1"]
|===
| Method | Use Case | Return Type

| `map(getter)`
| Read-only transformations
| `Signal<T>` (read-only)

| `map(getter, merger)`
| Two-way binding with immutable values
| `WritableSignal<T>`

| `mapMutable(getter, modifier)`
| Two-way binding with mutable beans
| `WritableSignal<T>`
|===


== Organizing Signals as Fields

Storing signals as class fields is recommended for better code organization. It keeps all reactive state together at the top of the class, making it easier to understand the component's state at a glance:

[source,java]
----
public class MyView extends VerticalLayout {
    // State is clearly visible at the top of the class
    private final ValueSignal<String> nameSignal = new ValueSignal<>("");
    private final Signal<String> greeting = nameSignal.map(n -> "Hello, " + n);

    public MyView() {
        // Components can be local variables since they're added to the layout
        Span greetingSpan = new Span();
        greetingSpan.bindText(greeting);
        add(greetingSpan);
    }
}
----

This pattern also allows computed signals to be defined declaratively alongside their source signals, making the reactive dependencies clear.


== Use Cases

Local signals are ideal for:

*ValueSignal use cases:*

- *UI toggle states*: Panel expansion, modal visibility, sidebar open/closed
- *Form state*: Current step in a wizard, validation state
- *Local filters*: Search text, sort order within a single view
- *Temporary state*: Editing mode, selection state

[source,java]
----
public class ExpandablePanel extends VerticalLayout {
    private final ValueSignal<Boolean> expanded = new ValueSignal<>(false);

    public ExpandablePanel(String title, Component content) {
        Button header = new Button(title);
        header.addClickListener(e -> expanded.update(v -> !v));

        // Reactively show/hide content
        content.bindVisible(expanded);

        add(header, content);
    }
}
----

*ListSignal use cases:*

- *Dynamic form fields*: Add/remove phone numbers, addresses, or other repeating fields
- *Local shopping cart*: Managing cart items in a single-user session
- *UI tabs or panels*: Dynamic tabs that users can open and close
- *Temporary selections*: Multi-select items before batch operations
