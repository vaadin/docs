---
title: In-Project Component
page-title: How to create in-project web components with Vaadin
description: How to create an UI component specific to an application.
meta-description: Learn how to build and integrate custom web components in your Vaadin projects.
order: 20
---


= Creating an In-Project Web Component

In the majority of circumstances, the best way to integrate a public Web Component into Vaadin is to follow the steps in <<index#,Integrating a Web component>>.

As an alternative, if you want to create a UI component that's specific to your application, you can integrate and develop the component within your application project.

This section demonstrates how to do this using the https://start.vaadin.com.

== Creating the Component Template

The first step is to create a TypeScript Lit template in [filename]`frontend/my-test-element/my-test-element.ts`.

*Example*: Defining the `my-test-element` TypeScript template.

[source,typescript]
----
import { html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';

@customElement('my-test-element')
class MyTestElement extends LitElement {

  @property({ type: String })
  accessor name: string = '';

  render() {
    return html`
      <h2>Hello ${this.name}</h2>
    `;
  }
}
----

The `@customElement` decorator registers the class as a custom element, replacing the manual `customElements.define()` call. The `@property` decorator declares `name` as a reactive property with a type hint, so Lit automatically handles attribute-to-property conversion and triggers re-renders when the value changes.

.JavaScript works, too
[NOTE]
You can also use plain JavaScript (`.js`) files if you prefer. TypeScript is recommended for larger components because it provides type checking and better IDE support, but both work identically with `@JsModule`.

== Creating the Component Java API

This works in exactly the same way as described in <<java-api-for-a-web-component#,Creating Java API for a Web Component>>, except that the static files are loaded from your project.
You can modify them while creating the Java API.

*Example*: Defining the matching template class.

[source,java]
----
@Tag("my-test-element")
@JsModule("my-test-element/my-test-element.ts")
public class MyTest extends Component {

    public MyTest(String msg) {
        getElement().setProperty("name", msg);
    }
}
----

Note the `@JsModule` annotation points to a `.ts` file. Vaadin's build tooling handles TypeScript compilation automatically.

== Using the Web Component

You can now use the component in other parts of your code.

*Example*: Using the component in the [classname]`MainView` class.
[source,java]
----
public class MainView extends VerticalLayout {
    public MainView() {
        add(new MyTest("World"));
    }
}
----


[[using-npm-packages]]
== Using npm Packages in Your Component

When your Web Component needs a third-party npm package, declare the dependency with `@NpmPackage` on the Java class and import the package in your TypeScript file.

For example, to use a date formatting library in your component:

*Step 1*: Import and use the package in TypeScript.

[source,typescript]
----
import { html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { format } from 'date-fns';

@customElement('formatted-date')
class FormattedDate extends LitElement {

  @property({ type: String })
  accessor date: string = '';

  @property({ type: String })
  accessor pattern: string = 'PP';

  render() {
    const formatted = this.date
      ? format(new Date(this.date), this.pattern)
      : '';
    return html`<span>${formatted}</span>`;
  }
}
----

*Step 2*: Declare the npm dependency and module in the Java class.

[source,java]
----
@Tag("formatted-date")
@NpmPackage(value = "date-fns", version = "4.1.0")
@JsModule("./formatted-date.ts")
public class FormattedDate extends Component {

    public FormattedDate() {
    }

    public void setDate(String isoDate) {
        getElement().setProperty("date", isoDate);
    }

    public void setPattern(String pattern) {
        getElement().setProperty("pattern", pattern);
    }
}
----

The `@NpmPackage` annotation ensures `date-fns` is installed when the application builds. The TypeScript file can then import from it like any other module.

For more complex integration scenarios, including wrapping full-featured npm libraries and advanced Lit patterns, see <<advanced-integration#,Advanced Web Component Integration>>.


[discussion-id]`F3B26182-6375-44E5-8B83-09BE00801C2A`
