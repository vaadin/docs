---
title: Use Vaadin with OSGi
order: 1
layout: page
---

[[osgi.basic]]
= Use Vaadin with OSGi

Vaadin applications can be deployed on an OSGi compatible servlet container.

An OSGi application typically consists of multiple bundles that can be deployed separately. 

To deploy Vaadin applications as OSGi bundles, static resources must be published using the appropriate APIs.

The application is typically packaged as a JAR file, and needs to have a valid OSGi bundle manifest which can be created e.g. by the `bnd-maven-plugin` or Apache Felix `maven-bundle-plugin`. All the dependencies of the application should be available as OSGi bundles.

== Minimal Vaadin Project For OSGi
Vaadin application for OSGi should be a valid bundle, i.e. it should be packaged as a `.jar` file, and it should have a proper OSGi manifest inside.
The easiest way to convert regular maven-based Vaadin application into a valid OSGi bundle consists of five steps:

* Change packaging type to `jar` in your `pom.xml`:
[source, xml]
----
    <packaging>jar</packaging>
----
* Change the scope for all vaadin dependencies from default to `provided`, like this:

[source, xml]
----
    <dependency>
        <groupId>com.vaadin</groupId>
        <artifactId>vaadin-core</artifactId>
        <scope>provided</scope>
    </dependency>
----
* Add OSGi-related dependencies to the project

[source, xml]
----
    <groupId>com.vaadin</groupId>
        <artifactId>flow-osgi</artifactId>
        <version>${flow.version}</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.osgi</groupId>
        <artifactId>osgi.core</artifactId>
        <version>6.0.0</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.osgi</groupId>
        <artifactId>osgi.cmpn</artifactId>
        <version>7.0.0</version>
        <scope>provided</scope>
    </dependency>
----
* Setup necessary plugins for building the project:

[source, xml]
----
 <build>
    <plugins>
        <plugin>
            <groupId>biz.aQute.bnd</groupId>
            <artifactId>bnd-maven-plugin</artifactId>
            <version>3.3.0</version>
            <executions>
                <execution>
                    <goals>
                        <goal>bnd-process</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <version>3.0.2</version>
            <configuration>
                <archive>
                    <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
                </archive>
            </configuration>
        </plugin>
        ...
    </plugins>
</build>
----
* Add bundle script (`bnd.bnd`) into the project root folder:

[source, text]
----
Bundle-Name: ${project.name}
Bundle-Version: ${project.version}
Bundle-SymbolicName: ${project.groupId}.${project.artifactId}
Export-Package: com.example.osgi.myapplication
Import-Package: *
Vaadin-OSGi-Extender: true
----

[NOTE]
The last line in the manifest tells Vaadin OSGi integration to scan all classes
in the bundle and discover routes.

Make sure that the project is built for production 
(see <<../../guide/production/tutorial-production-mode-basic.asciidoci#,Preparing 
your application for Production>>) which means that frontend resources are compiled into a bundle 
(using `build-frontend` Vaadin maven plugin goal) and packaged together with Java code into the resulting project JAR.

[NOTE]
At the moment Vaadin web applicaiton may be used only with bundles frontend resources. There is no support for web pack dev server development mode.

[[osgi.servlet]]
== Publishing a Servlet With OSGi

It's a developer responsibility to register a `VaadinServlet` in the servlet container (inside OSGi container).
There are many ways to do it. One way is to use HTTP Whiteboard specification.

[source,java]
----
@Component(service = Servlet.class, , property = 
  HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_INIT_PARAM_PREFIX +
  InitParameters.SERVLET_PARAMETER_COMPATIBILITY_MODE + "=false")
@HttpWhiteboardServletAsyncSupported
@HttpWhiteboardServletPattern("/*")
public class FixedVaadinServlet extends VaadinServlet {

     @Override
     public void init(ServletConfig servletConfig) throws ServletException {
         super.init(servletConfig);

         getService().setClassLoader(getClass().getClassLoader());
     }

} 
----

[NOTE]
`FixedVaadinServlet` class is used here as a workaround for the 
https://github.com/vaadin/flow/issues/4367[Classloader bug]. Once it's fixed there will be no need in it.

[NOTE]
When you have more than one bundle created by Vaadin, note that you should not
have multiple `VadinServlet` registrations with the same servlet pattern. So,
you should either use a unique pattern for each bundle or create `VaadinServlet`
in only one bundle. In the latter case, keep in mind that for the other bundles
to work, it is required that the bundle containing the servlet is active.

[[osgi.vaadin.extender]]
== Classes discovering

Vaadin discovers a number of classes to delegate them some functionality.
E.g. classes annotated with `@Route` annotation are used in the routing 
functionality (see <<../routing/tutorial-routing-annotation#,Defining Routes with @Route>>).
There are many other cases which requires classes discovering functionality (see also
<<../routing/tutorial-routing-exception-handling#,Router Exception Handling>>,
<<../pwa/tutorial-pwa-pwa-with-flow#,Creating PWA with Flow>>).
It doesn't happen out of the box in OSGi container for every bundle.
To avoid scanning all classes in all bundles Vaadin uses `Vaadin-OSGi-Extender` 
manifest header as a marker for those bundles that needs to be scanned.
So if you have a bundle which contains routes or other classes whose 
functionality relies on inheritance or annotation presence you should mark 
this bundle using `Vaadin-OSGi-Extender` manifest header (so normally every Vaadin
application bundle should have this manifest header otherwise routes declared in this
bundle won't be discovered):

[source, text]
----
....
Export-Package: com.example.osgi.myapplication
Import-Package: *
Vaadin-OSGi-Extender: true
....
----

[[osgi.deploy]]
== Deployment to OSGi container.

In order to have your application running under OSGi container, you need to have 
Vaadin Flow bundles deployed, and then the application bundle can be deployed and started.
Please note that there are many transitive dependencies which are also need to be deployed.
Bundle won't be activated if all its dependencies are not deployed and activated
(it might be that some OSGi containers may deploy transitive dependencies 
along with the bundle deployment).
Here is a minimal list of required Vaadin Flow bundles:

* `flow-server-X.Y.Z.jar`
* `flow-client-X.Y.Z.jar`
* `flow-html-components-X.Y.Z.jar`
* `flow-data-X.Y.Z.jar`
* `flow-osgi-X.Y.Z.jar`

This is not a full list of all required bundles. The full list is too long
and may vary due to transitive dependencies.
Here are some of the required external dependencies (the versions are omitted):

* `jsoup`
* `gentyref-x.y.z.vaadin1.jar`
* `gwt-elemental-x.y.z.vaadin2.jar`
* `ph-css`
* ....

Please note that some of the dependencies are repackaged by Vaadin because
original jars are not OSGi compatible (like `gwt-elemental`).
Other dependencies require some OSGi features which needs to be deployed at 
runtime but they don't depend on them during compilation.
This is the case with `ph-css` bundle. It depends on `ph-commons` (which 
should be deployed also of course) but the latter bundle requires `ServiceLoader` 
OSGi implementation. You will need to deploy the bundle which contains
this implementation suitable for your OSGi container.
Also Vaadin OSGi support uses OSGi Compendium API (which allows registering an OSGi
service using declarative services annotations). If your OSGI container doesn't have it 
out of the box, you have to deploy an implementation bundle to support the Compendium API.

In your project you will most likely want to use some ready-made Vaadin components like Vaadin Button.
In this case you should deploy `vaadin-button-flow` bundle as a dependency.

[[osgi.base.starter]]
== OSGi base starter project

There is an OSGi base starter project available https://github.com/vaadin/base-starter-flow-osgi.
This project consists of two modules: `starter` and `app`.

The `starter` project is a Vaadin web applicaion bundle project which is pacakged as a JAR and 
may be deployed to any OSGi container.

The `app` project contains configuration which allows quickly run the `starter` project in an OSGi container.
Please refer to the https://github.com/vaadin/base-starter-flow-osgi/blob/feature/osgi-bnd/README.md[README.md] file in the project for details.

[[osgi.vaadin.components]]
== Vaadin components version update

Vaadin application generally contains dependencies to other bundles: e.g. Vaadin components like `Button`,
`TextField` , etc. Every Vaadin component is based on a Web Component which
is represented by frontend resources. All frontend resources are built into a bundle
along with Vaadin WAB. As a result:
* any Vaadin component bundle update is possible only within the same minor version, 
 so that the Web Component version stays the same (and only Java code is updated). We don't recommend 
 updating any version over a minor for Flow or the web component Flow integrations (even though it's
 not prevented anyhow at the moment).
* Updating any bundle that has frontend resources requires that the frontend build goal `build-frontend` 
 is run and the WAB is redeployed to get the static frontend bundle updated.

[[osgi.vaadin.limitations]]
== Limitations

Here is a list of things which are not currently supported:

* NPM dev mode: it's only possible to run Vaadin web application in production mode (with frontend resources bundled into the JAR)
* it's not possible to use OSGi declarative services with Vaadin components: 
you may not inject a service declaratively in Vaadin classes (using annotations) 
just because UI objects are not managed by OSGi. But you still may call OSGi services programmatically of course.
* as mentioned above: there is no yet automatic servlet registration. So the web application 
bundle should register the servlet itself.
* there is no documentation and it's not clear how to make Push working with WebSockets: the main question 
here is enabling WS on pure OSGi container. It works on hybrid OSGi container which allows
to deploy WARs (like Karaf) but this is exactly the same as for plain web server. It's not clear what
needs to be done to enable WS for a pure OSGi container.
* Fusion/TS views can't be used in OSGi.

