---
title: Best Practices
order: 40
layout: page
---

= Security Best Practices

// tag::authentication-authorization[]
== Authentication and Authorization

Vaadin lets you choose which authentication and authorization framework you want to use, instead of bundling any specific one.
Vaadin is fully compatible with the most used security solutions in the Java ecosystem, including but not limited to Spring Security, JAAS and Apache Shiro.
The Vaadin-Spring addon has helpers for developers to integrate into the security mechanisms of those respective frameworks.

Since Vaadin is a server-side framework, credential processing always happens on the server, away from any possible attack surface.
Credentials are never transmitted to the client unless explicitly done so by the developer.

Generally, it is recommended that the developer double-checks user identity and access rights for each call from the client.
This can be automated with, for example, Spring Security and view-based authentication using roles.
What typically can't be automated by these frameworks is data-based access rights, such as limiting access to specific entities.

As an example, if the server receives an ID of a User object to be displayed in, for example, a URL request parameter (`{yourapp.com}/users/4/edit`), then the ID in question can be freely changed by an attacker.
The application needs to be aware of this and check if the currently logged-in user has access rights to this entity.
This is something that is common for all UI frameworks, and not specific to Vaadin.

// end::authentication-authorization[]
// tag::spring-security-integration-ref[]
Examples for integrating Spring Security can be found in
// end::spring-security-integration-ref[]
https://vaadin.com/tutorials/securing-your-app-with-spring-security[Securing your app with Spring Security].

== View-Based Access Control

[role="since:com.vaadin:vaadin@V21 standalone"]
--
--

Since Vaadin 21, it is possible to use built-in view-based access control mechanism to secure Flow navigation targets, but as mentioned in <<Authentication and Authorization,Authentication and Authorization>> it is not mandatory to use it, so it is not enabled by default.
The view-based access control mechanism uses the `@AnonymousAllowed`, `@PermitAll`, `@RolesAllowed`, and `@DenyAll` annotations on view classes to define the access control rules.

.There is a detailed document for Flow applications based on Spring Boot
[NOTE]
If your Vaadin Flow application is based on Spring Boot, it is strongly recommended following the dedicated documentation for using <<{articles}/flow/integrations/spring/view-based-access-control#, View-Based Access Control in Vaadin Flow Spring Boot applications>>.

To enable and use this mechanism, the following should be added to a Vaadin Flow application (if not exist already):

- A Login view.
- A `VaadinServiceInitListener` that adds `ViewAccessChecker` as the `BeforeEnterListener` of all UIs.
- A Service Provider under `META-INF/services` to load above custom ServiceInitListener via Java SPI loading mechanism.

=== Adding Login View
Having a login view is one of the basic requirements of many authentication and authorization mechanisms to be able to redirect the anonymous users to that page before giving the access of viewing any protected resources.

.`LoginView.java`
[source,java]
----
@Route("login")
@PageTitle("Login")
public class LoginView extends VerticalLayout implements BeforeEnterObserver {

    private LoginForm login = new LoginForm();

    public LoginView() {
        addClassName("login-view");
        setSizeFull();

        setJustifyContentMode(JustifyContentMode.CENTER);
        setAlignItems(Alignment.CENTER);

        login.setAction("login");

        add(new H1("Test Application"), login);
    }

    @Override
    public void beforeEnter(BeforeEnterEvent beforeEnterEvent) {
        if(beforeEnterEvent.getLocation()
            .getQueryParameters()
            .getParameters()
            .containsKey("error")) {
            login.setError(true);
        }
    }
}
----

.Usage of Vaadin's LoginForm Component
[NOTE]
In this example, Vaadin's `LoginForm` component is used to make the implementation more brief, but there is no obligation to do so, feel free to implement your own Login view, as you wish.

=== Adding VaadinServiceInitListener
To be able to restrict the access to the views, a `BeforeEnterListener` must be registered for the `VaadinService` which initialize and enable the `ViewAccessChecker`:

.ViewAccessCheckerInitializer.java
[source,java]
----
import com.vaadin.flow.server.ServiceInitEvent;
import com.vaadin.flow.server.VaadinServiceInitListener;
import com.vaadin.flow.server.auth.ViewAccessChecker;
import org.vaadin.example.views.login.LoginView;

public class ViewAccessCheckerInitializer implements VaadinServiceInitListener {

    private ViewAccessChecker viewAccessChecker;

    public ViewAccessCheckerInitializer() {
        viewAccessChecker = new ViewAccessChecker(); // <1>
        viewAccessChecker.setEnabled(true); // <2>
        viewAccessChecker.setLoginView(LoginView.class); // <3>
    }

    @Override
    public void serviceInit(ServiceInitEvent serviceInitEvent) {
        serviceInitEvent.getSource().addUIInitListener(uiInitEvent -> {
            uiInitEvent.getUI().addBeforeEnterListener(viewAccessChecker); // <4>
        });
    }
}
----

The above code contains some notable pieces of the View-Base Access Control mechanism:

<1> `ViewAccessChecker` which is the at core of this access control mechanism, is instantiated.
<2> `ViewAccessChecker` is enabled. Note that it is not enabled by default.
<3> `LoginView` class is set to the `viewAccessChecker` instance, now it knows where to redirect unauthenticated users.
<4> `viewAccessChecker` instance is set as the `BeforeEnterListener` in the overridden `serviceInit` method.
Now it is ready to intercept the attempts for entering to all views.

However, the above class still needs to be loaded, so it is recommended to follow the instructions of the next step.

=== Enable Loading of VaadinServiceInitListener
To enable Java SPI loading mechanism to load the above `ViewAccessCheckerInitializer` as the `VaadinServiceInitListener`, it is needed to do the following:

- Under `resources/META-INF/services` directory, create a file named exactly as:

[text,text]
----
com.vaadin.flow.server.VaadinServiceInitListener
----

- Put the fully qualified name of `ViewAccessCheckerInitializer` into this newly created file.
For example, if `ViewAccessCheckerInitializer` class is in `org.vaadin.example.security` package, the following value should be in the file:

.Text value that should be the `com.vaadin.flow.server.VaadinServiceInitListener` file:
[text,text]
----
org.vaadin.example.security.ViewAccessCheckerInitializer
----

This Service Provider config file would trigger Java SPI loading mechanism to load `ViewAccessCheckerInitializer` during the application startup.
More information on this can be found <<{articles}/flow/advanced/service-init-listener#,here>>.

=== Access Annotations
Before providing a usage examples of the access annotations, it would be beneficial to have a closer look at the annotations, and their meaning when applied on a view:

- `@AnonymousAllowed` Permits anyone to navigate to the view without any authentication or authorization.
- `@PermitAll` Allows any *authenticated* user to navigate to the view.
- `@RolesAllowed` Grants access to users having the roles specified in the annotation value.
- `@DenyAll` Disallows to navigate to the view for everyone.
This is the default, which means if a view is not annotated at all, the `@DenyAll` logic would be applied.

Some usage examples:

.Example of using @AnonymousAllowed to enable all users navigating to this view
[source,java]
----
@Route(value = "", layout = MainView.class)
@PageTitle("Public View")
@AnonymousAllowed
public class PublicView extends VerticalLayout {
    // ...
}
----

.Example of using @PermitAll to allow only authenticated users (with any role) navigating to this view
[source,java]
----
@Route(value = "private", layout = MainView.class)
@PageTitle("Private View")
@PermitAll
public class PrivateView extends VerticalLayout {
    // ...
}
----

.Example of using @RolesAllowed to enable only the users with `ADMIN` role navigating to this view
[source,java]
----
@Route(value = "admin", layout = MainView.class)
@PageTitle("Admin View")
@RolesAllowed("ADMIN") // <- Should match one of the user's roles (case-sensitive)
public class AdminView extends VerticalLayout {
    // ...
}
----

Now if the application is started, by navigating to `http://localhost:8080` `PublicView` contents should be available without any authentication.
However, by navigating to `http://localhost:8080/private` or `http://localhost:8080/admin` the user would be redirected to the specified `LoginView`.

// TODO: Consider adding more details and snippet codes to showcase how the followings can be achieved:
// 1. login with some users with different roles
// 2. save the requested URL to redirect to it after a successful login

If multiple annotations specified on a single view, the following rules are applied:

- `DenyAll` overrides other annotations
- `AnonymousAllowed` overrides `RolesAllowed` and `PermitAll`
- `RolesAllowed` overrides `PermitAll`

However, specifying more than one of the above access annotations on a view class in not recommended, as it is confusing and probably has no logical reason to do so.

== Application State

The server is always aware of your application state. Compared to client side applications, this means that the server is aware of what is currently visible on the end-user's screen. Hence Vaadin denies actions to components that are not currently visible on the screen, or components that have been disabled on the server.

For instance, if the developer sets a component to be disabled, this effect is set both on the server and the client. On the client, an attacker can circumvent this (attackers have full control over anything in the browser), but the server will block any attempt to interact with the component and a warning is printed to the server logs.

[source,java]
----
Button button = new Button("Click me for effect!");
button.setEnabled(false);
button.addClickListener(e -> {
    // If the Button is disabled, this listener will not run,
    // even if an attacker enables the button client side.
});
----
// tag::data-validation[]
== Data Validation

In a Vaadin application, the data binding API supports data validation on the server, which cannot be by-passed with client-side attacks. 
Vaadin components do support client-side validation to increase the responsiveness of the application, but the developer should be aware that these should be used purely for convenience, since they are easily circumvented in the browser.

As with other web applications, all data coming from the client should always be validated once it reaches the server. 
It is not safe to rely on only client-side validation. 
Vaadin provides a set of pre-created server side validators for this purpose. 
In addition, the developer is free to use any Java API for validating the data, including connecting to external services. 
Vaadin also has a built-in integration with Java's Bean Validation (JSR 303) standard.

Data coming from a data store (such as a database) and inserted as HTML into DOM elements (for example, setting innerHTML for elements or using HTML mode in component captions) should also be escaped. 
Please see the chapter for XSS for more information.

// end::data-validation[]
== Web Services

No public Web Services are necessary in Vaadin applications. 
All communication in Vaadin goes through a single HTTP request handler used for RPC requests using the standard Servlet Java API. 
With Vaadin, you never open up your business logic as web services and thus there are less attack entry points to your Vaadin application.

// tag::ssl-https[]
== SSL and HTTPS

Vaadin always recommend developers to set up secure server endpoints and run all communication exclusively under HTTPS. 
Vaadin works out-of-the-box with HTTPS, and there is nothing for the developer to configure in your application code. 
Please refer to the documentation of your servlet container for details on how to set up HTTPS on your server.
// end::ssl-https[]
