---
title: Content Security Policy
description: Instructions for enabling strict Content Security Policy
order: 400
---

= Content Security Policy

Content Security Policy (https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP[CSP]) is a browser standard that helps to mitigate certain types of attacks. Strict CSP rules allows the application to define rules for how JavaScript can be loaded and ran in the browser. This provides an additional layer of security against Cross-Site Scripting (XSS), data injection, data theft, site defacement and malware distribution.


== Vaadin and Strict CSP

As such, Vaadin Flow is not compatible with strict CSP rules. This is due to how the client-server communication has been built; for example dynamic JavaScript functions and `eval` calls are used. These are not compatible with strict CSP rules.

However, with some effort from the application developer, nonce-based strict CSP can be used with Vaadin Flow applications. Nonce is a random identifier which is generated by the server for each HTTP request, and it needs to be included in the response headers. Once this has been done, only script tags containing this nonce value are loaded by the browser. Additionally dynamic functions and calling `eval` are not allowed.

Strict CSP implemented this way is only available when the Vaadin application is running in production mode.


== Creating Random Nonce

To create the random nonce value, the application needs to have an [interfacename]`IndexHtmlRequestListener` which must generate and add the nonce to the index file response and all script tags, for example like this:

[source,java]
----
String nonce = UUID.randomUUID().toString();

// Add a header to make the browser require the nonce in all script tags
response.getVaadinResponse().setHeader("Content-Security-Policy",
        "script-src 'nonce-" + nonce + "'");

// Add the nonce to all script tags in the host page
response.getDocument().getElementsByTag("script").attr("nonce", nonce);
----


== Handling function execution and eval calls

The example in the above section of course only adds the nonce to the application, it does not help with handling all the dynamic functions, eval calls and chunk loading. Therefore, an application that needs to use strict CSP must provide a JavaScript file for handling these issues in a CSP-compliant way.

In short, the Function constructor and `eval` must be overridden, and the application developer needs to provide equivalent pre-defined JavaScript functions for any calls made by the application. A snippet of this is shown below as an example.

[source,javascript]
----
// Override the Function constructor with a version that uses inlined code if available
const originalFunction = window.Function;
window.Function = function(...args) {
  const key = args.join(",");

  if (functions.has(key)) {
    return functions.get(key);
  }

  if (key.startsWith("return window.Vaadin.Flow.loadOnDemand(")) {
    const chunk = key.split("return window.Vaadin.Flow.loadOnDemand('").pop().split("');").pop();
    return function (chunk) {return window.Vaadin.Flow.loadOnDemand(chunk);};
  }

  // In "training" mode, log expression to add to the map
  const code = args[args.length - 1];
  // Ignore the stats gatherer which isn't used in production mode
  if (code.indexOf("var StatisticsGatherer") == -1) {
    const snippet = `functions.set("${key}",\n  function(${args.slice(0, -1).join(',')}) {${code}});`
    console.warn(snippet);
  }

  // Fall back to the original constructor (seem to be fine not use it as a constructor)
  return originalFunction.apply(null, args)
}

// Override eval(..) with a version that uses inlined code if available
const originalEval = window.eval;
window.eval = function(script) {
  const originalArg = script;
  // Removes parenthesis used by Vaadin Charts
  if (script.length > 1 && script.substring(0, 1) === "(" && script.substring(script.length - 1) === ")") {
    script = script.substring(1, script.length - 1);
  }
  if (evalCalls.has(script)) {
    return evalCalls.get(script);
  } else {
    let snippet = "";
    if (script.startsWith("function")) {
      snippet = `evalCalls.set("${script}",\n  ${script});`
    } else {
      snippet = `evalCalls.set("${script}",\n  function() {return ${script}});`
    }
    console.warn(snippet);

    // Fall back to original eval function
    originalEval.apply(null, originalArg);
  }
}
----

In the example above, `functions` and `evalCalls` are maps which provide mapping from string to a predefined function. The next snippet shows a couple of examples only whereas a real application would have a lot more of these mappings.

[source,javascript]
----
const evalCalls = new Map();
evalCalls.set("'The value for <b>' + this.x + '</b> is <b>' + this.y + '</b>'",
    function() {return 'The value for <b>' + this.x + '</b> is <b>' + this.y + '</b>'});

const functions = new Map();
functions.set("$0,$1,return $0.$connector.confirm($1)",
    function($0,$1) {return $0.$connector.confirm($1)});

----

An example application using strict CSP is available https://github.com/vaadin/flow-crm-tutorial/tree/24.5-strict-csp[here]. Files containing the required changes are https://github.com/vaadin/flow-crm-tutorial/blob/24.5-strict-csp/src/main/java/com/example/application/Application.java[`Application.java`] and https://github.com/vaadin/flow-crm-tutorial/blob/24.5-strict-csp/src/main/frontend/csp.js[`csp.js`].

[discussion-id]`B5E8EEC6-0F7E-49C5-8121-0906827BE4A5`