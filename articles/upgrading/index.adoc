---
title: Upgrading Guide
page-title: How to upgrade Vaadin applications
description: Changes needed to upgrade an application from Vaadin 24 to the latest version.
meta-description: Follow this comprehensive guide to upgrade your Vaadin applications to the latest version.
order: 900
---


= Upgrading from Vaadin 24

This guide goes through the changes you'll need to make in your applications when upgrading from Vaadin 24 to the latest version. After making them, your application should compile, run, behave, and look the way it did before you upgraded.

.Upgrading from Earlier Version
[TIP]
See link:/docs/latest/upgrading[Vaadin 23 to 24 Upgrade Instructions] if you're upgrading from a version earlier than Vaadin 24.

Many of the breaking changes are needed because of fundamental changes in the Java platform and the major dependencies on which Vaadin relies. This includes the following:

// Allow LTS
pass:[<!-- vale Vaadin.Abbr = NO -->]

Java 21::
Vaadin 25 requires Java 21 or later. Java 21 is the Long Term Support (LTS) version of Java. Upgrading to Java 21 might require you to upgrade other dependencies in your application.

pass:[<!-- vale Vaadin.Abbr = YES -->]

Spring Boot 4::
Vaadin 25 uses the latest Spring Boot 4 and Spring Framework 7 versions. This leads to making breaking changes in Spring-based features, compared to earlier Spring Boot 3.5 and Spring Framework 6 versions. Details can be found in link:https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-4.0-Migration-Guide[Spring Boot 4 Migration Guide].

Servlet 6.1::
Vaadin 25 is based on link:https://jakarta.ee/specifications/servlet/6.1/[Servlet 6.1] specification, which is compatible with link:https://jakarta.ee/specifications/platform/11/[Jakarta EE 11]. When upgrading from Vaadin 24 (Servlet 6 and Jakarta EE10), changes are typically not needed.

Gradle 8/9::
Gradle 8 (8.14 and later) and Gradle 9 releases are supported.

Jackson 3::
Elemental has been replaced with Jackson while Jackson version has been updated to 3. This only affects you if your application uses some of the affected low-level APIs. Details can be found in link:https://github.com/vaadin/flow/issues/21060[Finalize Jackson conversion] and its sub-issues.

Node.js 24::
Vaadin 25 requires Node.js 24 or later for building the frontend part of the application. Node.js 24 becomes the active Long Term Support (LTS) before Vaadin 25.0.0 - guaranteeing the longest possible support.

React 19::
Vaadin 25 uses React 19 for the React-based components and views. Details about the changes in React 19 can be found in link:https://react.dev/blog/2024/04/25/react-19-upgrade-guide[React 19 Upgrade Guide].


== Overview

Vaadin 25 doesn't change fundamentally how applications are developed and behave. Nevertheless, the upgrade process requires the following essential tasks and tests:

Preparation::
Upgrade the Vaadin version in the project's [filename]`pom.xml` file, checking for the latest Vaadin 25 release link:https://github.com/vaadin/platform/releases[in GitHub].

Upgrade Java::
Upgrade your application to use Java 21 or later.

Upgrade Spring::
For Spring-based applications, upgrade to Spring Boot 4 or Spring Framework 7, depending on which is used in your project. For non-Spring applications, upgrade the application server version to one that's compatible with Jakarta EE 11.

Other Dependencies::
Upgrade third-party dependencies used in your project (e.g., Maven/Gradle plugins, libraries, frameworks) to compatible versions.

Verify & Test::
Ensure your application is not using deprecated code fragments.
+
Make sure your application runs well on Java 21 runtime.


== Preparation

Upgrade the Vaadin version in the [filename]`pom.xml` and [filename]`gradle.properties` files to the latest release like so:

include::{articles}/_vaadin-version.adoc[]

[.example]
--
[source,xml,subs="+attributes"]
----
<source-info group="pom.xml"></source-info>
<vaadin.version>{vaadin-version}</vaadin.version>
----
[source,properties,subs="+attributes"]
----
<source-info group="gradle.properties"></source-info>
vaadinVersion={vaadin-version}
----
--

See the link:https://github.com/vaadin/platform/releases[list of releases on GitHub] for the latest one.

== Java Version

Java 21 or later is required. Below is an example of how to use this version:

[.example]
--
[source,xml]
----
<source-info group="Maven"></source-info>
<properties>
    <java.version>21</java.version>
    <!-- OR: -->
    <maven.compiler.source>21</maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
</properties>
----
[source,kotlin]
----
<source-info group="Gradle (Kotlin DSL)"></source-info>
plugins {
    java
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
----
[source,groovy]
----
<source-info group="Gradle (Groovy DSL)"></source-info>
plugins {
    id 'java'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
----
--

== Spring Upgrade Instructions

To browse a full list of changes, see the link:https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-4.0.0-M3-Release-Notes[Spring Boot 4.0 Release Notes] and the https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes[What's New in Spring Framework 7.x] page.

The following sections provide a general overview of the changes needed for Spring-based Vaadin applications.

=== Upgrade Spring to Latest

You'll need to upgrade Spring to the latest versions, including the starter parent dependency:

.pom.xml
[source,xml]
----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>4.0.0</version>
</parent>
----

== Application Servers

Before migrating, find the corresponding version of the Jakarta EE 11-compatible application server used in your project. See link:https://jakarta.ee/compatibility/[Jakarta Compatible Products] for more information.

== Maven & Gradle Plugins

Ensure that the Maven plugins which are explicitly defined in your project, are compatible with Java 21.
A safe choice: Maven 3.9.11 (or the latest in the 3.9 line) or Maven 4.0.x (once stable) if you are comfortable with that.

To run Gradle on top of Java 21 and latest Spring Boot 4 versions, you'll need to use version 8.14 or later. See the link:https://docs.gradle.org/8.14/release-notes.html[Gradle release notes] for further details. If your project uses Spring Boot, upgrade the plugin `org.springframework.boot` to version 4.0.0.

If you're using a Gradle wrapper, update it to version 8.14 by executing the following from the command line:

[source,terminal]
----
./gradlew wrapper --gradle-version 8.14
----

For Java 21 compatibility, you may need to update the `sourceCompatibility` setting in your project's build file to version 21. Check your project's build file and make any necessary changes.

== Development Tools

Development tools are opt-in feature in Vaadin 25. `vaadin-dev` module isn't included transitively by default anymore via `vaadin` or `vaadin-core` or any other Vaadin dependencies. To include it, add following dependency to your build configuration:

[.example]
--
[source,xml]
----
<source-info group="Maven"></source-info>
<dependency>
    <groupId>com.vaadin</groupId>
    <artifactId>vaadin-dev</artifactId>
    <optional>true</optional>
</dependency>
----

[source,groovy]
----
<source-info group="Gradle"></source-info>
dependencies {
    implementation('com.vaadin:vaadin-dev')
}
----
--

More detailed instructions can be found in <<{articles}/flow/configuration/development-mode#development-mode, Development Mode>>.

== Hilla
Vaadin Spring Boot Starter no longer includes Hilla by default. In case you have react views, add `hilla-spring-boot-starter` to work together with `vaadin-spring-boot-starter` in your build configuration.

.pom.xml
[source,xml]
----
<dependency>
    <groupId>com.vaadin</groupId>
    <artifactId>vaadin-spring-boot-starter</artifactId>
</dependency>
<!-- optional if you want to add React views -->
<dependency>
    <groupId>com.vaadin</groupId>
    <artifactId>hilla-spring-boot-starter</artifactId>
</dependency>
----

== Quarkus

Vaadin Quarkus extension is changed to build production package by default. No need for production profile with exclusions for development tools in Maven configurations because Vaadin Quarkus extension has build-in Vaadin plugin handling production packaging.

To allow project to keep build configuration unchanged, Vaadin Quarkus extension has `vaadin.build.enabled` property to change the default behavior. Disable Vaadin plugin by adding `vaadin.build.enabled=false` in `application.properties` file to keep using profile based configuration.

== Themes and Styling

Vaadin 25 simplifies the theme/styling system to bring it closer to normal/native web development, and minimizes Vaadin-specific peculiarities, while keeping migration from earlier versions as painless as possible.

Below are the main highlights of the changes and more detailed instructions are described in link:https://github.com/vaadin/platform/issues/7453[Theming System Renewal].

The special `frontend/themes` folder, and the `components` sub-folder for CSS shadow-DOM injection, is deprecated (but still supported).

Injecting CSS into Vaadin components’ shadow DOM through the components sub-folder in your theme folder is disabled by default. Shadow DOM styling is no longer recommended (as of V24), but if you still need to use it, it can be enabled with the feature flag `themeComponentStyles`.

The [classname]`@Theme` annotation is deprecated. Instead, [classname]`StyleSheet` annotation to be used for loading one or more stylesheets from public static resources locations (e.g. `META-INF/resources/`), whereas [classname]`CssImport` loads one or more stylesheets from the `src/main/frontend/` folder and use mechanisms native to HTML, CSS, and React (e.g. `@import url("morestyles.css")` in CSS).

`StyleSheet` annotation is now a recommended way to load Vaadin theme for the application — to be placed on the application class implementing [classname]`AppShellConfigurator`. Below are some examples of how to use it:

[source,java]
----
// theme selection
@StyleSheet(Aura.STYLESHEET) // or Lumo.STYLESHEET
public class Application implements AppShellConfigurator {}

// or loading custom styles and theme:

@StyleSheet("styles.css")
public class Application implements AppShellConfigurator {}

// then using @import in the src/main/resources/META-INF/resources/styles.css:

@import 'aura/aura.css'; /* or 'lumo/lumo.css' */
// your custom styles go here ...

----

The [filename]`theme.json` configuration file is deprecated (but still supported, except the `lumoImports` property).

The `themeFor` parameter of the [classname]`@CssImport` annotation (for shadow-DOM injection) is deprecated (but still supported).

The special [filename]`document.css` file (for loading styles into the document root in embedded components) is removed as no longer necessary.

You can use [classname]`@ColorScheme` for choosing between light or dark color scheme. 
See <<{articles}/styling/themes#color-schemes, Color Schemes>> for more details on using color schemes.

=== Spring Security and StyleSheet

By default, Vaadin Spring Security denies access to URLs that are not explicitly allowed in the <<{articles}/upgrading#security-configuration-changes, security configuration>>. To allow access to custom resources such as `@import 'css/foo.css'`, you need to configure permission for the relevant path in your security settings:

[source,java]
----
@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(auth -> auth
                .requestMatchers("/css/foo.css").permitAll());
    http.with(VaadinSecurityConfigurer.vaadin(), vaadin -> {
        ...
    });
    return http.build();
}
----

Or use link:https://docs.spring.io/spring-boot/api/java/org/springframework/boot/security/autoconfigure/web/StaticResourceLocation.html[StaticResourceLocation] provided by Spring to allow common locations for static resources:

[source,java]
----
import org.springframework.boot.security.autoconfigure.web.servlet.PathRequest;
...

@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(auth -> {
        auth.requestMatchers(PathRequest.toStaticResources()
                .atCommonLocations()).permitAll();
    });
    ...
    return http.build();
}
----

=== Lumo Theme

The Lumo theme is no longer loaded by default, except if you’re using the [classname]`@Theme` annotation to load an application theme folder. If you’re not using [classname]`@Theme`, then add a [classname]`@StyleSheet` annotation to either your application class or a root layout to load the Lumo theme:

[source,java]
----
@StyleSheet(Lumo.STYLESHEET);
public class Application implements AppShellConfigurator {}
----

All Lumo styles, including badges, but excluding Lumo Utility Classes are included by default when the Lumo theme is loaded. To load the utility classes, add a separate [classname]`@StyleSheet` annotation:

[source,java]
----
@StyleSheet(Lumo.STYLESHEET);
@StyleSheet(Lumo.UTILITY_STYLESHEET);
public class Application implements AppShellConfigurator {}
----

NOTE: The way the Lumo theme is injected into Vaadin components has been refactored to not use the `registerStyles()` helper. This should not cause any breaking changes in applications; please report issues at link:https://github.com/vaadin/web-components/issues[vaadin/web-components] if you find otherwise.

=== Material Theme

The Material theme is no longer supported in Vaadin 25. You can migrate your application to the Lumo or Aura theme or implement your own Material Design theme on top of the new component base styles.

=== Component Base Styles

The un-themed base styles in Vaadin components have changed significantly in Vaadin 25. They are now much less bare-bones and actually provide a better starting point for custom themes. This does mean that custom themes built on top of the Vaadin 25 component base styles need to be heavily refactored. The components’ Styling pages provide lists of style properties (CSS custom properties) that make them easier to customize.

=== WebComponentExporter

The [classname]`WebComponentExporter` feature in Flow allows you to export Flow components as Web Components for embedding into non-Vaadin user interfaces. In Vaadin 25, stylesheets loaded into exported components using the [classname]`@CssImport` annotation only load those styles into the exported component’s shadow DOM, not the surrounding page as before. To load the same styles into the surrounding page, import the stylesheet to it separately.

=== React Components

The Lumo CSS files have been removed from the `@vaadin/react-components` package. As mentioned above, the Lumo theme should be imported from `@vaadin/vaadin-lumo-styles` instead.

[source,typescript,role="before"]
----
/* If imported through a CSS file */
@import '@vaadin/react-components/css/Lumo.css';

/* If imported through Typescript */
import '@vaadin/react-components/css/Lumo.css';
----
[source,typescript,role="after"]
----
/* If imported through a CSS file */
@import '@vaadin/vaadin-lumo-styles/lumo.css';

/* If imported through Typescript */
import '@vaadin/vaadin-lumo-styles/lumo.css';
----

One exception is the `@vaadin/react-components/css/lumo/Utility.module.css` CSS module, which has been preserved for backward compatibility as the Lumo package does not expose utilities as a CSS module.

=== Optional Changes

These changes are optional, as old approaches still work (with the exceptions listed in the Breaking Changes section), but recommended to get your application to the new best practices in Vaadin 25, and to avoid breaking changes in later major versions.

* Refactor component styles from shadow DOM styles to normal CSS (this was the recommended approach already in V24)
* Load custom styles through a master stylesheet with [classname]`@StyleSheet` instead of [classname]`@Theme` or multiple [classname]`@CssImport`-s
* Load additional custom stylesheets through master stylesheet with `@import`
* Move stylesheets from `frontend/themes/<mytheme>` to `src/main/resources/META-INF/resources`

== Components

=== App Layout
The `bottom` attribute was removed and can no longer be used to target the bottom navbar. Instead, use the selector `::part(navbar-bottom)` to target it with CSS.

The protected `afterNavigation()` method has been removed. Classes that extend `AppLayout` and override this method must implement the `AfterNavigationObserver` interface instead:

[source,java,role="before"]
----
public class MainLayout extends AppLayout {
    @Override
    protected void afterNavigation() {
        super.afterNavigation();
    }
}
----
[source,java,role="after"]
----
public class MainLayout extends AppLayout implements AfterNavigationObserver {
    @Override
    public void afterNavigation(AfterNavigationEvent event) {
        // ...
    }
}
----

=== Cookie Consent
The Cookie Consent component has been removed. Vaadin does not provide any replacement, but several third party options exist, such as link:https://github.com/orestbida/cookieconsent[orestbida/cookieconsent].

=== Confirm Dialog
The Flow [classname]`ConfirmDialog` now only implements [classname]`HasComponents` instead of [classname]`HasOrderedComponents`. The following methods are not available anymore: [methodname]`replace`, [methodname]`indexOf`, [methodname]`getComponentCount`, [methodname]`getComponentAt`, [methodname]`getChildren`.

Methods that allowed passing an [classname]`Element` instance have been removed. Use the corresponding alternatives that allow passing a [classname]`Component` instance instead.

=== Context Menu
The [methodname]`add` method has been removed from the Flow [classname]`ContextMenu`. Instead, use [methodname]`addItem` to add menu items, or [methodname]`addComponent` to add generic components without wrapping them into a menu item.

=== CRUD
The “New Item” button in the CRUD component no longer uses the primary style variant by default. To get the old default back:

[.example]
[source,java]
----
crud.getNewButton().addThemeVariants(ButtonVariant.LUMO_PRIMARY);
----

=== Charts
The [methodname]`setWidthAdjust` / [methodname]`getWidthAdjust` methods of the [classname]`Title` class have been removed because it was removed from the underlying Highcharts library.

The [classname]`DrillUpButton` class has been removed from the codebase and all of its related API, e.g., [methodname]`setDrillUpButton` / [methodname]`getDrillUpButton` from the [classname]`Drilldown` class. Use Breadcrumbs instead. Likewise, the [methodname]`setDrillUpText` / [methodname]`getDrillUpText` has been removed from the [classname]`Lang` class.

All methods that accept [classname]`Date` as parameter that were previously marked as deprecated have been removed.

Chart configurations are now serialized using Jackson 3. The [methodname]`ChartSerialization.setObjectMapperInstance` method that can be used to customize serialization behavior now expects a [classname]`tools.jackson.databind.ObjectWriter` instance.

=== Date Picker and Date Time Picker
The following changes have been made to the internal DOM structure of the Date Picker overlay, which may affect custom styling:

* The `vaadin-date-picker-overlay-content` element is now a CSS grid layout instead of a flexbox.
* The `overlay-header` part has been removed.

=== Date Time Picker
In the Flow [classname]`DateTimePicker` component, validation is no longer triggered on blur if the value has remained unchanged after user interaction, making this behavior consistent with the rest of the field components, which already received a similar update in V24.

Incomplete input, where only a date or only a time is entered, is now treated as invalid. The corresponding error message can be configured via [classname]`DateTimePickerI18n`:

[.example]
[source,java]
----
dateTimePicker.setI18n(new DateTimePickerI18n()
    .setIncompleteInputErrorMessage("Please enter both date and time"));
----

=== Details
The [methodname]`setContent` and [methodname]`addContent` methods have been removed from the Flow [classname]`Details` component. Use regular methods from [classname]`HasComponents` such as [methodname]`add`, [methodname]`remove`, [methodname]`removeAll` instead.

=== Dialog and Confirm Dialog
[classname]`Dialog` and [classname]`ConfirmDialog` do not show a closing animation anymore when removing the component from the UI / DOM. Instead, the dialog should be closed and the `closed` event needs to be used to wait for the closing animation to finish before removing the component.

For Flow this is relevant when manually adding / removing the dialog from the UI. The event is not needed when calling [methodname]`dialog.open()` without adding the dialog to the UI.

[source,java,role="before"]
----
var dialog = new Dialog();
add(dialog);
dialog.open();

// When dialog is not needed anymore
remove(dialog);
----
[source,java,role="after"]
----
var dialog = new Dialog();
dialog.addClosedListener(e -> remove(dialog));
add(dialog);
dialog.open();

// When dialog is not needed anymore
dialog.close();
----

For Hilla / React this is relevant when rendering dialogs conditionally.

[source,typescript,role="before"]
----
const opened = useSignal(true);

{ opened ? <Dialog opened={true}/> : null }

// When dialog is not needed anymore
opened.value = false;
----
[source,typescript,role="after"]
----
const ref = useRef<DialogElement>(null);
const opened = useSignal(true);

{
  opened
  ? <Dialog opened={true} ref={ref} onClosed={() => opened.value = false}/>
  : null
}

// When dialog is not needed anymore
ref.current?.close();
----

=== Form Layout
The following custom CSS properties have been removed from `vaadin-form-item`:

* `--vaadin-form-item-label-width`
* `--vaadin-form-item-label-spacing`
* `--vaadin-form-item-row-spacing`

Use the following CSS properties on `vaadin-form-layout` instead:

* `--vaadin-form-layout-label-width`
* `--vaadin-form-layout-label-spacing`
* `--vaadin-form-layout-row-spacing`

=== Grid

The deprecated methods [methodname]`setClassNameGenerator` and [methodname]`getClassNameGenerator` have been removed from both the `Grid` and `Grid.Column` classes. Similarly, the `cellClassNameGenerator` property has been removed from the `vaadin-grid` and `vaadin-grid-column` elements. Instead, use the [methodname]`setPartNameGenerator` method and the [propertyname]`cellPartNameGenerator` property, respectively.

The [methodname]`scrollToItem` method no longer scrolls if the item is already fully visible in the grid viewport.

=== Map
The Map component’s `borderless` / `BORDERLESS` style variant has been renamed `no-border` / `NO_BORDER` for consistency with other components.

=== Menu Bar
The TestBench API `MenuBarElement.OVERLAY_TAG` has been removed. To get a reference to a sub-menu, instead use [methodname]`MenuBarButtonElement.openSubMenu` which returns a reference.

=== Message Input
The send button no longer uses the Primary style variant by default. To revert this change you can style the button with CSS:

[.example]
[source,css]
----
vaadin-message-input > vaadin-message-input-button {
  background-color: var(--lumo-primary-color);
  color: var(--lumo-primary-contrast-color);
}
----

Also, the send button now is a `vaadin-message-input-button` instead of `vaadin-button`.

=== Multi-Select Combo Box
The Multi-Select Combo Box no longer uses `vaadin-multi-select-combo-box-internal` internally. This may affect custom shadow DOM styling of the component.

=== Overlays

Component overlays (like Dialog or the Combo Box drop-down) are no longer rendered outside of the component itself. This causes the following breaking changes to overlay styling:

* The `overlayClass` property and the [methodname]`setOverlayClassName` method in Flow are gone. Apply a normal class name to the component instead.
* The `vaadin-xyz-overlay` (such as `vaadin-dialog-overlay`) elements can not be targeted with CSS anymore. Refactor any CSS targeting these elements to target the component itself instead (e.g. `vaadin-dialog` instead of `vaadin-dialog-overlay`), using the same part names as before. Other CSS selectors are unaffected by this change.

[source,css,role="before"]
----
vaadin-dialog-overlay::part(content) {}
----
[source,css,role="after"]
----
vaadin-dialog::part(content) {}
----

You’ll find the appropriate selector in the component’s Styling page.

=== Popover
The Lit/React component’s `contentWidth` and `contentHeight` properties have been replaced by `width` and `height`.

=== Rich Text Editor
The `on` attribute was removed and can no longer be used to target toggled-on buttons. Instead, use the selector `::part(toolbar-button-pressed)` to target them with CSS.

=== Split Layout
The Split Layout component no longer sets `overflow:auto` on its two child elements. The link:https://vaadin.com/docs/latest/components/scroller[Scroller] component is recommended to make them scrollable on overflow. Alternatively, you can apply it manually with CSS:

[.example]
[source,css]
----
vaadin-split-layout > * {
  overflow: auto;
}
----

The `SplitterDragendEvent` and `addSplitterDragendListener` have been renamed to `SplitterDragEndEvent` and `addSplitterDragEndListener`, respectively.

=== Spreadsheet
The events [classname]`CellValueChangeEvent`, [classname]`FormulaValueChangeEvent`, and [classname]`SelectionChangeEvent` in Spreadsheet provide a set of cells. Calling [methodname]`contains` on these sets now requires the [classname]`CellReference` argument to have a non-null sheet name, otherwise an [classname]`IllegalArgumentException` will be thrown. In order to achieve this, use one of the following constructors:

* `CellReference(Cell)`
* `CellReference(String, int, int, boolean, boolean)`

=== Tabs / Tab Sheet
The [classname]`TabsVariant.LUMO_ICON_ON_TOP` and [classname]`TabSheetVariant.LUMO_ICON_ON_TOP` theme variants have been removed. Apply the [classname]`TabVariant.LUMO_ICON_ON_TOP` to individual tabs instead.

=== Text Field
The [classname]`HasPrefixAndSuffix` interface has been removed from the Flow [classname]`TextField` and related components. The components now implement [classname]`HasPrefix` and [classname]`HasSuffix` instead.

=== Time Picker
The Time Picker no longer uses `vaadin-time-picker-combo-box` internally. This may affect custom shadow DOM styling of the component.

The [classname]`TimePickerOverlayElement` TestBench element has been removed as the component now uses the native HTML popover mechanism for its drop-down. The [methodname]`getItem` and [methodname]`getLastItem` methods are now available on [classname]`TimePickerElement` itself.

=== Tree Grid
Tree Grid's client-side approach to data loading has been refactored. Instead of requesting data for each hierarchy level separately, the web component now sends a single request for the visible range, and the server always returns the corresponding items as a flat list. On the server side, on the other hand, the data provider can now choose to provide hierarchical data in one of two formats: the existing <<../components/tree-grid/data-providers#hierarchyformat-nested-default,`HierarchyFormat.NESTED`>> (default) or the new <<../components/tree-grid/data-providers#hierarchyformat-flattened,`HierarchyFormat.FLATTENED`>>. These updates collectively introduce breaking changes, which are described below.

The [propertyname]`pageSize` property now applies to the entire flattened hierarchy rather than to each level individually as before.

Expanded items are no longer exposed to the client side as a plain array. Instead, the web component receives depth information for each item and uses it to display the data as a tree structure.

As a result, the [methodname]`TreeGridElement#isLoadingExpandedRows` TestBench API has been removed. You no longer need to wait for expanded rows specifically since they are loaded in the same request with other rows.

The [methodname]`TreeGridElement#getNumberOfExpandedRows` TestBench API has also been removed. Use unit tests instead to verify that exact items are expanded:

[source,java,role="before"]
.integration test
----
private TreeGridElement treeGridElement;

@Test
public void shouldHaveSomeRowsExpanded() {
    Assert.assertEquals(2, treeGridElement.getNumberOfExpandedItems());
}
----
[source,java,role="after"]
.unit test
----
private TreeGrid<String> treeGrid;

@Test
public void shouldHaveSomeRowsExpanded() {
    Assert.assertTrue(treeGrid.isExpanded("Item 0"));
    Assert.assertTrue(treeGrid.isExpanded("Item 0-1"));
}
----

The following section is relevant if your code extends [classname]`Grid` or [classname]`TreeGrid`, or accesses low-level Flow APIs like [classname]`HierarchicalDataCommunicator`.

.Low-Level API Changes
[%collapsible]
====
The [classname]`GridArrayUpdater.UpdateQueueData` class has been removed, along with related API:

* The [methodname]`setUpdateQueueData` method in [classname]`GridArrayUpdater` has been removed
* The [methodname]`getUpdateQueueData` method in [classname]`GridArrayUpdater` has been removed
* Parameters that included [classname]`UpdateQueueData` in their type have been removed from all [classname]`Grid` and [classname]`TreeGrid` constructors and methods:
+
--
[source,java,role="before"]
----
protected <U extends GridArrayUpdater, B extends DataCommunicatorBuilder<T, U>> Grid(
    Class<T> beanType,
    SerializableBiFunction<UpdateQueueData, Integer, UpdateQueue> updateQueueBuilder,
    B dataCommunicatorBuilder)
----
[source,java,role="after"]
----
protected <U extends GridArrayUpdater, B extends DataCommunicatorBuilder<T, U>> Grid(
    Class<T> beanType,
    B dataCommunicatorBuilder)
----
--
+
--
[source,java,role="before"]
----
protected GridArrayUpdater createDefaultArrayUpdater(
    SerializableBiFunction<UpdateQueueData, Integer, UpdateQueue> updateQueueFactory)
----
[source,java,role="after"]
----
protected GridArrayUpdater createDefaultArrayUpdater()
----
--

The [classname]`TreeGridArrayUpdater` interface has also been removed. The [classname]`GridArrayUpdater` interface is now used for both hierarchical and non-hierarchical updates.

The [classname]`HierarchicalDataCommunicator` class in Flow has been fully refactored to use a flat list structure for representing hierarchical data on the client side. Although it still extends the [classname]`DataCommunicator` class, its internal implementation has been completely redesigned to optimize hierarchy rendering and address various bugs. This caused the following breaking changes:

* Both the [classname]`HierarchicalCommunicationController` and [classname]`HierarchyMapper` concepts have been retired, and all related protected APIs in [classname]`HierarchicalDataCommunicator` have been removed, including such methods as [methodname]`createHierarchyMapper` and [methodname]`getHierarchyMapper`.
* The [propertyname]`arrayUpdater` parameter has been removed from all [classname]`HierarchicalDataCommunicator` constructors. The data communicator now re-renders modified items by making granular [methodname]`Update#set(int index, List items)` calls.
* The protected [methodname]`doUnregister` and [methodname]`getPassivatedKeys` methods have been removed.
* The protected [methodname]`setFilter` method has been removed. Use the returned consumer of the [methodname]`setDataProvider(HierarchicalDataProvider, Object)` method instead.
* The protected [methodname]`collapse(T item, boolean syncClient)` method has been removed. Use the [methodname]`collapse(T item)` method instead.
* The protected [methodname]`expand(T item, boolean syncClient)` method has been removed. Use the [methodname]`expand(T item)` method instead.
* The public [methodname]`setRequestedRange` and [methodname]`setParentRequestedRange` methods have been merged into a single method [methodname]`setViewportRange(int start, int length)`. Instead of setting ranges separately for each level, this method sets a single range that operates on the flat list of items from all levels.
* The public [methodname]`confirmUpdate(int id, String parentKey)` method has been removed. The [methodname]`confirmUpdate(int id)` method is now called instead.
* The public [methodname]`getParentItem(T item)` method has been removed. Use the [classname]`HierarchicalDataProvider#getParent` method instead to get an item's parent reliably.
* The public [methodname]`getIndex(T item)` and [methodname]`getParentIndex(T item)` methods have been removed. To find an item's index reliably, use a combination of the [classname]`HierarchicalDataProvider#getItemIndex`, [classname]`HierarchicalDataProvider#getParent`, [classname]`HierarchicalDataCommunicator#buildQuery` methods as shown in the example below:
+
[.example]
--
[source,java]
.HierarchyFormat.NESTED
----
// By default, the data provider implements HierarchyFormat.NESTED,
// meaning each request returns only the direct children of a parent.
// In this format, items are identified by their hierarchical path,
// a list of indexes from the root to the item. This path can then
// be passed to `TreeGrid#scrollToIndex` to scroll to that item, for
// example.

public List<Integer> getIndexPath(T item) {
    List<Integer> path = new LinkedList<>();
    do {
        var parent = dataCommunicator.getDataProvider().getParent(item);
        var query = dataCommunicator.buildQuery(parent, 0, Integer.MAX_VALUE);
        var index = dataCommunicator.getDataProvider().getItemIndex(item, query);
        path.addFirst(index);
        item = parent;
    } while (item != null);
    return path;
}
----
[source,java]
.HierarchyFormat.FLATTENED
----
// When the data provider implements HierarchyFormat.FLATTENED,
// each request returns all descendants of a parent item in a
// single flat list. In this format, items are identified by
// their index in that list, which is called "flat index".
// This index can then be passed to `TreeGrid#scrollToIndex`
// to scroll to that item, for example.

public int getFlatIndex(T item) {
    var query = dataCommunicator.buildQuery(0, Integer.MAX_VALUE);
    return dataCommunicator.getDataProvider().getItemIndex(item, query);
}
----
--
====

Tree Grid now supports scrolling to a specific item using [methodname]`scrollToItem(T)`. Unlike [methodname]`scrollToIndex(int...)`, this method automatically expands any collapsed parent items before scrolling to the target item.

This feature relies on the [methodname]`getParent(T)` and [methodname]`getItemIndex(T, HierarchicalQuery)` methods of the [classname]`HierarchicalDataProvider` interface. To use [methodname]`scrollToItem(T)`, your data provider must implement these methods. The built-in `TreeDataProvider` already provides full support out of the box.

The following table shows which methods need to be implemented, depending on the data provider type and whether it is in-memory or not:

[cols="3,2,4,2"]
|===
| `DataProvider` | `isInMemory()` | `getItemIndex(T, HierarchicalQuery)` | `getParent(T)`

|`TreeDataProvider`
|`true`
|Not required
|Not required

|`HierarchicalDataProvider`
|`true`
|Not required
|Required

|`HierarchicalDataProvider`
|`false`
|Required
|Required



|===

=== Upload

The web component now uses "raw" requests for file uploads instead of multipart requests by default. The file content is sent as the request body, and metadata such as file name and content type are sent as HTTP headers (`X-Filename` and `Content-Type` respectively).
To revert to using multipart requests, set the `uploadFormat` property to `multipart`. The Flow component handles the new default automatically under the hood and filename and content type can still be accessed as before.

The `vaadin-upload-file` elements representing files in the list now use CSS grid layout instead of flexbox. This may affect custom styling of the element.

The `row` and `info` parts have been removed from the `vaadin-upload-file` element.

=== Validation
Flow components using validation do not implement [classname]`HasClientValidation` anymore, as such the [methodname]`addClientValidatedEventListener` method has been removed. Consider using [classname]`ValidationStatusChangeEvent` to get notified when users enter input that can not be parsed.

== Security Configuration Changes

The deprecated [classname]`VaadinWebSecurity` class has been removed from Vaadin 25. Use instead the [classname]`VaadinSecurityConfigurer` base class for your security configuration. Below is an example of this:

[source,java]
----
<source-info group="VaadinWebSecurity (deprecated since V24.9)"></source-info>
@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        /**
         * Delegating the responsibility of general configuration
         * of HTTP security to the VaadinSecurityConfigurer.
         *
         * It's configuring the following:
         * - Vaadin's CSRF protection by ignoring internal framework requests,
         * - default request cache,
         * - ignoring public views annotated with @AnonymousAllowed,
         * - restricting access to other views/endpoints, and
         * - enabling ViewAccessChecker authorization.
         */

        // You can add any possible extra configurations of your own
        // here - the following is just an example:
        http.rememberMe(customizer -> customizer.alwaysRemember(false));

        // Configure your static resources with public access before calling
        // VaadinSecurityConfigurer.vaadin() as it adds final anyRequest matcher
        http.authorizeHttpRequests(auth -> {
            auth.requestMatchers("/admin-only/**").hasAnyRole("admin")
            .requestMatchers("/public/**").permitAll();
        });

        http.with(VaadinSecurityConfigurer.vaadin(), configurer -> {
            // This is important to register your login view to the
            // view access checker mechanism:
            configurer.loginView(LoginView.class);
        });

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Demo UserDetailsManager which only provides two hardcoded
     * in-memory users and their roles.
     * This shouldn't be used in real-world applications.
     */
    @Bean
    public UserDetailsService userDetailsService(
            PasswordEncoder passwordEncoder) {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("user")
                .password(passwordEncoder.encode("userPass"))
                .roles("USER").build());
        manager.createUser(User.withUsername("admin")
                .password(passwordEncoder.encode("adminPass"))
                .roles("USER", "ADMIN").build());
        return manager;
    }
}
----

==== Upgrade To VaadinSecurityConfigurer From VaadinWebSecurity

. Add a new method to the security configuration class to provide the security filter chain bean

+
[source,java]
----
@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    return http.with(VaadinSecurityConfigurer.vaadin(), vaadin -> {
        ...
    }).build();
}
----
+

**Hint**: you can use a static import for `VaadinSecurityConfigurer.vaadin()`.

. Move and adapt the code of the `configure(HttpSecurity)` method into `vaadinSecurityFilterChain()`.
.. customizations of [classname]`HttpSecurity` placed before `super.configure()` can be moved before the `with(vaadin(), vaadin -> {})` instruction.
.. calls to [classname]`VaadinWebSecurity` methods have related methods in the [classname]`VaadinSecurityConfigurer`.
+
--
[source,java,role="before"]
----
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(registry -> {
        registry.requestMatchers("/assets/**").permitAll();
    });
    super.configure(http);
    setLoginView(http, "/login", "/");
}
----
[source,java,role="after"]
----
@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(registry -> {
        registry.requestMatchers("/assets/**").permitAll();
    });
    http.with(vaadin(), vaadin -> vaadin.loginView("/login", "/"));
    return http.build();
}
----
--

. If `configure(WebSecurity web)` is overridden you might:

.. Move the rules in the security filter chain bean definition using `HttpSecurity.authorizeRequests()` and remove the original method (recommended by Spring, to prevent skipping all other filters in the chain):
+
--
[source,java,role="before"]
----
@Override
protected void configure(WebSecurity web) throws Exception {
    web.ignoring().requestMatchers("/images/**");
}
----
[source,java,role="after"]
----
@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    http.authorizeHttpRequests(registry -> {
        registry.requestMatchers("/assets/**", "/images/**").permitAll();
    });
    http.with(vaadin(), vaadin -> vaadin.loginView("/login", "/"));
    return http.build();
}
----
--

.. OR, expose a [classname]`WebSecurityCustomizer` bean by your own and remove the original method
+
--
[source,java,role="before"]
----
@Override
protected void configure(WebSecurity web) throws Exception {
    web.ignoring().requestMatchers("/images/**");
}
----
[source,java,role="after"]
----
@Bean
public WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring().requestMatchers("/images/**");
}
----
--

. If stateless authentication is configured (`setStatelessAuthentication(...)`), replace the call using `VaadinStatelessSecurityConfigurer`
+
--
[source,java,role="before"]
----
@Override
protected void configure(HttpSecurity web) throws Exception {
    //...
    setStatelessAuthentication(http, new SecretKeySpec(Base64.getDecoder().decode(authSecret), JwsAlgorithms.HS256), "com.example.application");
    //...
}
----
[source,java,role="after"]
----
@Bean
public SecurityFilterChain vaadinSecurityFilterChain(HttpSecurity http) throws Exception {
    //...
    http.with(new VaadinStatelessSecurityConfigurer<>(), stateless -> stateless.issuer("com.example.application")
        .withSecretKey()
        .secretKey(new SecretKeySpec(Base64.getDecoder().decode(authSecret), JwsAlgorithms.HS256))
    );
    //...
}
----
--

. Remove `extends VaadinWebSecurity` and import the Vaadin security context holder strategy
+
[source,java]
----
@EnableWebSecurity // should be already present
@Configuration     // should be already present
public class SecurityConfiguration {
}
----


==== Restrict Access By Default For Url-Based Security
URLs not explicitly specified in security configuration changed from being allowed for authenticated users to restricted by default. This requires extra security rules (path matchers) for URLs that were allowed only for authentication users.

==== Deny Access If Flow Layout Has No Security Annotation
Vaadin Flow layouts now require access annotation (e.g. [classname]`RolesAllowed` or [classname]`AnonymousAllowed`) on layout classes. This was added to align with auto-layout default security rules.

.Main layout in 24 secured application for anonymous user views
[source,java]
----
@Layout
public class MainLayout extends AppLayout {
}
----

.Main layout in 25 secured application for anonymous user views
[source,java]
----
@Layout
@AnonymousAllowed
public class MainLayout extends AppLayout {
}
----


== TestBench

=== JUnit 6 and Vintage Engine for JUnit 4 Tests

Vaadin 25 with Spring Boot 4 uses JUnit 6 (JUnit Platform) as the default test framework. If you have JUnit 4 tests using [classname]`UIUnit4Test` (UI Unit) or [classname]`TestBenchTestCase` (End-to-End), they won't be detected or executed without adding the JUnit Vintage Engine dependency.

See <<{articles}/flow/testing/ui-unit/getting-started#,Getting Started with UI Unit Testing>> and <<{articles}/flow/testing/end-to-end/getting-started#,Getting Started with End-to-End Testing>> for the required dependencies.

=== ComponentTester Click Method

[classname]`ComponentTester` in UI Unit test has been updated to prove a common [methodname]`void click()` method. However, the new method clashes with a similar existing method in [classname]`AnchorTester` and [classname]`RouterLinkTester` that returns an [classname]`HasElement` instance as a result of the navigation. Existing tests that rely on the return type have to migrate to the new [methodname]`navigate()` method; if the return value is not used, there is no need for changes.

Because of the change, the [classname]`com.vaadin.flow.component.html.testbench.ClickHandler` class has been removed. The interface, meant to be used with [classname]`ComponentTester` subclasses, should not be needed anymore. In this case, [classname]`com.vaadin.testbench.unit.Clickable` is a valid substitute.

The [methodname]`getPropertyString`, [methodname]`getPropertyBoolean`, [methodname]`getPropertyDouble` and [methodname]`getPropertyInteger` methods of the [classname]`TestBenchElement` class have been changed to not convert property values to the respective result types anymore. For example, calling [methodname]`getPropertyString` on a property that contains a number value will now throw an exception instead of returning the string representation of the number.

== Binder
[methodname]`Binder.validate()` implementation has been changed to behave as its Javadoc states. In other words, [methodname]`Binder.validate()` no longer fails when bean level validators have been configured but no bean is currently set (i.e. [classname]`Binder` is used in buffered mode).

== Server-Side Modality
[classname]`Dialog` has become less strict and allows background requests to server. Vaadin Flow allows to change this behavior if needed through [methodname]`Dialog.setModality(ModalityMode)` method.

== Form Filler Add-On
The link:https://github.com/vaadin/form-filler-addon[Form Filler add-on] has been removed from the Vaadin 25 platform. If your project uses it, you can add it as a separate dependency or get the same functionality with much less code using Spring AI to have the LLM directly populate a Java object that you can then use with e.g. [methodname]`binder.readBean()`.

== Polymer Support

In Vaadin 25, the `@polymer/polymer` dependency in default `package.json` is removed by default, if polymer-template module is not found from the project. If the application uses Polymer in add-ons may require to add `@NpmPackage(value = "@polymer/polymer", version = "3.5.2")` or add an import to `package.json` explicitly. Details can be found in link:https://github.com/vaadin/flow/issues/21421[Ensure Flow works without Polymer in v25].

== Frontend Sources Directory
Vaadin uses the [filename]`{project directory}/src/main/frontend/` directory as the default location for frontend sources. Legacy location [filename]`{project directory}/frontend/` is deprecated and a warning is shown if it's used. If you're using the legacy location, please move your files to the new location, or add the `frontendDirectory` parameter and point it to the legacy location. Legacy location support will be removed in a future release.

== Removed Deprecations

APIs deprecated earlier have now been removed. The following linked GitHub issue lists these removals — link:https://github.com/vaadin/flow/issues/21396[Remove deprecated API in Flow 25.0].

== Upgrading Add-ons

Some add-ons may require updates to work with Vaadin 25. This section gives an overview of the most common required changes.

=== Java-based Add-ons

This section covers add-ons that provide Flow components implemented in Java.

==== JSON RPC Changes

Flow's RPC mechanism now uses Jackson 3 instead of Elemental JSON. Using `elemental.json.JsonObject` or `elemental.json.JsonArray` types in the following places is no longer supported:

- Passing parameters to `Element.executeJs` or `Element.callJsFunction`
- Handling parameters from client-side RPC calls in `@ClientCallable` methods
- Mapping data from custom events using `@EventData`

Use the respective Jackson 3 types, such as `ObjectNode` and `ArrayNode`, instead.

=== Frontend-based Add-ons

This section covers add-ons that provide custom web components implemented in TypeScript or JavaScript.

==== Lumo Javascript Modules

The Lumo Javascript modules have been removed, as such imports such as the following no longer work and should be removed:

[source,js]
----
import '@vaadin/vaadin-lumo-styles/color.js';
import '@vaadin/vaadin-lumo-styles/font-icons.js';
import '@vaadin/vaadin-lumo-styles/sizing.js';
import '@vaadin/vaadin-lumo-styles/spacing.js';
import '@vaadin/vaadin-lumo-styles/style.js';
import '@vaadin/vaadin-lumo-styles/typography.js';
----

In general these imports were used to ensure Lumo custom CSS properties were defined globally. However, this should not be done by add-ons, but rather by the application that uses the add-on. As such, there is no alternative import to use in add-ons.

If the add-on provides a demo HTML page, the Lumo theme can be imported there using a link tag for example:
[source,html]
----
<!-- Assuming the demo HTML page is in a folder such as `demo` in the project root -->
<link rel="stylesheet" href="../node_modules/@vaadin/vaadin-lumo-styles/lumo.css">
----

Lumo Javascript mixins have not been removed and can still be used to inject common styles into custom components:
[source,js]
----
import { inputField } from '@vaadin/vaadin-lumo-styles/mixins/input-field-shared.js';

class MyInputField extends LitElement {
  static get styles() {
    return [
      inputField,
      css`...`
    ];
  }
}
----

==== Lumo Global Typography

Previously you could apply the Lumo global typography styles to a custom component's shadow root like so:

[source,js]
----
import { typography } from "@vaadin/vaadin-lumo-styles";

class MyComponent extends LitElement {
  static get styles() {
    return [
      typography,
      css`...`
    ];
  }
}
----

This would result in Lumo styles being applied to text nodes and basic HTML elements (headings, links) in the component’s shadow root.

This is not possible anymore in v25, as the respective Typography module has been converted into a CSS file. If you need to apply Lumo typography styles to basic HTML elements in your component’s shadow root then you can copy the relevant styles into your component’s styles.

==== Theme Structure

Previously, theme-specific component styles and entry-points were located in `theme/lumo` / `theme/material` folders. In Vaadin 24 an import for a component was then resolved to either folder, depending on which theme was applied using the `@Theme` annotation. In Vaadin 25 this mechanism does not work anymore.

Regardless of whether the add-on supports multiple themes or not, all styles should be placed in the component's source file by using the `static get styles()` Lit API.

If the add-on wants to support the two official Vaadin themes (Aura or Lumo), then the component can implement `ThemeDetectionMixin`, which automatically adds an attribute to the component based on the active theme. This attribute can then be used to target theme-specific styles rules:

[source,js]
----
import { ThemeDetectionMixin } from '@vaadin/vaadin-themable-mixin/theme-detection-mixin.js';

class MyComponent extends ThemeDetectionMixin(LitElement) {
  static get styles() {
    return css`
      :host {
        /* Common / functional styles */
      }
      :host([data-application-theme="aura"]) {
        /* Aura-specific styles */
      }
      :host([data-application-theme="lumo"]) {
        /* Lumo-specific styles */
      }
    `;
  }
}
----

If the add-on supports custom themes, then styles for those themes can be provided as separate CSS files that an application using the add-on can import.

==== Mixins

`ThemableMixin` and `registerStyles` are planned to be removed in a future Vaadin version. Consider migrating add-on components to Lit and use the `get styles() { ... }` API to define styles instead.

`ControllerMixin` has been removed. If an add-on component relies on controllers it should be converted to Lit which provides the same API natively.
