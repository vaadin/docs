---
title: Upgrading Guide
page-title: How to upgrade Vaadin applications
description: Changes needed to upgrade an application from Vaadin 24 to the latest version.
meta-description: Follow this comprehensive guide to upgrade your Vaadin applications to the latest version.
order: 900
---


= Upgrading from Vaadin 24

This guide goes through the changes you'll need to make in your applications when upgrading from Vaadin 24 to the latest version. After making them, your application should compile, run, behave, and look the way it did before you upgraded.

.Upgrading from Earlier Version
[TIP]
See link:/docs/v24/upgrading/essential-steps[Vaadin 23 to 24 Upgrade Instructions] if you're upgrading from a version earlier than Vaadin 24.

Many of the breaking changes are needed because of fundamental changes in the Java platform and the major dependencies on which Vaadin relies. This includes the following:

Java 21::
Vaadin 25 requires Java 21 or later. Java 21 is the latest LTS version of Java. Upgrading to Java 21 might require you to upgrade other dependencies in your application.

Spring Boot 4::
Vaadin 25 uses the latest Spring Boot 4 and Spring Framework 7 versions. This leads to making breaking changes in Spring-based features, compared to earlier Spring Boot 3.5 and Spring Framework 6 versions.

Servlet 6.1::
Vaadin 25 is based on link:https://jakarta.ee/specifications/servlet/6.1/[Servlet 6.1] specification, which is compatible with link:https://jakarta.ee/specifications/platform/11/[Jakarta EE 11]. When upgrading from Vaadin 24 (Servlet 6 and Jakarta EE10), changes are typically not needed.

Gradle 8/9::
Gradle 8 (8.14 and later) and Gradle 9 releases are supported.

Jackson 3::
Elemental has been replaced with Jackson while Jackson version has been updated to 3. This only affects you if the your application uses some of the affected low-level APIs. Details can be found in link:https://github.com/vaadin/flow/issues/21060[Finalize Jackson conversion] and its sub-issues.


== Overview

Vaadin 25 doesn't change fundamentally how applications are developed and behave. Nevertheless, the upgrade process requires the following essential tasks and tests:

Preparation::
Upgrade the Vaadin version in the project's [filename]`pom.xml` file, checking for the latest Vaadin 25 release link:https://github.com/vaadin/platform/releases[in GitHub].

Upgrade Java::
Upgrade your application to use Java 21 or later.

Upgrade Spring::
For Spring-based applications, upgrade to Spring Boot 4 or Spring Framework 7, depending on which is used in your project. For non-Spring applications, upgrade the application server version to one that's compatible with Jakarta EE 11.

Other Dependencies::
Upgrade third-party dependencies used in your project (e.g., Maven/Gradle plugins, libraries, frameworks) to compatible versions.

Verify & Test::
Ensure your application is not using deprecated code fragments.
+
Make sure your application runs well on Java 21 runtime.


== Limitations

Portlet and OSGi integrations are not included for two reasons: First, the latest Portlet 3 specification corresponds to Servlet 3, and it doesn't work with Servlet 6.1. Second, a Jakarta EE 10 compatible version of OSGi core runtime https://felix.apache.org/documentation/index.html[Apache Felix 8] is under development. The https://karaf.apache.org/[Apache Karaf] container is based on Apache Felix and doesn't have a Jakarta-compatible version.


== Preparation

Upgrade the Vaadin version in the [filename]`pom.xml` and [filename]`gradle.properties` files to the latest release like so:

include::{articles}/_vaadin-version.adoc[]

[.example]
--
[source,xml,subs="+attributes"]
----
<source-info group="pom.xml"></source-info>
<vaadin.version>{vaadin-version}</vaadin.version>
----
[source,properties,subs="+attributes"]
----
<source-info group="gradle.properties"></source-info>
vaadinVersion={vaadin-version}
----
--

See the link:https://github.com/vaadin/platform/releases[list of releases on GitHub] for the latest one.


== Spring Upgrade Instructions

To browse a full list of changes, see the https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-4.0.0-M3-Release-Notes[Spring-boot 4.0 Release Notes] and the https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-7.0-Release-Notes[What's New in Spring Framework 7.x] page.

The following sections provide a general overview of the changes needed for Spring-based Vaadin applications.


=== Upgrade Spring to Latest

You'll need to upgrade Spring to the latest versions, including the starter parent dependency:

.pom.xml
[source,xml]
----
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>4.0.0</version>
</parent>
----


=== Deprecation

The deprecated `VaadinWebSecurity` class was removed. Use instead the `VaadinSecurityConfigurer` class for your security configuration. Below is an example of this:

[.example]
--

[source,java]
----
<source-info group="VaadinSecurityConfigurer"></source-info>
@EnableWebSecurity
@Configuration
@Import(VaadinAwareSecurityContextHolderStrategyConfiguration.class)
public class SecurityConfig {

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        /**
         * Delegating the responsibility of general configuration
         * of HTTP security to the VaadinSecurityConfigurer.
         *
         * It's configuring the following:
         * - Vaadin's CSRF protection by ignoring internal framework requests,
         * - default request cache,
         * - ignoring public views annotated with @AnonymousAllowed,
         * - restricting access to other views/endpoints, and
         * - enabling ViewAccessChecker authorization.
         */

        // You can add any possible extra configurations of your own
        // here - the following is just an example:
        http.rememberMe(customizer -> customizer.alwaysRemember(false));

        // Configure your static resources with public access before calling
        // VaadinSecurityConfigurer.vaadin() as it adds final anyRequest matcher
        http.authorizeHttpRequests(auth -> {
            auth.requestMatchers("/admin-only/**").hasAnyRole("admin")
            .requestMatchers("/public/**").permitAll();
        });

        http.with(VaadinSecurityConfigurer.vaadin(), configurer -> {
            // This is important to register your login view to the
            // view access checker mechanism:
            configurer.loginView(LoginView.class);
        });

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Demo UserDetailsManager which only provides two hardcoded
     * in-memory users and their roles.
     * This shouldn't be used in real-world applications.
     */
    @Bean
    public UserDetailsService userDetailsService(
            PasswordEncoder passwordEncoder) {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("user")
                .password(passwordEncoder.encode("userPass"))
                .roles("USER").build());
        manager.createUser(User.withUsername("admin")
                .password(passwordEncoder.encode("adminPass"))
                .roles("USER", "ADMIN").build());
        return manager;
    }
}
----

[source,java]
----
<source-info group="VaadinWebSecurity (deprecated since V24.9)"></source-info>
@EnableWebSecurity
@Configuration
@Import(VaadinAwareSecurityContextHolderStrategyConfiguration.class)
public class SecurityConfig {

    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        /**
         * Delegating the responsibility of general configuration
         * of HTTP security to the VaadinSecurityConfigurer.
         *
         * It's configuring the following:
         * - Vaadin's CSRF protection by ignoring internal framework requests,
         * - default request cache,
         * - ignoring public views annotated with @AnonymousAllowed,
         * - restricting access to other views/endpoints, and
         * - enabling ViewAccessChecker authorization.
         */

        // You can add any possible extra configurations of your own
        // here - the following is just an example:
        http.rememberMe(customizer -> customizer.alwaysRemember(false));

        // Configure your static resources with public access before calling
        // VaadinSecurityConfigurer.vaadin() as it adds final anyRequest matcher
        http.authorizeHttpRequests(auth -> {
            auth.requestMatchers("/admin-only/**").hasAnyRole("admin")
            .requestMatchers("/public/**").permitAll();
        });

        http.with(VaadinSecurityConfigurer.vaadin(), configurer -> {
            // This is important to register your login view to the
            // view access checker mechanism:
            configurer.loginView(LoginView.class);
        });

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Demo UserDetailsManager which only provides two hardcoded
     * in-memory users and their roles.
     * This shouldn't be used in real-world applications.
     */
    @Bean
    public UserDetailsService userDetailsService(
            PasswordEncoder passwordEncoder) {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername("user")
                .password(passwordEncoder.encode("userPass"))
                .roles("USER").build());
        manager.createUser(User.withUsername("admin")
                .password(passwordEncoder.encode("adminPass"))
                .roles("USER", "ADMIN").build());
        return manager;
    }
}
----


== Java Version

Java 21 or later is required. Below is an example of how to use this version:

[.example]
--
[source,xml]
----
<source-info group="Maven"></source-info>
<properties>
    <java.version>21</java.version>
    <!-- OR: -->
    <maven.compiler.source>21/maven.compiler.source>
    <maven.compiler.target>21</maven.compiler.target>
</properties>
----
[source,kotlin]
----
<source-info group="Gradle (Kotlin DSL)"></source-info>
plugins {
    java
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
----
[source,groovy]
----
<source-info group="Gradle (Groovy DSL)"></source-info>
plugins {
    id 'java'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}
----
--


== Application Servers

Before migrating, find the corresponding version of the Jakarta EE 11-compatible application server used in your project. See link:https://jakarta.ee/compatibility/[Jakarta Compatible Products] for more information.



[role="since:com.vaadin:vaadin@V24.4"]
== Frontend Sources Directory
Vaadin uses the [filename]`{project directory}/src/main/frontend/` directory as the default location for frontend sources. Legacy location [filename]`{project directory}/frontend/` is no longer supported or used automatically [filename]`{project directory}/src/main/frontend/` directory doesn't exist, a warning will be output instead. If you're using the legacy location, you should move your files to the new location, or add the `frontendDirectory` parameter and point it to the legacy location for it to function correctly.


== Polymer Support

In Vaadin 25, the `@polymer/polymer` dependency in default `package.json` is removed by default, if polymer-template module is not found from the project. If the application uses Polymer in add-ons may require to add `@NpmPackage(value = "@polymer/polymer", version = "3.5.2")` or add an import to `package.json` explicitly. Details can be found in link:https://github.com/vaadin/flow/issues/21421[Ensure Flow works without Polymer in v25]


== Maven & Gradle Plugins

Ensure that the Maven plugins which are explicitly defined in your project, are compatible with Java 21. <TODO: any specific versions to mention?>

To run Gradle on top of Java 21 and latest Spring Boot 4 versions, you'll need to use version 8.14 or later. See the https://docs.gradle.org/8.14/release-notes.html[Gradle release notes] for further details. If your project uses Spring Boot, upgrade the plugin `org.springframework.boot` to version 4.0.0.

If you're using a Gradle wrapper, update it to version 8.14 by executing the following from the command line:

[source,terminal]
----
./gradlew wrapper --gradle-version 8.14
----

For Java 21 compatibility, you may need to update the `sourceCompatibility` setting in your project's build file to version 21. Check your project's build file and make any necessary changes.

== Quarkus

Vaadin Quarkus extension is changed to build production package by default. No need for production profile with exclusions for development tools in Maven configurations because Vaadin Quarkus extension has build-in Vaadin plugin handling production packaging.

To allow project to keep build configuration unchanged, Vaadin Quarkus extension has `vaadin.build.enabled` property to change the default behaviour. Disable Vaadin plugin by adding `vaadin.build.enabled=false` in `application.properties` file to keep using profile based configuration.

== Removed Deprecations

APIs that were deprecated earlier have now been removed. The following linked GitHub issue lists these removals:

- https://github.com/vaadin/flow/issues/21396[Remove deprecated API in Flow 22.0]

== Side Navigation Replaces AppNav and AppNavItem

Some starter projects previously used the `AppNav` and `AppNavItem` components, which relied on the Vaadin Component Factory components, vcf-nav and vcf-nav-item. These Component Factory components are no longer supported and you should replace `AppNav` and `AppNavItem` with their successor, <</components/side-nav#,Side Navigation>>.

