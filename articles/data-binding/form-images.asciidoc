---
title: Image Fields in Forms
description: Allowing images to be uploaded in forms.
order: 110
layout: page
---

= Submitting Images in Forms

A common use case is a form field that allows an image to be uploaded.
For instance, an application may let users customize their avatars.
This tutorial shows how this can be implemented for forms, using the `vaadin-upload` component for local file selection (by file browser or dragging), but postponing the actual server upload until the form is submitted.

The tutorial application allows a contact card to be edited.
It assumes a server-side bean where the image is stored as a Base64-encoded string in the field `avatarBase64`:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/forms/Contact.java[]
----

It also assumes that the server exposes an endpoint for saving updated `Contact` instances:

[source,java]
----
include::{root}/src/main/java/com/vaadin/demo/fusion/forms/ContactEndpoint.java[]
----


The following form binds the `avatarBase64` field of the instance to a `vaadin-upload` component:

[source,typescript]
----
include::{root}/frontend/demo/fusion/forms/contact-form.ts[]
----

In the above code, the custom `upload-before` listener prevents `vaadin-upload` from uploading the received file to the server.
Instead, it reads the file into a Base64-encoded string and updates the form field `avatarBase64` via the [classname]#Binder#.
The small https://www.npmjs.com/package/promise-file-reader[`promise-file-reader`] library wrapping [classname]#FileReader# inside a promise is used here to handle the result synchronously.

The [classname]#Contact# instance is first submitted to the [methodname]#saveContact()# endpoint.
This happens through the statement [methodname]#this.binder.submitTo(saveContact)# in the [methodname]#save()# method.
Only then does the server-side endpoint implementation receive the image string.
The server can then choose to recode the image for more efficient storage, if necessary.

The advantage of using the string type is simplicity; you can use the built-in serialization mechanism of Hilla's form binder and endpoints.
Please note that this approach is not suitable for larger files.
A streamed upload may be more appropriate.
