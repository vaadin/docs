---
title: Unit vs. End-to-End Testing
description: Describes the differences between UI unit and end-to-end testing in TestBench, as well as the pros and cons of each approach.
order: 10
---

= The Difference between UI Unit Testing and End-to-End Testing in TestBench

TestBench provides two approaches to testing your application: UI unit testing and end-to-end testing.

UI unit testing allows you to write unit tests for your user interfaces without running a browser and the servlet container.
This testing approach speeds up your test runs, making the results less flaky compared to the end-to-end tests.
On the other hand, end-to-end tests are closer to the real-world user experience and can be used to simulate user actions that are not possible with the UI unit tests.

Because they are faster and more stable, UI unit tests are suitable for development workflows where you need to write many tests (perhaps with every commit), and you want to run those tests frequently.
This is the case, for example, with the test-driven development (TDD) approach.
On the other hand, end-to-end tests are more suitable for testing the critical parts of your application, such as the login and the checkout process, to simulate your users' real-life experience with your application.

The following sections describe the relative advantages of the two testing approaches in more detail.

[role="since:com.vaadin:vaadin@V23.2"]
== Advantages of UI Unit Testing

Advantages of UI unit testing over end-to-end testing:

* *Fast*: browser-less tests are typically 100&times; faster than end-to-end tests and run in 5-60 milliseconds, depending on their complexity.
* Reliable: no arbitrary sleeps are needed, as the test is executed on the server side and it can wait until the request is fully processed.
No random failures because of incompatibility between the Selenium drivers used in end-to-end testing and the browser.
* Headless: the tests run headless, as there is no browser.
No need to set up the screen in your CI environment.
* Robust: the test runs in the same JVM as the server-side components.
If the server-side bootstrap fails and throws an exception, the test method fails with the same exception.
No need to go hunting for exceptions in a log located somewhere on a CI server.
* No need to write a massive set of Page Objects.
You are already on the server, and you have access to the actual Java components that are already providing you with high-level APIs, exactly as Page Objects do.
* Full access to the database.
You are on the server side, so you can access the database from your tests in the same way your business logic accesses the database.
You can run a bunch of SQL statements to restore the database to a known state before every test.
Even better, you can run the test in a transaction, then roll back after the test to perform a fast database revert to a known state.

With this technique, you can run 600 UI tests in 7 seconds, as opposed to 1 to 2 hours with the end-to-end testing approach.
Because of the speed, you can let the UI tests run after every commit via your continuous integration server.
Bypassing the browser and talking to the Vaadin server API directly eliminates the need to start the servlet container.
You can add the server `JARs` to the testing classpath and call the Vaadin server API, which, in turn, invokes your server logic.

== Advantages of End-to-End Testing

Though UI unit testing is faster and less flaky, end-to-end testing is still needed in some cases.
Specifically, end-to-end testing is more suitable for testing the critical parts of your application, such as the login and the checkout process, to simulate your users' real-life experience with your application.
Moreover, end-to-end testing enables you to test the client-side functionality of your application, such as JavaScript code or the parts of the UI that are implemented using the Polymer or Lit libraries.
These tests are not possible with the UI unit testing approach because the UI unit tests run on the server side without initializing the browser.


[.discussion-id]
BF046BA3-9165-4BE5-AC1C-171C0E870BAD
