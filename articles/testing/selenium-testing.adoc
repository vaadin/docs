---
title: Selenium Testing
description: Test automation of a Vaadin application using Selenium.
order: 170
---

= Testing Vaadin Apps Using Selenium

Selenium is a popular browser automation library that is often used to automate the testing of web apps.
While it is more convenient to use TestBench, Selenium can be used for testing Vaadin apps as well.

This guide describes:
. The differences between TestBench and Selenium.
. The setup and configuration of Selenium.
. The making of a simple Selenium test.
. The basics of finding and interacting with elements in a Selenium test.
. How a more complex Selenium test can be created.

== Differences Between TestBench and Selenium

TestBench is a framework for testing that is itself based on Selenium.
TestBench, however, is specifically designed for testing Vaadin apps.
Compared to Selenium, TestBench is designed to:

. *Facilitate the handling of Vaadin components.* Unlike Selenium which operates on the DOM of the web page and provides basic methods to interact with elements like "click" or "sendKeys", TestBench provides helper methods to interact with Vaadin components like "select" or "setValue". Moreover, TestBench provides a more convenient way to interact with elements in the shadow DOM of Vaadin components.
. *Take the nature of client-server communication in Vaadin apps into account.* During the course of a test, TestBench will automatically suspend client-side execution if the server is busy and resume it when the server is ready. This makes it possible to write tests in TestBench without the need to explicitly set wait timeouts for various events like page load or waiting for long-running server calls to finish.
. *Provide an easy to use API for conducting screen-comparison tests.*
. *Enable parallel testing of Vaadin apps.*

== Setting Up Selenium

. Add the Selenium library dependency to your project's `pom.xml` file.
+
.`pom.xml`
[source,xml]
----
<!-- Selenium Library -->
<dependency>
   <groupId>org.seleniumhq.selenium</groupId>
   <artifactId>selenium-java</artifactId>
   <version>4.3.0</version>
</dependency>
----
+
The latest version of Selenium can be found https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java[here].

. Use WebDriverManager to manage Web Browser Drivers
+
Using WebDriverManager is the easiest way to manage Drivers because you don't have to download and set up the driver manually by yourself.
+
[loweralpha]
.. Add the WebDriverManager dependency to your project's `pom.xml` file.
+
.`pom.xml`
[source,xml]
----
<!-- Web Driver Management Software -->
<dependency>
   <groupId>io.github.bonigarcia</groupId>
   <artifactId>webdrivermanager</artifactId>
   <version>5.2.1</version>
   <scope>test</scope>
</dependency>
----
+
The latest version of WebDriverManager can be found https://mvnrepository.com/artifact/io.github.bonigarcia/webdrivermanager[here].

.. Import WebDriverManager into your test class.
+
.`SimpleTest.java`
[source,java]
----
import io.github.bonigarcia.wdm.WebDriverManager;
----

.. Call `setup()` on the driver that you would like to use. 
We used the Chrome driver in the code snippet below, but drivers for other browsers can be found at the https://www.selenium.dev/documentation/webdriver/getting_started/install_drivers/#quick-reference[official Selenium guide].
+
.`SimpleTest.java`
[source,java]
----
WebDriverManager.chromedriver().setup();
----
+
[NOTE]
====
.Besides using WebDriverManager, you can also install drivers by:
* https://www.selenium.dev/documentation/webdriver/getting_started/install_drivers/#2-the-path-environment-variable[Adding the driver location to the PATH environment variable].
* https://www.selenium.dev/documentation/webdriver/getting_started/install_drivers/#3-hard-coded-location[Hard-coding the location in your test code].
====

== Create Your First Selenium Test
As a simple example, the code snippet below tests whether the page title is “Hello World”. 

.`SimpleTest.java`
[source,java]
----
import io.github.bonigarcia.wdm.WebDriverManager;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.support.ui.FluentWait;

import java.time.Duration;

public class SimpleTest {

   @Test
   public void checkTitle() {
       WebDriverManager.chromedriver().setup(); // <1>
       var driver = new ChromeDriver(); // <2>
       driver.get("http://localhost:8080/hello"); // <3>
       
       new FluentWait<WebDriver>(driver)
               .withTimeout(Duration.ofSeconds(30))
               .pollingEvery(Duration.ofSeconds(1))
               .ignoring(NoSuchElementException.class)
               .until(_driver -> !_driver.getTitle().isEmpty()); // <4>

       var title = driver.getTitle(); // <5>
       Assertions.assertEquals("Hello World", title); // <6>
       driver.quit(); // <7>
   }
}
----
<1> Setup the driver for the test.
<2> Instantiates the [classname]`ChromeDriver`, which will be used to interact with the Chrome web browser.
<3> Directs the [classname]`ChromeDriver` to load the URL.
<4> Because Flow produces a single-page frontend, Selenium is not aware of DOM manipulation after the initial page has been loaded, so we had to use Selenium's https://www.selenium.dev/documentation/webdriver/waits/#fluentwait[FluentWait] API to wait until the DOM has been _compiled_.
<5> After we are sure that the page title is available, we retrieve the page title.
<6> We check whether the page title is "Hello World".
<7> It is important that we close the browser session after the test.

== Finding and Interacting With Elements

You can also test the web browser's URL after a navigation action. 

.`SimpleTest.java`
[source,java]
----
@Test
public void routeSwitch(){
  //Set up the web driver
  WebDriverManager.chromedriver().setup();

  //Use this ChromeDriver to interact with Chrome
  var driver = new ChromeDriver();

  //Loads the page
  driver.get("http://localhost:8080");

  //Have to explicitly wait because it takes time for compiled html to load
  new FluentWait<WebDriver>(driver)
          .withTimeout(Duration.ofSeconds(30))
          .pollingEvery(Duration.ofSeconds(1))
          .ignoring(NoSuchElementException.class)
          .until(_driver -> !_driver.getTitle().isEmpty());

  //Clicks on the About button
  driver.findElement(By.linkText("About")) <1>
      .click(); <2>
  
  new FluentWait<WebDriver>(driver)
          .withTimeout(Duration.ofSeconds(30))
          .pollingEvery(Duration.ofSeconds(1))
          .ignoring(NoSuchElementException.class)
          .until(_driver -> driver.getTitle().equals("About")); // <3>

  var url = driver.getCurrentUrl(); // <4>

  //Checks whether the url matches
  assertEquals("http://localhost:8080/about", url);
  
  //Ends the browser session
  driver.quit();
}
----
<1> You can find elements using https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/By.html[[classname]`By`] matchers.
<2> We call `click()` to click on the https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/WebElement.html[[classname]`WebElement`].
<2> We wait for the "About" page to load first before attempting to get the URL. This reduces flakiness.
<3> We use the convenient method to get the full current URL.

== Advanced Selenium Test

The test below demonstrates how to use advanced [classname]`By` matchers such as `id()` and `xpath()`.

.`SimpleTest.java`
[source,java]
----
@Test
public void addUser(){
  //Set up the web driver
  WebDriverManager.chromedriver().setup();

  //Use this ChromeDriver to interact with Chrome
  var driver = new ChromeDriver();

  //Loads the page
  driver.get("http://localhost:8080/master-detail");

  //Have to explicitly wait because it takes time for compiled html to load
  new FluentWait<WebDriver>(driver)
          .withTimeout(Duration.ofSeconds(30))
          .pollingEvery(Duration.ofSeconds(1))
          .ignoring(NoSuchElementException.class)
          .until(_driver -> !_driver.getTitle().isEmpty());

  //Test data
  var firstName = "FirstName";
  var lastName = "LastName";
  var email = "first.last@example.com";
  var phone = "(111) 111-1111";
  //Cannot use simple String because the form and table display the dob differently
  var dob = LocalDate.of(2000, Month.JANUARY, 1);
  var occupation = "Forester";

  //Adds First Name
  var firstNameTextInput = driver.findElement(By.id("vaadin-text-field-0")); // <1>
  firstNameTextInput.click(); // <2>
  firstNameTextInput.sendKeys(firstName); // <3>

  //Adds Last Name
  var lastNameTextInput = driver.findElement(By.id("vaadin-text-field-1"));
  lastNameTextInput.click();
  lastNameTextInput.sendKeys(lastName);

  //Adds Email
  var emailTextInput = driver.findElement(By.id("vaadin-text-field-2"));
  emailTextInput.click();
  emailTextInput.sendKeys(email);

  //Adds Phone
  var phoneTextInput = driver.findElement(By.id("vaadin-text-field-3"));
  phoneTextInput.click();
  phoneTextInput.sendKeys(phone);

  //Adds DOB
  var dobTextInput = driver.findElement(By.id("vaadin-date-picker-4"));
  dobTextInput.click();
  dobTextInput.sendKeys(DateTimeFormatter.ofPattern("dd/MM/uuuu").format(dob));
  dobTextInput.sendKeys(Keys.ENTER); //Closes the pop-up Date Picker

  //Adds Occupation
  var occupationTextInput = driver.findElement(By.id("vaadin-text-field-5"));
  occupationTextInput.click();
  occupationTextInput.sendKeys(occupation);

  //Marks as Important
  driver.findElement(By.id("vaadin-checkbox-6"))
          .click();

  //Clicks Save
  driver.findElement(By.xpath("//vaadin-button[contains(.,'Save')]")).click();

  //Sorts by Phone number so the sample user is visible on the screen
  driver.findElement(By.xpath("//vaadin-grid-sorter[contains(.,'Phone')]")).click();

  //Reduces verbosity
  var xPathStart = "//vaadin-grid-cell-content[contains(.,'";
  var xPathEnd = "')]";

  //Waits for the page to sort
  new FluentWait<WebDriver>(driver)
          .withTimeout(Duration.ofSeconds(30))
          .pollingEvery(Duration.ofSeconds(1))
          .ignoring(NoSuchElementException.class)
          .until(_driver -> _driver.findElement(By.xpath(xPathStart + firstName + xPathEnd)).isDisplayed());

  //Gets the cells in the table for the newly added user
  var firstNameCell = driver.findElement(By.xpath(xPathStart + firstName + xPathEnd)); // <4>
  var lastNameCell = driver.findElement(By.xpath(xPathStart + lastName + xPathEnd));
  var emailCell = driver.findElement(By.xpath(xPathStart + email + xPathEnd));
  var phoneCell = driver.findElement(By.xpath(xPathStart + phone + xPathEnd));
  var dobCell = driver.findElement(By.xpath(xPathStart + dob + xPathEnd));
  var occupationCell = driver.findElement(By.xpath(xPathStart + occupation + xPathEnd));

  // <5>
  assertEquals(firstName, firstNameCell.getText());
  assertEquals(lastName, lastNameCell.getText());
  assertEquals(email, emailCell.getText());
  assertEquals(phone, phoneCell.getText());
  assertEquals(dob.toString(), dobCell.getText());
  assertEquals(occupation, occupationCell.getText());
  
  //Ends the browser session
  driver.quit();
}
----
<1> We can use the `By.id()` matcher to find fields with a unique `id`. You can retrieve the `id` using your browser's inspector.
<2> We must click on the field to simulate real behavior of an end user.
<3> You can send key strokes using the `sendKeys()` method.
<4> For elements that dont have an `id`, you can use https://developer.mozilla.org/en-US/docs/Web/XPath[xpath expression] to find the element. The xpath can be generated by the https://www.selenium.dev/selenium-ide/[Selenium IDE].
<5> Finally, we test whether all of the information in the table cells match our original data.

For more usage scenarios, you can check out the official https://www.selenium.dev/documentation/webdriver/elements/[Selenium doc]
