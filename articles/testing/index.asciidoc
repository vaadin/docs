---
title: Testing
order: 170
---

[[testbench.uiunit]]
= [since:com.vaadin:vaadin@V23.2]#Browser-Less and Browser-Based Testing#

== Browser-Less Unit Testing

UI unit testing removes the necessity to run both the browser and the servlet container, to test your Vaadin-based applications faster.

- Container-less testing: You do not need to launch the servlet container.
UI unit testing creates the Vaadin Session, the UI and other necessary Vaadin classes straight in the JVM that runs your JUnit tests.
- Browser-less testing: You look up components straight from [methodname]`UI.getCurrent()`, bypassing the browser and the JavaScript->server bridge.
You call methods directly on your server-side view classes and on the server-side Java Vaadin components.

[[testbench.uiunit.why-unit-testing]]
=== Why Unit Testing?

Advantages of unit testing over end-to-end testing with TestBench:

* Fast: browser-less tests are typically 100&times; faster than Selenium-based tests and run in 5-60 milliseconds, depending on their complexity.
* Reliable: no arbitrary sleeps are needed, as the test is executed on the server side and it can wait until the request is fully processed.
No random failures because of incompatibility between the Selenium drivers and the browser.
* Headless: the tests run headless, as there is no browser.
No need to set up the screen in your CI environment.
* Robust: the test runs in the same JVM as the server-side components.
If the server-side bootstrap fails and throws an exception, the test method fails with the same exception.
No need to go hunting for exceptions in a log located somewhere on a CI server.
* No need to write a massive set of Page Objects.
You are already on the server, and you have access to the actual Java components that are already providing you with high-level APIs, exactly as Page Objects do.
* Full access to the database.
You are on the server side, so you can access the database from your tests in the same way your business logic accesses the database.
You can run a bunch of SQL statements to restore the database to a known state before every test.
Even better, you can run the test in a transaction, then roll back after the test to perform a fast database revert to a known state.

With this technique, you can run 600 UI tests in 7 seconds, as opposed to 1 to 2 hours with a Selenium-based approach.
Because of the speed, you can let the UI tests run after every commit via your continuous integration server.
Bypassing the browser and talking to the Vaadin server API directly eliminates the need to start the servlet container.
You can add the server `JARs` to the testing classpath and call the Vaadin server API, which, in turn, invokes your server logic.

[[testbench.uiunit.limitations]]
=== Limitations

UI unit testing is designed to bypass the browser and the servlet container.
This means that it is impossible to test JavaScript code, templates, and other client-side functionalities.
If you need to test client-side features, you need to use browser-based integration tests with TestBench.


[[testbench.overview]]
== Browser-Based Testing

 Testing Using TestBench

:commercial-feature: TestBench
include::{articles}/_commercial-banner.asciidoc[opts=optional]

Vaadin TestBench is a tool for creating and running browser-based integration tests for your Vaadin application.
TestBench simulates a user of your application, performs the tasks specified using Java code, and verifies that the expected actions take place in the application.

TestBench can also visually inspect your application and detect unintentionally introduced changes, and verify that the application is visually OK in all the browsers you are testing with.
TestBench also includes special support for other Vaadin products, making testing easy and robust compared to generic web testing solutions.

Although it is not the main purpose of TestBench, you can also use TestBench to automate mundane tasks such as filling out forms.

=== Features

The main features of Vaadin TestBench are:

* Control one or several browser instances from Java, both desktop and mobile browsers
* A powerful and robust way to describe your tests, so that they do not break with application changes
* A high-level API for finding the component you want to interact with
* Vaadin Component API for easy interaction with all <<{articles}/components#, Vaadin components>> and HTML elements
* Automatic screen comparison, highlighting differences
* Assertion-based UI state validation
* Easily run tests in parallel
* Test grid support to speed up tests by running in parallel on multiple browsers on selected operating systems
* Support for JUnit and other testing frameworks
* All features available in Selenium

== Topics

section_outline::[]
