---
title: Walking Skeleton
page-title: Walk-through of the Vaadin Walking Skeleton
description: TODO Write a description
meta-description: TODO Write a meta-description
order: 50
---

// TODO Do we need a guide for importing the project into your IDE, or is that outside the context?
// TODO This page contains a lot of links to guides and deep dives. Should they be added to the Next Steps page instead to make the page more readable?

= Meet Your Walking Skeleton
:toclevels: 2

<<import#,Open>> your newly generated <<start#,walking skeleton>> in your Java IDE. The walking skeleton is a single-module Maven project. For Maven newcomers, see the link:https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html[Maven in 5 Minutes] tutorial before proceeding.

The most important files and directories in your skeleton are the following:

[source]
----
my-application/
├── src/
│   ├── main/
│   │   ├── frontend/      <1>
│   │   │   └── ...     
│   │   ├── java/          <2>
│   │   │   └── ...     
│   │   └── resources/     <3>
│   │   │   └── ...     
│   └── test/
│       └── java/          <4>
│           └── ...     
└── pom.xml                <5>
----
<1> Frontend files, such as CSS and TypeScript files.
<2> Java source files.
<3> Configuration files and other files needed by the application.
<4> Java test files.
<5> Maven POM-file for your application.

To make building easier, the skeleton includes the link:https://maven.apache.org/wrapper/[Maven Wrapper]. Because of this, you don't have to install Maven on your computer. Instead, you can use the `mvnw` (macOS and Linux) or `mvnw.cmd` (Windows) scripts to run Maven on the command line.

The skeleton includes a `.gitignore` file optimized for Vaadin projects, and configuration files for the link:https://github.com/diffplug/spotless[Spotless] code formatter. The code formatter is needed when you generate code with <<{articles}/tools/copilot#,Vaadin Copilot>>, since it does not format the code itself.

The `LICENCE.md` file is a placeholder for your application's licence. Replace with your own license, or delete if you don't need it.

Next, you'll have a closer look at the Java files, the frontend files, and the POM-file.


== Java Files

A walking skeleton always contains the following Java files, regardless of whether you chose to generate a Flow view or a React view:

[source]
----
src
├── main/java
│   ├── com.example.application
│   │   ├── base                           <1>
│   │   │   └── domain
│   │   │       └── AbstractEntity.java
│   │   └── greeting                       <2>
│   │       ├── domain
│   │       │   ├── Greeting.java
│   │       │   └── GreetingRepository.java
│   │       └── service
│   │           └── GreetingService.java
│   └── Application.java                   <3>
│
└── test/java
    └── com.example.application
        ├── greeting
        │   └── service
        │       └── GreetingServiceIT.java <4>
        └── ArchitectureTest.java          <5>
----
<1> The `base` feature package.
<2> The `greeting` feature package.
<3> Main entry point into the application.
<4> Example integration test for the `GreetingService`.
<5> ArchUnit architecture test for the entire application.

If you generated a Flow view, the project contains more Java files. You'll learn about those later.

The main entry point into the application is `Application.java`. This class contains the `main()` method that start up the Spring Boot application.

The skeleton uses feature-based package naming, and has two feature packages: `base`, and `greeting`. The `base` package contains classes that are intended to be re-used, either through composition or extension. The `greeting` package is an example feature that you'll want to delete from your project once you've created your first real feature. 
//For more information about feature-based package naming, see the <<{articles}/building-apps/deep-dives/project-structure#,Project Structure>> deep dive.

You'll find `package-info.java` files in every package. These files add the `@NullMarked` annotation from link:https://jspecify.dev[JSpecify] to each package. This instructs static analysis tools that every return value and method parameter can never be `null` unless explicitly stated with a `@Nullable` annotation. This is a good practice that reduces bugs caused by `NullPointerException`.

`ArchitectureTest.java` is an link:https://www.archunit.org[ArchUnit] test that guards against unintentional dependencies between classes. As your application grows, it helps keep your code base in shape. 
//For more information about testing the architecture, see the <<{articles}/building-apps/testing/archunit#,Test the Architecture>> guide.


=== The Greeting Feature

The `greeting` feature consists of a JPA entity, a Spring Data JPA repository interface, and an application service.

The repository stores and fetches entities from a relational database. The skeleton uses an in-memory H2 database. This is useful for prototyping, but soon you'll want to replace it with something else. 
//The <<{articles}/building-apps/persistence/replace-h2#,Replace H2 with PostgreSQL>> guide shows you how to do this. For more information about persistence in Vaadin applications, see the <<{articles}/building-apps/deep-dives/persistence#,Persistence in Vaadin applications>> deep dive.

The application service acts as the API of the feature and is the boundary between the _presentation layer_ and the _application layer_. Its main purpose in the skeleton is to show how an application service interacts with the domain model in a Vaadin application. 
//See the <<{articles}/building-apps/deep-dives/architecture/layers#,Conceptual Layers>> deep dive for more information about the presentation and application layers.

The greeting service has a sample integration test. It starts up the application and its embedded H2 database, and checks that the service works as expected. Its main purpose in the skeleton is to show how to write integration tests for application services.


=== Flow Views

If you generated a Flow view, you'll find some extra Java files in the skeleton:

[source]
----
src
└── main/java
    └── com.example.application
        ├── base
        │   └── ui
        │       ├── component
        │       │   └── ViewToolbar.java
        │       └── view
        │           ├── MainErrorHandler.java
        │           └── MainLayout.java
        └── greeting
            └── ui
                └── view
                    └── GreetingView.java 
----

The `base` feature package contains one user interface package with two sub-packages: `component` and `view`.

The `component` package contains custom UI components that can be reused throughout the entire application. The skeleton only contains one, but as your application grows, you'll add more components to this package.

The `view` package contains view-related classes that cut across multiple views in multiple features. The skeleton contains an error handler, and a main layout.

The error handler receives all exceptions that reach the user interface, logs them, and shows an error notification to the user. You'll want to customize this as the application grows. 
//For more information about error handling, see the <<{articles}/building-apps/views/handle-errors#,Handle Errors>> guide.

Your application shows all the views inside the main layout by default. It contains the application's name, a navigation menu, and a mock user menu that doesn't do anything. You'll want to at least change the application name, and either remove or  implement the user menu. 
//The <<{articles}/building-apps/security/add-user-menu#,Add a User Menu>> guide shows you how to do this. If you are interested in learning more about the main layout itself, see the <<{articles}/building-apps/views/add-router-layout#,Add a Router Layout>> guide.

The `greeting` feature package contains one UI-related package. It contains the view that allows users to create and list greetings.
//If you want to add a new view to your application, see the <<{articles}/building-apps/views/add-view#,Add a View>> guide.


== Frontend Files

A walking skeleton always contains the following frontend files, regardless of whether you chose to generate a Flow view or a React view:

[source]
----
src
└── main/frontend
    └── themes
        └── default
            ├── styles.css
            └── theme.json
----

This is an empty theme called `default`, based on the Lumo theme. It is activated in the `Application` class, using the `@Theme` annotation. 
//For more information about themes, see the <<{articles}/building-apps/styling/add-theme#,Add a Theme>> guide.

If you've started up your application, you'll see some auto-generated files in the `frontend` directory as well. You'll find an `index.html` file, and a `generated` directory. You don't have to touch these for now.


=== React Views

If you generated a React view, you'll find more frontend files in the skeleton:

[source]
----
src
└── main/frontend
    ├── components
    │   └── ViewToolbar.tsx
    └── views
        ├── @index.tsx
        ├── @layout.tsx
        └── _ErrorHandler.ts
----

The `components` directory contains custom UI components that can be reused throughout the entire application. The skeleton only contains one, but as your application grows, you'll add more components to this directory.

The `views` directory contains an example view, a main layout, and an error handler. The file names in this directory all have special meaning. You'll learn about it later.

The example view - `@index.tsx` - allows users to add and list greetings. 
//If you want to add a new view to your application, see the <<{articles}/building-apps/views/add-view#,Add a View>> guide.

Your application shows all the views inside the main layout - `@layout.tsx` - by default. It contains the application's name, a navigation menu, and a mock user menu that doesn't do anything. You'll want to at least change the application name, and either remove or implement the user menu.
//The <<{articles}/building-apps/security/add-user-menu#,Add a User Menu>> guide shows you how to do this. If you are interested in learning more about the main layout itself, see the <<{articles}/building-apps/views/add-router-layout#,Add a Router Layout>> guide.

The error handler is a TypeScript function that logs the error to the console and shows a notification to the user. The error handler is _not_ a link:https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary[React error boundary]. It is designed to handle errors that occur when calling application services. Because of this, you have to manually catch the errors you want to handle, and call the error handler. The example view shows you how to do this.
//For more information about error handling, see the <<{articles}/building-apps/views/handle-errors#,Handle Errors>> guide.


== The POM File

The POM file is a typical Spring Boot, single-module Maven project file. It uses the `spring-boot-starter-parent`, so all the Spring Boot dependencies are available for use. It also brings in the Vaadin dependencies, and ArchUnit.

The `spring-boot-maven-plugin` is used to package the application into a single, executable JAR file.

The `spotless-maven-plugin` is used to format the Java and TypeScript source files.

The `vaadin-maven-plugin` is used to prepare and build the frontend files. Under the hood it is using link:https://www.npmjs.com/[npm] and link:https://vite.dev/[Vite].

The POM file defines two build profiles: `production`, and `integration-test`. 

The `production` profile triggers a production build, and is deactivated by default. You'll learn more about making a production build on the <<build#,Build Your Walking Skeleton>> page.

The `integration-test` profile runs integration tests during the `verify` phase, and is deactivated by default. 
//You'll learn more about this in the <<{articles}/building-apps/testing#,Testing>> guides.

//For more information about structuring Vaadin projects, see the <<{articles}/building-apps/deep-dives/project-structure#,Project Structure>> deep dive.