---
title: Basics Tutorial
order: 30
layout: page
page-title: "Hilla Basics Tutorial"
description: "Learn the basics of Hilla: creating a project, accessing endpoints, building views, and deploying"
---

[[fusion.tutorial]]
= Hilla Basics Tutorial

pass:[<!-- vale Google.Will = NO -->]

This tutorial teaches you the core concepts of Hilla while you build a full-stack application for managing to-do items.
After completing the tutorial, you are ready to start experimenting on your own or continue to more advanced tutorials.

pass:[<!-- vale Google.Will = YES -->]

== What You Need

- About 10 minutes
- https://nodejs.org/[Node^] 16.14 or higher
- JDK 11 or higher (For example, https://adoptium.net/[Eclipse Temurin JDK^]).

https://code.visualstudio.com/[Visual Studio Code] is used in this tutorial.
See the https://youtu.be/G_aJONwi0qo[setup instructions] on YouTube.
You can use any IDE that supports Java and TypeScript development.

== Create a Hilla Project

Use the Vaadin CLI to create a new project:

[source,terminal]
----
npx @vaadin/cli init --preset hilla-tutorial hilla-todo
----

The pre-configured starter project includes:

- An empty `Todo` view
- H2 database and Spring Data JPA dependencies

== Importing the Hilla Project Into VS Code

Unzip the downloaded file and open the project in your IDE.
The instructions in this tutorial assume you use https://code.visualstudio.com/[VS Code].

Open the project by either:

- navigating to the project folder and running `code .` (note the period), or

- choosing **File > Open...** in VS Code and selecting the _project folder_.

We recommend installing the following plugins in VS Code for an optimal development experience:

* https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack^]
* https://marketplace.visualstudio.com/items?itemName=runem.lit-plugin[lit-plugin^]
* https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-spring-boot[Spring Boot Tools^]

VS Code should automatically suggest these for you when you open the project.

=== Project Structure and Architecture

Hilla projects are based on https://spring.io/projects/spring-boot[Spring Boot^] and use https://maven.apache.org/[Maven^] for project management.

.Hilla project structure
image::../images/basics-project-structure.png[Project Structure,width=250]

The two important folders be aware of are:

`frontend`::
This is where your views and frontend code live.

`src`::
This is where your Java backend code lives.

The key files in a Hilla application are:

`pom.xml`::
The project configuration file, which defines dependencies.

`frontend/index.html`::
The bootstrap page.
You do not usually need to change this.

`frontend/index.ts`::
Defines routing.

`src/main/java/com/example/application/Application.java`::
Runs the Spring Boot application.

== Defining the Data Model and Service Layer

Begin by setting up the data model and services for accessing the database.

You can do this in two steps:

. Define an entity.
. Create a repository for accessing the database.

This tutorial shows how to use an in-memory H2 database and JPA for persistence.
The starter you downloaded already includes the needed dependencies in [filename]#pom.xml#.

Define a JPA _entity_ class for the data model, by creating a new file, [filename]#Todo.java#, in `src/main/java/com/example/application` with the following content:

.`Todo.java`
[source,java]
----
package com.example.application;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.validation.constraints.NotBlank;

@Entity // <1>
public class Todo {

  @Id
  @GeneratedValue
  private Integer id;

  private boolean done = false;
  @NotBlank // <2>
  private String task;

  public Todo() {}

  public Todo(String task) {
    this.task = task;
  }

  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }

  public boolean isDone() {
    return done;
  }

  public void setDone(boolean done) {
    this.done = done;
  }

  public String getTask() {
    return task;
  }

  public void setTask(String task) {
    this.task = task;
  }
}
----
<1> Turn the class into a JPA entity with an `@Entity` annotation.
<2> Add a `@NotBlank` Java bean validation annotation to enforce validity both in the view and on the server.

Next, create a _repository_ for accessing the database.
You only need to provide an interface with type information; Spring Data takes care of the implementation.

Create a new file, [filename]#TodoRepository.java#, in `src/main/java/com/example/application`, with the following contents:

.`TodoRepository.java`
[source,java]
----
package com.example.application;

import org.springframework.data.jpa.repository.JpaRepository;

public interface TodoRepository extends JpaRepository<Todo, Integer> {

}
----

You now have all the necessary backend code in place to start building a UI.

Run the project from the command line with the following command:

[source,terminal]
----
./mvnw
----

**The first time you run the application, it may take up to a few minutes**, as Hilla downloads all the dependencies and builds a frontend bundle.
Subsequent builds do not download dependencies, so that they are much faster.

When the build has finished, you should see the application running on http://localhost:8080.

image::../images/basics-running-1.png[Running project]


== Create a Typed Server Endpoint

One of the key features of Hilla is type-safe server access through _endpoints_.
When you define an `@Endpoint`, Hilla creates the needed REST-like endpoints, secures them, and generates TypeScript interfaces for all the data types and public methods used.
Having full-stack type safety helps you stay productive through autocomplete and helps guard against accidentally breaking the UI when the data model changes on the server.

Create a new file, [filename]#TodoEndpoint.java#, in `src/main/java/com/example/application`:

.`TodoEndpoint.java`
[source,java]
----
package com.example.application;

import java.util.List;

import com.vaadin.flow.server.auth.AnonymousAllowed;
import dev.hilla.Endpoint;
import dev.hilla.Nonnull;


@Endpoint // <1>
@AnonymousAllowed // <2>
public class TodoEndpoint {
 private TodoRepository repository;

 public TodoEndpoint(TodoRepository repository) { // <3>
   this.repository = repository;
 }

 public @Nonnull List<@Nonnull Todo> findAll() { // <4>
   return repository.findAll();
 }

 public Todo save(Todo todo) {
   return repository.save(todo);
 }
}
----
<1> Annotating a class with `@Endpoint` exposes it as a service for client-side views.
All *public* methods of an endpoint are callable from TypeScript.
<2> By default, endpoint access requires an authenticated user. `@AnonymousAllowed` enables access for anyone.
See <<../security/configuring#,Configuring Security>> for more information on endpoint security.
<3> Use Spring to automatically inject the `TodoRepository` dependency for database access.
<4> Using the `@Nonnull` annotation ensures that the TypeScript generator does not interpret these values as possibly `undefined`.

Save the file and ensure the change is loaded.
You should see log output from the reload in the console.
It should end with the message, `Frontend compiled successfully`.

If you did not have the server running, or if something failed, (re)start the server with the `mvn` command.

== Building the Todo View Component

Hilla uses the https://lit.dev/[Lit] library for client-side views.
Lit is a lightweight and highly performant library for building reactive components with declarative templates.

You can learn the basics of Lit in the article <<../application/lit#, Lit basics>>.

Next, create a view for adding and viewing to-do items.

Open [filename]#frontend/views/todo/todo-view.ts# and replace its contents with the following:

[source,typescript]
----
import { html } from 'lit';
import { customElement, state } from 'lit/decorators.js';
// <1>
import '@vaadin/vaadin-text-field';
import '@vaadin/vaadin-button';
import '@vaadin/vaadin-checkbox';
import { Binder, field } from '@hilla/form';
import Todo from 'Frontend/generated/com/example/application/Todo';
import TodoModel from 'Frontend/generated/com/example/application/TodoModel';
import { TodoEndpoint } from 'Frontend/generated/endpoints';
import { View } from '../view';


@customElement('todo-view') // <2>
export class TodoView extends View { // <3>
}
----
<1> Import the UI components, helpers, and generated TypeScript models required for building the view.
<2> Register the new component with the browser.
This makes it available as `<todo-view>`.
The routing in [filename]#index.ts# is already set up to show it when you navigate to the application.
<3> Define the component class that extends from [classname]#View#.

=== Defining the View State

Inside the [classname]#TodoView# class, define the view state as follows:

[source,typescript]
----
 @state()
 private todos: Todo[] = []; // <1>
 private binder = new Binder(this, TodoModel); // <2>
----
<1> The list of [classname]#Todo# items is private and decorated with `@state()`, so Lit observes it for changes.
<2> A Hilla [classname]#Binder# is used to handle the form state for creating new [classname]#Todo# objects.
[classname]#TodoModel# is automatically generated by Hilla.
This describes the data types and validations that [classname]#Binder# needs.
Read more about forms in <<../data-binding/binder#,Binding Data to Forms>>.

=== Defining CSS

Define some padding on the view.
Web Components have a default `display` value of `inline`, which is rarely what you want.
Set it to `block` instead.
You can define styles in the [filename]#themes/hilla-todo/styles.css# file.
Read more about CSS in <<../css/styling-with-css#,Styling With CSS>>.

.`themes/hilla-todo/styles.css`
[source,css]
----
 todo-view {
  display: block;
  padding: var(--lumo-space-m) var(--lumo-space-l); /* <1> */
}
----
<1> The `padding` property is defined using the https://vaadin.com/docs/ds/foundation/size-space#space[spacing properties] to be consistent with the rest of the app.

=== Defining the HTML Template

Define a [methodname]#render()# method that returns an `html` template literal inside the class.

[source,typescript]
----
render() {
 return html`

 `;
}
----

Add the following code within the `html` template:

[source,typescript]
----
return html`
   <div class='form'>
    <vaadin-text-field
      ${field(this.binder.model.task)}
    ></vaadin-text-field> <!--1-->
    <vaadin-button
      theme='primary'
      @click=${this.createTodo /* <2> */}
      ?disabled=${this.binder.invalid /* <3> */}
      >Add</vaadin-button>
   </div>
`;
----
<1> The Text Field component is bound to the `task` property of a [classname]#Todo# using `${field(this.binder.model.task)}`.
You can read more about forms in <<../data-binding/binder#,Binding Data to Forms>>.
<2> The click event of the *Add* button is bound to the [methodname]#createTodo()# method.
<3> The button is disabled if the form is invalid.

Right underneath the previous `<div>`, add the following code:

[source,typescript]
----
return html`
   <div class="todos">
    ${this.todos.map((todo) => html` <!--1-->
        <div class="todo">
          <vaadin-checkbox
            ?checked=${todo.done /* <2> */}
            @checked-changed=${(e: CustomEvent) => // <3>
              this.updateTodoState(todo, e.detail.value)}
          ></vaadin-checkbox>
          <span>${todo.task}</span>
        </div>
      `)}
   </div>
`;
----
<1> The existing `todo` items are shown by mapping the `todos` array to Lit templates.
The template for a single [classname]#Todo# contains a checkbox and the task text.
<2> Bind the `checked` boolean attribute to the `done` property on the `todo`.
<3> Call the [methodname]#updateTodoState()# method, with the `todo` and the new value, whenever the checked value changes.

=== Updating the View State and Calling the Backend

Below the [methodname]#render()# method in the [classname]#TodoView# class, add a [methodname]#connectedCallback()# https://lit.dev/docs/components/lifecycle/[lifecycle callback] to initialize the view when it is attached to the DOM.

[source,typescript]
----
async connectedCallback() { // <1>
 super.connectedCallback(); // <2>
 this.todos = await TodoEndpoint.findAll(); // <3>
}
----
<1> Use an https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function[async function] to make it easier to handle asynchronous code.
<2> Remember to call the superclass method.
<3> The [methodname]#getTodos()# method is automatically generated by Hilla based on the method in [filename]#TodosEndpoint.java#.
The method was imported in the head of the file.
The `await` keyword waits for the server response without blocking the UI.

Below the [methodname]#connectedCallback()#, add another method to handle the creation of a new [classname]#Todo#.

[source,typescript]
----
async createTodo() {
 const createdTodo = await this.binder.submitTo(TodoEndpoint.save); // <1>
 if (createdTodo) {
   this.todos = [...this.todos, createdTodo]; // <3>
   this.binder.clear(); // <3>
 }
}
----
<1> Use `binder` to submit the form to [classname]#TodoEndpoint#.
The [classname]#Binder# validates the input before posting it, and the server revalidates it.
<2> Update the state with a new array that includes the saved [classname]#Todo#.
This re-renders the view.
<3> Clear the form input.

Finally, add a method for updating the `todo` state right below [methodname]#createTodo()#:

[source,typescript]
----
updateTodoState(todo: Todo, done: boolean) {
 todo.done = done;
 const updatedTodo = { ...todo }; // <1>
 this.todos = this.todos.map((t) => (t.id === todo.id ? updatedTodo : t)); // <2>
 TodoEndpoint.save(updatedTodo); // <3>
}
----
<1> Create a new [classname]#Todo# with the updated `done` state.
<2> Update the local `todos` array with the new state.
The `map` operator creates a new array where the changed `todo` is swapped out.
This re-renders the view.
<3> Save the updated `todo` to the server.

=== Complete View Code

The completed view code is as follows:

.`todo-view.ts`
[source,typescript]
----
import { html } from 'lit';

import { customElement, state } from 'lit/decorators.js';

import '@vaadin/vaadin-text-field';
import '@vaadin/vaadin-button';
import '@vaadin/vaadin-checkbox';
import { Binder, field } from '@hilla/form';
import Todo from 'Frontend/generated/com/example/application/Todo';
import TodoModel from 'Frontend/generated/com/example/application/TodoModel';
import { TodoEndpoint } from 'Frontend/generated/endpoints';
import { View } from '../view';


@customElement('todo-view')
export class TodoView extends View {
  @state()
  private todos: Todo[] = [];
  private binder = new Binder(this, TodoModel);

  render() {
    return html`
      <div class="form">
        <vaadin-text-field ${field(this.binder.model.task)}></vaadin-text-field>
        <vaadin-button theme="primary" @click=${this.createTodo} ?disabled=${this.binder.invalid}>
          Add
          </vaadin-button>
      </div>
      <div class="todos">
        ${this.todos.map(
          (todo) => html`
            <div class="todo">
              <vaadin-checkbox
                ?checked=${todo.done}
                @checked-changed=${(e: CustomEvent) => this.updateTodoState(todo, e.detail.value)}></vaadin-checkbox>
              <span>${todo.task}</span>
            </div>
        `)}
      </div>
    `;
  }

  async connectedCallback() {
    super.connectedCallback();
    this.todos = await TodoEndpoint.findAll();
  }

  async createTodo() {
    const createdTodo = await this.binder.submitTo(TodoEndpoint.save);
    if (createdTodo) {
      this.todos = [...this.todos, createdTodo];
      this.binder.clear();
    }
  }

  updateTodoState(todo: Todo, done: boolean) {
    todo.done = done;
    const updatedTodo = { ...todo };
    this.todos = this.todos.map((t) => (t.id === todo.id ? updatedTodo : t));
    TodoEndpoint.save(updatedTodo);
  }
}
----

=== Run the Completed Application

Start your server with the `./mvnw` command if you do not already have it running.

Open http://localhost:8080 in your browser.
You should now have a fully functional to-do application.
Notice that when you refresh the browser, it keeps the same `todo` items, as they are persisted in the database.

image::../images/basics-running-2.png[Running project]

== Optional: Deploy the Application to Heroku

The following steps are optional.
You can follow them to deploy your application to https://www.heroku.com/[Heroku], a cloud deployment platform that offers a free tier that does not require a credit card.

include::_heroku-steps.adoc[leveloffset=+1]

== Next Steps and Helpful Links

pass:[<!-- vale Google.Exclamation = NO -->]

Congratulations on finishing the tutorial!

pass:[<!-- vale Google.Exclamation = YES -->]

The following are some helpful links for you to continue your learning:

- https://github.com/vaadin/hilla-basics-tutorial[GitHub repository for the completed project source code].

- <<in-depth-course#, An in-depth course covering navigation, forms, state management, security, and offline use>>.

- <<../routing#, Learn to add more views to your app>>.

- <<../data-binding#,Data Binding>>.

- https://vaadin.com/docs/ds/components[Browse all Vaadin components and their APIs].

If you get stuck or need help, please reach out to the https://discord.gg/vaadin[Hilla Community on Discord].
