---
title: Observability Kit Agent
order: 1
---

= Observability Kit Agent

The Observability Kit Agent is a custom Java agent based on the OpenTelemetry standard, with preconfigured instrumentation for Vaadin Flow applications.

[NOTE]
A Java agent is a special set of classes which, by using the https://docs.oracle.com/javase/1.5.0/docs/api/java/lang/instrument/package-summary.html[Java Instrumentation API], can intercept applications running on the JVM and inject code to provide additional functionality.

https://opentelemetry.io/[OpenTelemetry] is an emerging standard for generating, collecting and exporting telemetry data, such as traces, metrics and logs.
As an industry-wide standard it is https://opentelemetry.io/vendors/[supported by a number of tools and vendors]. We have tested and support xref:../integrations/index.asciidoc#[integrations] with a specific selection of vendors, but the agent should work with any vendor that supports the OpenTelemetry standard.

[NOTE]
OpenTelemetry is still a relatively new standard, which means support from specific vendors may still be limited or incomplete.

Observability Kit builds on the automatic instrumentation provided by OpenTelemetry by implementing instrumentation on Vaadin-specific classes.
This provides a lot of framework-specific details that can be used to identify issues, track performance or observe user behavior.

== Traces

The agent creates traces for all Flow-specific requests against the application and spans for framework-specific operations.
It also adds span attributes that can be used to filter traces / spans, or to inspect additional details about an operation.

The following sections list the most relevant traces / spans created by the agent, as well as their attributes.

=== UI Requests

Creates a trace for every request that is related to a UI, using the current view's route template as name.

Example: `/products/:productId`

=== Static File Requests
Creates a trace for all static files that are served, using the file path as name.

Example: `/static/image.png`

=== Dynamic Stream Requests
Creates a trace for all dynamic content streamed from a `StreamResource`, using the resources' name.

Example: `/dynamic/[ui]/[secret]/export.csv`

=== Navigation
Creates a nested span whenever a navigation is triggered, either from the client or the server.
The span name contains the view's route template.

Example: `Navigation: /products/:productId`

.Navigation span attributes
[cols="1,1"]
|===
|Attribute |Description

|`vaadin.navigation.isForwardTo`
|Whether the navigation was a result of a forwarding request.

|`vaadin.navigation.route`
|The route that was navigated to.

|`vaadin.navigation.trigger`
|Whether the navigation was triggered from the client or server.

|===

=== Browser Events
Creates a span whenever a browser event is handled by a UI, for example click events.
The span name contains a descriptive label of element that was the source of the event, as well as the event name.

Example: `Event: vaadin-button[Save] {two-colons} click`

.Browser event span attributes
[cols="1,1"]
|===
|Attribute |Description

|`vaadin.element.tag`
|The tag name of the element that was the source of the event.

|`vaadin.event.type`
|The type of the event.

|`vaadin.view`
|The simple Java class name of the UI's currently active view, for example `ProductView`.

|===

=== Element Synchronization
Creates a span whenever an element property has changed and is synchronized to the server.
The span name contains a descriptive label for the element, as well as the property name.

Example: `Sync: vaadin-text-field[label='Customer Name'].value`

.Element synchronization span attributes
[cols="1,1"]
|===
|Attribute |Description

|`vaadin.element.property`
|The property that was synchronized.

|`vaadin.element.tag`
|The tag name of the element that was the source of the event.

|`vaadin.view`
|The simple Java class name of the UI's currently active view, for example `ProductView`.

|===

=== Server Calls
Creates a span whenever the client calls a server method that is annotated with `ClientCallable`.

Example: `Invoke server method: Grid.select`

.Server call span attributes
[cols="1,1"]
|===
|Attribute |Description

|`vaadin.callable.method`
|The signature of the method that was called.

|`vaadin.component`
|The qualified class name of the component on which the method was called.

|===

=== Data Provider Fetches
Creates a span whenever a component fetches data from a data provider.

Example: `Data Provider Fetch`

.Data provider span attributes
[cols="1,1"]
|===
|Attribute |Description

|`vaadin.dataprovider.limit`
|The requested amount of items to load.

|`vaadin.dataprovider.offset`
|The offset from where to start loading items.

|`vaadin.dataprovider.type`
|The qualified class name of the data provider class.

|===

=== Common Attributes

In addition to the span-specific attributes mentioned above, the following set of attributes are set on a number of spans:

[cols="1,2"]
|===
|Attribute |Description

|`http.host`
|Set on all traces / root spans, and contains the host name that triggered the request.
Can be used to filter traces by host name.

|`http.route`
|Set on all traces / root spans, and contains either a view's route template, excluding any actual parameter values, or a file path for file / stream requests.
Can be used to filter traces for specific views.

|`http.target`
|Set on all traces / root spans, and contains either a view's actual route, including parameter values, or a file path for file / stream requests.
Can be used to check which parameters were provided to a view through its route.

|`vaadin.flow.version`
|Set on all traces / root spans, and contains the Flow version used by the application.

|`vaadin.request.type`
|Set on all traces / root spans, and contains the type of Flow request made against the application.
Can be used to filter traces for a specific request type.

|`vaadin.session.id`
|Set on all spans, and contains the Vaadin session ID for the request.
Can be used to filter traces for a specific session.

|===

== Metrics

The Observability Kit Agent collects the following application metrics.
Metrics are categorized into three types:

[cols="1,3"]
|===
|Type |Description

|Counter
|A single value that only increases, for example the number of classes loaded into the JVM.

|Gauge
|A single value that is measured in intervals, for example the memory used by the JVM.

|Histogram
|Samples observations, like individual request durations, and distributes them into buckets, each bucket counting the number of observations that fall into a specific value range.
Histograms are typically used to calculate quantiles.
They also provide a total sum of all observed values and the total count of observations, which allows to calculate averages.

|===

=== Vaadin-Specific Metrics

[cols="2,1,3"]
|===
|Metric |Type |Description

|`vaadin.session.count`
|Gauge
|The number of open sessions.

|`vaadin.session.duration`
|Histogram
|Records the duration of individual sessions.

|`vaadin.ui.count`
|Gauge
|The number of current UIs managed by the application.

|===

=== Database Connection Pool Metrics

[cols="2,1,3"]
|===
|Metric |Type |Description

|`db.client.connections.create_time`
|Histogram
|The time it took to create a new connection.

|`db.client.connections.idle.min`
|Gauge
|The minimum number of idle connections allowed.

|`db.client.connections.max`
|Gauge
|The maximum number of connections allowed.

|`db.client.connections.pending_requests`
|Gauge
|The number of pending requests for an open connection, cumulative for the entire pool.

|`db.client.connections.use_time`
|Histogram
|The time between borrowing a connection and returning it to the pool.

|`db.client.connections.wait_time`
|Histogram
|The time it took to obtain an open connection from the pool.

|===


=== JVM Metrics

[cols="2,1,3"]
|===
|Metric |Type |Description

|`process.runtime.jvm.buffer.count`
|Gauge
|The number of buffers in the pool.

|`process.runtime.jvm.buffer.limit`
|Gauge
|Total capacity of the buffers in this pool, in bytes

|`process.runtime.jvm.buffer.usage`
|Gauge
|Memory that the Java virtual machine is using for this buffer pool, in bytes

|`process.runtime.jvm.classes.current_loaded`
|Gauge
|Number of classes currently loaded

|`process.runtime.jvm.classes.loaded`
|Counter
|Number of classes loaded since JVM start

|`process.runtime.jvm.classes.unloaded`
|Counter
|Number of classes unloaded since JVM start

|`process.runtime.jvm.cpu.utilization`
|Gauge
|Recent CPU utilization for the process

|`process.runtime.jvm.system.cpu.load_1m`
|Gauge
|Average CPU load of the whole system for the last minute

|`process.runtime.jvm.system.cpu.utilization`
|Gauge
|Recent CPU utilization for the whole system

|`process.runtime.jvm.memory.committed`
|Gauge
|Measure of memory committed, in bytes

|`process.runtime.jvm.memory.init`
|Gauge
|Measure of initial memory requested, in bytes

|`process.runtime.jvm.memory.limit`
|Gauge
|Measure of max obtainable memory, in bytes

|`process.runtime.jvm.memory.usage`
|Gauge
|Measure of memory used, in bytes

|`process.runtime.jvm.threads.count`
|Gauge
|Number of executing threads

|===

== Support for Other Libraries and Frameworks

As the Observability Kit Agent is based on the OpenTelemetry Java agent, it also includes a number of non Vaadin-specific instrumentation that can be helpful in monitoring an application, for example database requests using the JPA API, or outgoing HTTP requests.
https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md[See here] for a full list of supported libraries and frameworks.
