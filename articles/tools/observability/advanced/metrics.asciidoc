---
title: Additional Metrics
order: 30
description: Instructions on generating custom metrics in the application.
---

= Metrics

A metric is a measurement of a service, captured at runtime.

Application and request metrics are important indicators of availability and performance. Custom metrics can provide insights into how availability indicators impact user experience.

== Creating Custom Metrics

Creating manual metrics requires adding the OpenTelemetry API dependency to the project:

.pom.xml
[source, xml]
----
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api</artifactId>
    <version>1.18.0</version>
</dependency>
----

It is possible to make synchronous and asynchronous metric instrumentation.
Synchronous is when measurements are recorded as they happen. Asynchronous is related to when a collection of measurements is invoked.

.Create Meter Instance
[source,java]
----
class MyMetrics {
    void generateMetrics() {
        Meter meter = GlobalOpenTelemetry.meterBuilder("app-instrumentation")
            .setInstrumentationVersion("1.0.0").build();
    }
}
----

With the `Meter`, you can now create metric instrumentation for Counter, UpDownCounter, Gauge and Histogram. Each can be either a Long or a Double metric.

- `Counter` records only positive values.
- `UpDownCounter` records positive and negative values.
- `Gauge` measures an instantaneous value with an asynchronous callback.
- `Histogram` records measurements that are most useful to analyze as a histogram distribution.

Adding a synchronous count for amount of generated images:

.Counter Sample
[source,java]
----
class MyMetrics {
    static LongCounter counter;
    void generateMetrics() {
        // ...
         counter = meter
            .counterBuilder("generated_image")
            .setDescription("Amount of images generated")
            .setUnit("1").build();
    }

    public void generateImage() {
        // generation code
        counter.add(1);
    }
}
----

Adding an asynchronous gauge for measuring open sessions would could be the following:

.Gauge Sample
[source,java]
----
class MyMetrics {
    void generateMetrics() {
        // ...
        meter.gaugeBuilder("vaadin.session.count").ofLongs()
            .setDescription("Number of open sessions").setUnit("count")
            .buildWithCallback(measurement -> {
                measurement.record(getOpenSessions());
            });
    }
}
----

Metrics can also be annotated with attributes to help describe what the metric represents.

For more details about manual metrics, please see https://opentelemetry.io/docs/instrumentation/java/manual/#metrics[OpenTelemetry metrics^]

== System and Process Metrics

It's possible to collect systems and process metrics using OSHI https://github.com/oshi/oshi[Operating System and Hardware Information^] with OpenTelemetry instrumentation.

First, the application needs to get the `opentelemetry-oshi` and `oshi-core` dependencies:

.pom.xml
[source,xml]
----
<dependency>
  <!-- contains the implementation of the process- and systems-metrics collection for JavaAgent -->
  <groupId>io.opentelemetry.instrumentation</groupId>
  <artifactId>opentelemetry-oshi</artifactId>
  <version>1.18.0-alpha</version>
  <scope>compile</scope>
</dependency>
<dependency>
  <groupId>com.github.oshi</groupId>
  <artifactId>oshi-core</artifactId>
  <version>5.3.1</version>
</dependency>
----

Then to enable and register the metrics and observers, call `SystemMetrics.registerObservers()` and `ProcessMetrics.registerObservers()` once.

For instance, here is how it might look in a spring-boot application:

.SpringBootApplication
[source,java]
----
@SpringBootApplication
public class YourApplication implements AppShellConfigurator {

    static {
        SystemMetrics.registerObservers(GlobalOpenTelemetry.get());
	    ProcessMetrics.registerObservers(GlobalOpenTelemetry.get());
    }
    //  other code
}
----
