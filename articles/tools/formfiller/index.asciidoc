---
title: AI Form Filler
description: Fill your forms automatically from a natural language input source using ChatGPT.
---

= [since:com.vaadin:vaadin@V24.1]#AI Form Filler#


The AI Form Filler addon is an experimental feature that provides an easy way for Flow users to create forms that are filled automatically from natural language input sources using GPT technologies.

OpenAI ChatGPT is the LLM model behind this feature but any model can be adapted using the LLMService interface. 

[WARNING]
.Experimental Feature
AI Form Filler is an experimental feature and it may be removed, altered, or limited to commercial subscribers in future releases.

image::images/formfiller-design.png[AI FormFiller Design.]


== Features

Form Filler Addon has the following features in this experimental preview:

*Supports most of the common input components of Flow*::
- EmailField
- PasswordField
- NumberField
- IntegerField
- BigDecimalField
- DatePicker
- TimePicker
- DateTimePicker
- TextArea
- Checkbox
- CheckboxGroup
- RadioButtonGroup
- ComboBox
- MultiSelectComboBox
- Grid

*Easy to use and works out of the box*::
Built in prompt engineering do the job of generating a request containing the information related to the target components that works out of the box for most of the cases. Once you have defined your form only a couple of lines are required to use the Form Filler. 

*Context instructions*::
API to add more context instructions for the AI module i.e.: target language, vocabulary explanation, source context, etc... Use these instructions to give extra information to the AI module about the context of the input source in general.

*Component instructions*::
API to add more component instructions for the AI module (i.e.: field format, field explanation, field actions, etc...). Use these instructions to give extra information to the AI module about a specific field when the built in request/response of the form filler is not accurate enough.


== Getting Started

Form Filler is implemented as an addon. It can be used in any Flow 24.1 application and to use it you need to add the maven dependency to your project. 

[source,xml]
----
        <dependency>
            <groupId>com.vaadin.flow.ai</groupId>
            <artifactId>form-filler-addon</artifactId>
            <version>0.1.0</version>
        </dependency>
----

If you prefer to first test the addon with an example see https://github.com/vaadin/form-filler-demo[demo project]. Also some demos and advanced example use cases included in the https://github.com/vaadin/form-filler-addon[addon project]. 

In the demo project you can see an example of all the supported components with some raw text sources included. Then in the addon project you have some experiments with more advanced use cases like document inputs through OCR. New content and examples i.e.: using other LLM models than ChatGPT or improve OCR results could be included in the addon project in the future. Then added to the demo project as they become mature enough.  

To run demos or use the addon out of the box in your application you need a valid ChatGPT API Key. This key can be set as environment variable or specified as a JVM property with the '-D' flag. The name of the variable is OPENAI_TOKEN.

- Macos: include on your .zprofile 
[source,script]
----
export OPENAI_TOKEN="THE KEY"
----

- Windows: Use "System -> Advanced Settings -> Set Environment Variables" to set OPENAI_TOKEN and GOOGLE_VISION_API_KEY




=== Simple Example

To understand how the Form Filler works take a look to this simple example. 

[source,java]
----
@Route("test")
public class FormTest extends Div {

    public FormTest() {

        TextField nameField = new TextField("Name");
        nameField.setId("name");

        TextField addressField = new TextField("Address");
        addressField.setId("address");

        FormLayout fl = new FormLayout();
        fl.add(nameField, addressField);

        FormFiller formFiller = new FormFiller(fl);
        formFiller.fill("My name is Bart and I live at 742 Evergreen Terrace, Springfield USA");

        add(fl);
    }
}
----

image::images/simple-example.png[AI FormFiller Simple Example.]

To enable the Form Filler there is only one requirement. You have to set meaningful IDs to the fields(Components) that you want to be filled by the Form Filler. The target can be just one component or a group of component (container). Usually you would use the Form Filler with a FormLayout but any kind of Layout can be used. 

==== API Review

===== Constructors

Form Filler has 6 constructors all of them based on the same one but each one providing default values when a parameter of the base constructor is not provided. 

These parameters are:

_target:_ the target component or group of components (layouts) to fill. This is the only mandatory parameter without default value. 

_componentInstructions:_ extra instructions for the AI module related to a specific component/field (i.e.: field format, field explanation, etc...). Use these instructions to give extra information to the AI module about a specific field when the response of the form filler is not accurate enough. By default this structure is initialized empty.

_contextInstructions:_ extra instructions for the AI module related to the input source or all components/fields i.e.: target language, vocabulary explanation, current time, etc... Use these instructions to give extra information to the AI module about the context of the input source in general. By default this structure is initialized empty.

_llmService:_ the AI module service to use. By default, this service would use OpenAI ChatGPT with chat/completion end point and the "gpt-3.5-turbo-16k-0613" model. There is another built in service using also ChatGPT but with the /completion endpoint and the "text-davinci-003" model. About ChatGPT models, newest models could not be better for the specific task of the Form Filler. Testing phase has not identified the best model so don't hesitate to test both services and give feedback about your results. More models and others LLM providers could be added to the addon in the future. If you want to create your own provider service you need to extend the interface LLMService and add it as a parameter to the Form Filler. 
 	
===== Methods
[source,java]
----
public FormFillerResult fill(String input)
----

The main method to be called when you want to fill the form fields after setting up the FormFiller object. This method fills the registered fields and returns a structure with information of the process such as the AI module request and response.  

=== Advanced Example

==== Creating the Form

[source,java]
----
   formLayout = new FormLayout();

   TextField nameField = new TextField("Name");
   nameField.setId("name");
   formLayout.add(nameField);

   TextField addressField = new TextField("Address");
   addressField.setId("address");
   formLayout.add(addressField);

   TextField phoneField = new TextField("Phone");
   phoneField.setId("phone");
   formLayout.add(phoneField);

   TextField emailField = new TextField("Email");
   emailField.setId("email");
   formLayout.add(emailField);

   DateTimePicker dateCreationField = new DateTimePicker("Creation Date");
   dateCreationField.setId("creationDate");
   formLayout.add(dateCreationField);

   DatePicker dueDateField = new DatePicker("Due Date");
   dueDateField.setId("dueDate");
   formLayout.add(dueDateField);

   ComboBox<String> orderEntity = new ComboBox<>("Order Entity");
   orderEntity.setId("orderEntity");
   orderEntity.setItems("Person", "Company");
   formLayout.add(orderEntity);

   NumberField orderTotal = new NumberField("Order Total");
   orderTotal.setId("orderTotal");
   formLayout.add(orderTotal);

   TextArea orderDescription = new TextArea("Order Description");
   orderDescription.setId("orderDescription");
   formLayout.add(orderDescription);

   RadioButtonGroup<String> paymentMethod = new RadioButtonGroup<>("Payment Method");
   paymentMethod.setItems("Credit Card", "Cash", "Paypal");
   paymentMethod.setId("paymentMethod");
   formLayout.add(paymentMethod);

   Checkbox isFinnishCustomer = new Checkbox("Is Finnish Customer");
   isFinnishCustomer.setId("isFinnishCustomer");
   formLayout.add(isFinnishCustomer);

   CheckboxGroup<String> typeService = new CheckboxGroup<>("Type of Service");
   typeService.setItems("Software", "Hardware", "Consultancy");
   typeService.setId("typeService");
   formLayout.add(typeService);

   Grid<OrderItem> orderGrid = new Grid<>(OrderItem.class);
   orderGrid.setId("orders");

   formLayout.add(orderGrid);
----

==== Filling the Form:

- common use case

[source,java]
----
   FormFiller formFiller = new FormFiller(formLayout);
   FormFillerResult result = formFiller.fill(input);
----

- adding extra instructions use case
[source,java]
----
   FormFiller formFiller = new FormFiller(formLayout, fieldsInstructions, contextInformation);
   FormFillerResult result = formFiller.fill(input);
----

- using a different model use case
[source,java]
----
   FormFiller formFiller = new FormFiller(formLayout, new ChatGPTService());
   FormFillerResult result = formFiller.fill(input);
----

=== Best Practices & Limitations

To make a set of components ready to be filled by the FormFiller the only requirements are:

- Target fields are descendants of the same container (layout) passed to the FormFiller. The best way is to integrate all the fields in a FormLayout but any kind of Layout can be used. Also all the descendants of the passed container are going to be included so several containers can be used inside the main container. 

- Every field has an ID (Component::setId). The ID should be meaningful about the data contained by the field. Grid columns are a special case as they are not input fields, they are inspected directly from the Bean of the GRID so use meaningful names for the Bean fields.

Anyways remember that later you can add extra information about any component to help the AI module if the Id is not enough to understand what data you are looking for. Of course you can use a sentence as an Id but for cleaner code it is recommend to use Ids in combination with extra instructions but it is up to the developer to choose. For most cases a 2/3 word Id is enough for the AI module to understand the target. i.e.:

[source,java]
----
    CheckboxGroup<String> typeService = new CheckboxGroup<>("Type of Service");
    typeService.setItems("Software", "Hardware", "Consultancy");
    typeService.setId("typeService");
    formLayout.add(typeService);
    ......
    HashMap<Component,String> fieldInstructions = new HashMap<>();
    fieldInstructions.put(typeService, "This field describes the type of the items of the order");

    FormFiller formFiller = new FormFiller(formLayout, fieldsInstructions);
    FormFillerResult result = formFiller.fill(input);
----

is better than 

[source,java]
----
    CheckboxGroup<String> typeService = new CheckboxGroup<>("Type of Service");
    typeService.setItems("Software", "Hardware", "Consultancy");
    typeService.setId("the type of the items of the order");
    formLayout.add(typeService);
    ......
    FormFiller formFiller = new FormFiller(formLayout);
    FormFillerResult result = formFiller.fill(input);
----

These extra instructions can be used not only for understanding but also for formatting or error fixes i.e.:

[source,java]
----
    HashMap<Component,String> fieldInstructions = new HashMap<>();
    fieldInstructions.put(nameField, "Format this field in Uppercase");
    fieldInstructions.put(emailField, "Format this field as a correct email");
----

Some limitations exist for some fields specially the ones containing dates the FormFiller has its own standard formatting requirement so be careful manipulating them.

=== Components Supported:

- TextField
- EmailField
- PasswordField
- NumberField
- IntegerField
- BigDecimalField
- DatePicker
- TimePicker
- DateTimePicker
- TextArea
- Checkbox
- CheckboxGroup
- RadioButtonGroup
- ComboBox
- MultiSelectComboBox
- Grid

=== Types supported for Grid Columns:

- Date
- LocalDate
- Time
- LocalTime
- DateTime
- LocalDateTime
- Boolean
- Integer
- Long
- Double
- Float
- String

=== Debug

The _FormFiller::fill_ method returns a _FormFillerResult_ that contains the request sent and the response received of the AI module. The request is a prompt in natural language containing all the instructions including the target JSON object and the target types. The response has to be a valid JSON object with components Ids as keys and its values. 
Through the FormFiller object you can access the internal structures used for mapping. 

You can visualize all these structures like this (example from the addon demo):

[source,java]
----
        FormFiller formFiller = new FormFiller(formLayout, fieldsInstructions, contextInformation);
        FormFillerResult result = formFiller.fill(input);
        debugTool.getDebugPrompt().setValue(result.getRequest());
        debugTool.getDebugJsonTarget().setValue(String.format("%s", formFiller.getMapping().componentsJSONMap()));
        debugTool.getDebugTypesTarget().setValue(String.format("%s", formFiller.getMapping().componentsTypesJSONMap()));
        debugTool.getDebugResponse().setValue(result.getResponse());
----

Example of a valid response

[source,json]
----
{
  "typeService": ["Hardware", "Software"],
  "address": "Ruukinkatu 2-4, FI-20540 Turku, Finland",
  "clientId": "45XXD6543",
  "dueDate": "2023-05-05",
  "orderEntity": "Person",
  "creationDate": "2023-01-01T12:13:00",
  "orderDescription": "Form filler AI Addon",
  "orderTotal": 15000,
  "isFinnishCustomer": true,
  "phone": "555-1234",
  "name": "ANDREW JACKSON",
  "orderTaxes": 25.6,
  "paymentMethod": "Cash",
  "orders": [
    {
      "itemName": "Smartphones",
      "orderId": "1001",
      "orderStatus": "Delivered",
      "orderCost": 1000,
      "deliveryDate": "2023-01-13",
      "orderDate": "2023-01-10"
    },
    {
      "itemName": "Laptop",
      "orderId": "1002",
      "orderStatus": "In Transit",
      "orderCost": 1500,
      "deliveryDate": "2023-03-15",
      "orderDate": "2023-02-15"
    },
    {
      "itemName": "Wireless Headphones",
      "orderId": "1003",
      "orderStatus": "Cancelled",
      "orderCost": 500,
      "deliveryDate": "2023-04-14",
      "orderDate": "2023-03-20"
    },
    {
      "itemName": "Headphones",
      "orderId": "1004",
      "orderStatus": "In Transit",
      "orderCost": 999,
      "deliveryDate": "2023-03-15",
      "orderDate": "2023-01-01"
    },
    {
      "itemName": "Windows License",
      "orderId": "1005",
      "orderStatus": "Delivered",
      "orderCost": 1500,
      "deliveryDate": "2023-03-16",
      "orderDate": "2023-02-01"
    }
  ],
  "typeServiceMs": ["Hardware", "Software"],
  "age": 43,
  "email": "andrewjackson@gmail.com"
}
----

=== AI Models

The Form Filler provides two built-in LLM implementations using ChatGPT services. Both models are quite good understanding and processing natural language. In any case it is advised to try yourself both implementations to find out which one fits better with your requirements. Even if ChatGPTChatCompletionService, using gpt-3.5-turbo-16k-0613 model, is more advanced the LLM world is not something 100% predictable. You never know what model could work better. 

==== Implementing your Own AI Model Adapter

You can implement your own AI model adapter for ChatGPT or any other LLM provider. It is advised to use one of the existing implementations as template if you want to create a new adaptor. Internal parameters such as the model name, temperature or max tokens are up to the developer to be chosen and parametrized. The methods that are mandatory to be implemented are the ones described by the LLMService interface. 

First you need to implement the _LLMService::getPromptTemplate_ method to create the prompt that is sent to the AI module. This method receives all the internal structures generated automatically from the target form. 
Then you need to implement the _LLMService::getGeneratedResponse_ method that actually sends the prompt to the AI module. This method has to guarantee that the response is a valid JSON object using the same format that is sent in the request. 

[source,java]
----
/**
 * A LLM service that generates a response based on a prompt.
 * All responsibilities related to the model usage have to be
 * implemented in this service. This could be APIKEY providing,
 * parameter setting, prompt template generation, etc.
 */
public interface LLMService {

    /**
     * Generates a prompt based on the input, the target components and any
     * extra instruction.
     *
     * @param input the input text (e.g. "My name is John")
     * @param objectMap the objectMap containing the target components in a
     *                  hierarchical structure (keys = ids)
     * @param typesMap the map containing the desired type to fill with each
     *                 one of the target components (keys = ids)
     * @param componentInstructions the components (fields) instructions
     *                              containing additional information to understand
     *                              the field meaning.
     * @param contextInstructions the context instructions containing additional
     *                            information to understand the input or
     *                            providing some information not present in the input
     * @return the generated prompt to be sent to the AI module
     */
    public String getPromptTemplate(String input, Map<String, Object> objectMap, Map<String, String> typesMap, HashMap<Component, String> componentInstructions, ArrayList<String> contextInstructions);

    /**
     * Generates a response based on the input prompt from the AI module.
     *
     * @param prompt the prompt to be used by the AI module
     * @return the generated response from the AI module. This response has to
     * be a valid JSON Object using target field IDs as keys and the value
     * correctly formatted according to the target component. An example is
     * the following format:
     * <br>
     * <pre>{@code
     *     {
     *     "field Id 1": "value 1", // TextField
     *     "field Id 2": 66, // NumberField or IntegerField
     *     "field Id 3": "2022-04-03", // DatePicker
     *     "field Id 4 ": [ // Grid
     *          {
     *         "inner item id1": "Value 1",
     *         "inner item id2": "Value 2",
     *         "inner item id3": "Value 3"
     *          },
     *          {
     *         "inner item id1": "Value 1",
     *         "inner item id2": "Value 2",
     *         "inner item id3": "Value 3"
     *          }
     * ],
     * "field Id 5 ": ["Value 1", "Value 2"], // MultiSelectComboBox
     * "field Id 6": true, // Checkbox
     * "field Id 7": 43.47 // BigDecimalField
     * }
     * }</pre> <br>
     */
    public String getGeneratedResponse(String prompt);
}
----

Then use your new implemented service on the Form Filler constructor.

[source,java]
----
   FormFiller formFiller = new FormFiller(formLayout, new MyGPTService());
   FormFillerResult result = formFiller.fill(input);
----

=== Limitations

- The size of the text that can be processed is related to the capacity of the used model. The model included as default in the addon has a limit of 16384 tokens (approx 16000 words including request and response).
- So far parametrized components such as checkboxes or radio buttons work with basic types not custom classes.
- Grid must be defined using a Bean type.

Please use the https://github.com/vaadin/form-filler-addon[addon project] for reporting bugs, asking questions, proposing enhancement ideas or voting for roadmap priorities.

