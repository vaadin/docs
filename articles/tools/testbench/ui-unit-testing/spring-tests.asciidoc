---
title: UI Unit Testing With Spring Framework
order: 40
layout: page
---

[[testbench.uiunit.spring]]
= Testing With Spring Framework

In Spring based projects, views may benefit of dependency injection to get references to service and other software components.
To be able to instantiate such views and handle navigation in the correct way, Vaadin needs special implementations for internal components, like [classname]`SpringInstantiator`.
UI Unit Testing provides specialized base test classes that integrates with Spring Testing Framework: [classname]`SpringUIUnitTest`, for JUnit 5, and [classname]`SpringUIUnit4Test`, for JUnit 4.

Subclasses can therefore rely on all features offered Spring Testing Framework.
The test class can be annotated with [annotationname]`@ContextConfiguration`, to give a reduced [classname]`ApplicationContext` for a faster startup, or apply the [annotationname]`@SpringBootTest` annotation for more complex scenarios.


.Spring test example
[source,java]
----
@ContextConfiguration(classes = ViewTestConfig.class)
class ViewTest extends SpringUIUnitTest {

}

@Configuration
class ViewTestConfig {

        @Bean
        GreetingService myService() {
                return new TestingGreetingService();
        }
}
----

.Spring Boot test example
[source,java]
----
@SpringBootTest
class ViewTest extends SpringUIUnitTest {

}
----

[[testbench.uiunit.setup-view-access-control]]
== Setup View Access Control

To apply view access control, Vaadin requires a [classname]`ViewAccessChecker` to be registered as [classname]`BeforeEnterListener` for the UI.
For [annotationname]`@SpringBootTest` annotated tests, the checker is automatically created and configured.
However, when testing with a restricted ApplicationContext, you may want to perform the setup by your own in a [classname]`Configuration` class,
by providing a [classname]`VaadinServiceInitListener` that executes the step mentioned above.


.Setup ViewAccessChecker for plain Spring project
[source,java]
----
@Configuration
class TestViewSecurityConfig {
    
    @Bean
    VaadinServiceInitListener setupViewSecurityScenario() {
        SpringViewAccessChecker viewAccessChecker = new SpringViewAccessChecker(new AccessAnnotationChecker());
        viewAccessChecker.setLoginView(LoginView.class);
        return event -> {
            event.getSource().addUIInitListener(uiEvent -> {
                uiEvent.getUI().addBeforeEnterListener(viewAccessChecker);
            });
        };
    }
}
----

If using Vaadin Spring Add-On, you can instead import the out-of-the box [classname]`ViewAccessCheckerInitializer`, that only requires to define a [classname]`ViewAccessChecker` bean. 

.Setup ViewAccessChecker with Vaadin Spring Add-On
[source,java]
----
@Configuration
@Import({ViewAccessCheckerInitializer.class})
class TestViewSecurityConfig {
    
    @Bean
    ViewAccessChecker viewAccessChecker() {
        return new SpringViewAccessChecker(new AccessAnnotationChecker());
    }
}
----


[[testbench.uiunit.spring-security]]
== Testing With Spring Security

Vaadin comes with built-in security helpers that enable annotation based view access control mechanism, which integrates well with Spring Security.
When using [classname]`SpringUIUnitTest`, if Spring Security is present on classpath, the mock environment is instructed to fetch authentication details from Spring [classname]`SecurityContextHolder`.


With this support, you can use Spring Security test annotations, such as [annotationname]`@WithMockUser`, [annotationname]`@WithAnonymousUser` or [annotationname]`@WithUserDetails`, to simulate different authentication scenarios with test method granularity.
More information is available at https://docs.spring.io/spring-security/reference/servlet/test/method.html#test-method-withmockuser[Spring Security documentation] site.
Authentication details are available before creating the UI instance and navigating to the default route, so redirects to login view does not happen, when simulating logged in users.
In the same way, custom redirect logic for authenticated users works as expected.


To use Spring Security test annotations, first make sure the dependency is added to the project.

[source,xml]
----
<dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
</dependency>
----

Then extend [classname]`SpringUIUnitTest` and annotate test methods on order to setup an authentication scenario.
For simplest use cases, use [annotationname]`@WithMockUser` or [annotationname]`@WithAnonymousUser`, providing username and roles that should be granted.

.Tests with mocked users
[source,java]
----
@SpringBootTest
public class ViewSecurityTest extends SpringUIUnitTest {

    @Test
    @WithAnonymousUser
    void anonymousUser_protectedView_redirectToLogin() {
        navigate("protected", LoginView.class);
    }

    @Test
    @WithAnonymousUser
    void anonymousUser_publicView_signInLinkPresent() {
        // public view is default page
        Assertions.assertInstanceOf(PublicView.class, getCurrentView());

        Assertions.assertTrue(
                $(Anchor.class).withText("Sign in").first().isUsable(),
                "Sign in link should be available for anonymous user");
    }

    @Test
    @WithMockUser(username = "admin", roles = "ADMIN")
    void adminUser_adminView_viewShown() {
        navigate(AdminRoleView.class);

        Assertions.assertTrue(
                $(Avatar.class).first().getComponent().isVisible(),
                "Avatar should be visible for logged users");
    }
}
----

When custom User objects or complex grant rules should be used, provide a custom [classname]`UserDetailsService` and annotate test method with [annotationname]`@WithUserDetails`.

.Tests with mocked UserDetailsService
[source,java]
----
@ContextConfiguration(classes = SecurityTestConfig.class)
class SpringUnitSecurityTest extends SpringUIUnitTest {

    @Test
    @WithUserDetails("admin")
    void superuser_adminView_viewShown() {
        navigate(AdminRoleView.class);

        Assertions.assertTrue(
                $(Avatar.class).first().getComponent().isVisible(),
                "Avatar should be visible for logged users");
    }

    @Test
    @WithUserDetails
    void user_adminView_accessDenied() {
        RouteNotFoundError errorView = navigate("admin-role",
                RouteNotFoundError.class);
        Assertions.assertTrue(
                errorView.getElement().getChild(0).getOuterHTML()
                        .contains("Reason: Access denied"),
                "Admin view should be accessible only by users with ADMIN role");
    }


}

@Configuration
class SecurityTestConfig {

    @Bean
    UserDetailsService mockUserDetailsService() {

        return new UserDetailsService() {
            @Override
            public UserDetails loadUserByUsername(String username)
                    throws UsernameNotFoundException {
                if ("user".equals(username)) {
                    return new User(username, UUID.randomUUID().toString(),
                            List.of(
                                new SimpleGrantedAuthority("ROLE_DEV"),
                                new SimpleGrantedAuthority("ROLE_USER")
                        ));
                }
                if ("admin".equals(username)) {
                    return new User(username, UUID.randomUUID().toString(),
                            List.of(
                                new SimpleGrantedAuthority("ROLE_SUPERUSER"),
                                new SimpleGrantedAuthority("ROLE_ADMIN")
                        ));
                }
                throw new UsernameNotFoundException(
                        "User " + username + " not exists");
            }
        };
    }
}
----


