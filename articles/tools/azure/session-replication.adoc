---
title: Session Replication
description: Best practices to achieve session replication
order: 100
---

= Session Replication

For a Vaadin application to reach the goals of High Availability and Down Scaling, it is fundamental that the HTTP session is correctly distributed between multiple servers.

If the server processing user requests becomes unavailable, it should be transparently replaced by another one, in a way that the user should be able to continue using the application without any disruption.

The user may notice a temporarily offline notification or the loading indicator spawn, but the browser page is not reloaded and work can continue without losing any data.

This means that attributes must be constantly stored in a shared/distributed storage, so that newly created HTTP sessions may filled with the most recent user data.


== Kubernetes Kit Session Replication

Kubernetes Kit helps with session replication, by transferring HTTP session data via a backend session storage (Hazelcast or Redis) at every request.
When a server becomes unavailable, the one taking its place loads user data from the session storage and fills the new server-side HTTP session object.

To transfer information to the session storage, the HTTP session attributes are encoded in a binary format, using https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/index.html[Java serialization].

This means that to have session replication working, the application code should be written in way that all objects stored in the HTTP session are eligible for Java serialization, meaning they must implement a special marker interface, [classname]`java.io.Serializable`.
Objects that for any reason cannot be serializable (e.g. third party classes) must be defined `transient`, so they are skipped by the serialization process.
Of course, after deserialization transient fields are null.

For Spring applications, Kubernetes Kit is also able to overcome this limitation.
Transient fields referencing Spring beans are detected during serialization and metadata is stored along with the session attributes.
On deserialization, transient fields matching metadata are injected with the corresponding Spring bean.


== Vaadin and HTTP Session

A Vaadin application is comprised of UI objects that act as root nodes of graphs of components that represent the web page the user interacts with in through the browser.
UIs are collected into a [classname]`VaadinSession` that is stored in the HTTP session, to preserve the server-side state across requests.
For this reason, application code should be carefully written to be serializable for Vaadin session replication to succeed.

For a deeper insight of serialization process, consult [Java documentation] website.

== Vaadin Session Replication Tips

The aim of the following sections is to give tips and best practices on how to code a fully serializable Vaadin applications.


=== Use Serializable Object as UI Components Members

When writing a component make sure that all its non-transient members implement [classname]`Serializable`.

All Vaadin UI components and listeners are already marked as serializable, so if a class extends or implements one of them, it is not necessary to explicitly add the `Serializable` implementation statement.

However, it is mandatory to do that on non UI components that may be referenced in the UI graph.

For example, if a view is holding a reference to a data transfer object or a configuration object, it must be marked as serializable, and all its members must be serializable.

[source,java]
----
class ContactForm extends VerticalLayout { // (1)

    private Product product; // (2)

}

class Product implements Serializable { // (3)

    private Category category; // (4)
}

class Category implements Serializable { // (5)

}
----

1. The [classname]`ContactForm` class extends a Vaadin component that is already serializable.
2. The [classname]`ContactForm` class has a field of type [classname]`Product`.
Therefore, the [classname]`Product` class must also be made serializable.
3. The [classname]`Product` class is made serializable by extending [interfacename]`Serializable`.
4. The [classname]`Product` class has a field of type [classname]`Category`.
Therefore, the [classname]`Category` class must also be made serializable.
5. The [classname]`Category` class is made serializable by extending [interfacename]`Serializable`.


=== Transient Fields for Non-Serializable Objects

If a UI component needs to store a reference to an instance of a not serializable class, it must defined it as `transient`.

In Spring projects, Vaadin Kubernetes Kit is able to detect this fields and re-inject them after deserialization.

[NOTE]
In non Spring project, transient fields should be handled manually either by implementing Java serialization hooks (https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/output.html#the-writeobject-method[`writeObject`], https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/output.html#the-writereplace-method[`writeReplace`], https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/input.html#the-readobject-method[`readObject`], https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/input.html#the-readresolve-method[`readResolve`], etc.) or the Vaadin Kubernetes Kit [interfacename]`TransientHandler` interface.

[source,java]
----
class ContactForm extends VerticalLayout { // (1)

    private transient ContactService product; // (2)

}

@Component // (4)
class ContactService {
    private ContactRepository repository; // (3)
}
----

1. The [classname]`ContactForm`` class extends a Vaadin component that is already serializable.
1. [classname]`ContactService` is not serializable, field must be defined transient.
1. [classname]`ContactService` can contain not serializable members, since it would not be serialized.
1. [classname]`ContactService` is a Spring bean; it is injected after deserialization.

=== Use Serializable Variants of Functional Interfaces

A component may use Java functional interfaces to allow client code to provide executable code blocks, in form of lambda expressions or method references.

For example, a form view may accept a callback to be execute after data is saved to the database.
The callback may be represented by a [classname]`Consumer<T>`, and stored in the [fieldname]`onSuccess` field.

[source,java]
----
class ProductForm extends VerticalLayout {

    private Consumer<Product> onSuccess;

}
----

This breaks serialization process, because [classname]`Consumer` interface is not [classname]`Serializable`.
The [fieldname]`onSuccess` field must be replaced by serializable friendly type.

To make serialization of [classname]`ProductForm` work, the class can be refactored using a [classname]`SerializableConsumer<T>`

[source,java]
----
import com.vaadin.flow.function.SerializableConsumer;

class ProductForm extends VerticalLayout {

    private SerializableConsumer<Product> onSuccess;

}
----

Vaadin offers a serializable-ready version of the most used Java functional interfaces in the [packagename]`com.vaadin.flow.function` package.

Take care also when writing utility classes that uses functional interfaces as input parameters or return types.

Following class breaks serialization if methods are used 

[source,java]
----
public class DataProviderUtil {
  
    // (1)
	public static <S, T> T convertIfNotNull(S source, Function<S, T> converter, Supplier<T> nullValueSupplier) {
 		return source != null ? converter.apply(source) : nullValueSupplier.get();
 	}
 
    // (2)
	public static <T> ItemLabelGenerator<T> createItemLabelGenerator(Function<T, String> converter) {
 		return item -> convertIfNotNull(item, /* (3) */ converter, () -> "");
 	}
}

class OrderEditor {

    private ComboBox<OrderState> status;

    OrderEditor() {
        // (4)
        status.setItemLabelGenerator(
            DataProviderUtil.createItemLabelGenerator(OrderState::getDisplayName)
        );
    }
}
----

1. Takes a reference to non serializable functional interfaces.
1. Takes a reference to a non serializable interface
1. and captures it into the returned lambda expression.
1. Store the [classname]`ItemLabelGenerator` lambda expression in the serializable [classname]`ComboBox` component.

The above utility class must be refactored to use serializable functional interfaces, as follows:

[source,java]
----
public class DataProviderUtil {
  
	public static <S, T> T convertIfNotNull(S source, SerializableFunction<S, T> converter, SerializableSupplier<T> nullValueSupplier) {
 		return source != null ? converter.apply(source) : nullValueSupplier.get();
 	}
 
	public static <T> ItemLabelGenerator<T> createItemLabelGenerator(SerializableFunction<T, String> converter) {
 		return item -> convertIfNotNull(item, /* (3) */ converter, () -> "");
 	}
}
----

=== Don't Capture Not Serializable Object in lambdas

When coding component listeners or setting properties that accepts functional interfaces, it is common to use lambda expression.

Lambdas can be serialized if the target interface is [classname]`Serializable`, but they must not capture any not serializable objects.

For example, the following code fails during serialization because [classname]`OrderService` is not Serializable.

[source,java]
----
class OrderEditor {

    private ComboBox<OrderState> status;
    
    OrderEditor(OrderService service) {
        status.setItemLabelGenerator(item -> 
            service.humanReadableState(item)
        );
    }
}
----

In this case, probably a solution may be store the `service` reference as [classname]`OrderEditor` transient field, accessing the instance in the lambda with a method call, for example a `getter`, and implement Java deserialization hooks to somehow inject the service instance.

In Spring projects using Vaadin Kubernetes Kit, you can rely on transient field handling, and simply add the field for the service instance.

[source,java]
----
class OrderEditor {

    private transient OrderService service;
    private ComboBox<OrderState> status;
    
    OrderEditor(OrderService service) {
        this.service = service;
        status.setItemLabelGenerator(item -> 
            getOrderService().humanReadableState(item)
        );
    }

    private OrderService getOrderService() {
        return service;
    }
}
----

Another way, to avoid adding the transient field to the main class, is to reference the non serializable object in a serializable proxy, that exposes only the required methods.

[source,java]
----
class OrderEditor {

    private ComboBox<OrderState> status;
    
    OrderEditor(OrderService service) {
        this.service = service;
        OrderStateLabelGeneratorProxy proxy = new OrderStateLabelGeneratorProxy(service);
        status.setItemLabelGenerator(item -> 
            proxy.humanReadableState(item)
        );
    }

    private static class OrderStateLabelGeneratorProxy
        implements Serializable {
        
        private final transient OrderService service;

        OrderStateLabelGeneratorProxy(OrderService service) {
            this.service = service;
        }

        String humanReadableState(OrderState state) {
            return service.humanReadableState(item);
        }
    }
}
----


== Session Replication Issues

Despite from applying mentioned tips, still session replication may fail because of issues during serialization or deserialization.

When facing exceptions on serialization phase, it may be useful set the `sun.io.serialization.extendedDebugInfo` system property to make Java serialization verbose.
However, be aware that to represent the objects beans serialized, the `toString()` method is used, and this in rare cases may cause issues not related to serialization.
For example, Hibernate `[classname]`PersistentList.toString()` forces initialization of the lazy loaded collection.
If this happens without an active Hibernate session, an exception is thrown.

In the following section, common issues with serialization and deserialization are presented.


=== SerializedLambda ClassCastException

A common Vaadin application extensively uses lambda expression for components listeners, binder, etc.

When serializing and deserializing lambda expressions, it may happen to face [classname]`ClassCastException`s with cryptic messages, such as `SerializedLambda cannot be cast to class <className>`  (Serialization) or `SerializedLambda cannot be assigned to field <fieldName> of type <className>`.

Usually the cause is a `self reference`, meaning that the lambda expression captures an object instance, but the expression is itself a member of the object graph of the captured object.

Detecting the cause of the issues in not easy.
In most cases it requires the developer intercept the [classname]`ClassCastException` in the IDE debugger and to analyze the call stack to identify the class defining the lambda expression.

Once the lambda expression has been identified, replacing it with an anonymous class may be the solution.


== Kubernetes Kit Session Replication Debug Tool

To help making HTTP session fully serializable and deserializable, Kubernetes Kit offers a tool whose aim is to discover main issues during development.

The debug tool is composed by a HTTP session replication tester, engaged by a Vaadin [classname]`RequestHandler`, that tries to serialize and deserialize the HTTP session for every user action on the browser that triggers a server request.
It works only on `development mode` and only if session serialization is enabled setting the configuration property `vaadin.devmode.sessionSerialization.enabled` to `true`.

Outcomes from the test are printed on the server logs, and includes following details:

 * Test process outcomes (for example SERIALIZATION_FAILED, DESERIALIZATION_FAILED, SUCCESS, ...)
 * List of not serializable classes
 * Object class graph in case of deserialization errors
 * Potential causes of [classname]`SerializedLambda` [classname]` ClassCastException`s

The debug tool can be installed by configuring the provided [classname]`VaadinInitListener`, either by adding an entry in `META-INF/services/VaadinServiceInitListener` or by defining a bean if using Vaadin Spring add-on.

.Install with Service Loader entry in META-INF/services/VaadinServiceInitListener
[source,text]
----
com.vaadin.azure.starter.sessiontracker.serialization.SerializationDebugRequestHandler$InitListener
----

.Install exposing Spring Bean
[source,java]
----
@Configuration
class AppConfig {

    @Bean
    VaadinServiceInitListener serializationDebugInitListener() {
        return new SerializationDebugRequestHandler.InitListener();
    }
}
----

[TIP]
For information about Service Init Listener consult the <<{articles}/advanced/service-init-listener#,specific documentation>>.

=== Debug Tool Hints Examples

Suppose you have an application that is not coded from the beginning to support session replication.
With Kubernetes Session Replication Debug Tool in action issues like the following can be spot during development mode, checking server logs.

For views directly or indirectly referencing not serializable objects, the classes causing issues are reported.
Double check those classes, make them [classname]`Serializable` and then navigate to view again to see if the issues is solved or if other problems arise.

[source,text]
----
Session serialization attempt completed in 42 ms with outcomes: [SERIALIZATION_FAILED, NOT_SERIALIZABLE_CLASSES]

NOT SERIALIZABLE CLASSES FOUND:
===============================

com.vaadin.starter.bakery.ui.views.storefront.OrderPresenter
com.vaadin.starter.bakery.ui.utils.converters.LocalTimeConverter
com.vaadin.starter.bakery.backend.service.PickupLocationService
com.vaadin.starter.bakery.ui.views.orderedit.OrderEditor$$Lambda$2202/0x0000000800e2f040
com.vaadin.starter.bakery.backend.service.ProductService
com.vaadin.starter.bakery.ui.views.orderedit.OrderEditor$$Lambda$2165/0x0000000800e1f440
com.vaadin.starter.bakery.backend.service.OrderService$$EnhancerBySpringCGLIB$$75e41bca
com.vaadin.starter.bakery.ui.views.storefront.OrderPresenter$$Lambda$2106/0x0000000800df6440
----

To solve [classname]`SerializedLambda` class cast exceptions during deserialization, analyze the class graph from the bottom to the top and search for know classes and check the `BEST CANDIDATES` sections to identify the failing lambda expression.

[source,text]
----
Session serialization attempt completed in 22 ms with outcomes: [SERIALIZATION_FAILED, NOT_SERIALIZABLE_CLASSES, DESERIALIZATION_FAILED]

ERRORS DURING SERIALIZATION/DESERIALIZATION PROCESS:
====================================================
DESERIALIZATION_FAILED: cannot assign instance of java.lang.invoke.SerializedLambda to field com.vaadin.flow.component.ComponentEventBus$ListenerWrapper.listener of type com.vaadin.flow.component.ComponentEventListener in instance of com.vaadin.flow.component.ComponentEventBus$ListenerWrapper

DESERIALIZATION STACK. Process failed at depth 52
  class java.util.HashMap [loadFactor (float), threshold (int)]
  class [Ljava.util.Map$Entry; []
    class com.vaadin.flow.spring.SpringVaadinSession [destroyListeners (interface java.util.List)]
      class com.vaadin.flow.server.VaadinSession [cumulativeRequestDuration (long), lastLocked (long), lastRequestDuration (long), lastRequestTimestamp (long), lastUnlocked (long), nextUIId (int), sessionClosedExplicitly (boolean), attributes (class com.vaadin.flow.server.Attributes), browser (class com.vaadin.flow.server.WebBrowser), configuration (interface com.vaadin.flow.function.DeploymentConfiguration), errorHandler (interface com.vaadin.flow.server.ErrorHandler), locale (class java.util.Locale), pushId (class java.lang.String), requestHandlers (class java.util.LinkedList), resourceRegistry (class com.vaadin.flow.server.StreamResourceRegistry), state (class com.vaadin.flow.server.VaadinSessionState)]
      class com.vaadin.flow.server.Attributes [attributes (class java.util.HashMap)]
        class [Ljava.util.Map$Entry; []
          class com.vaadin.flow.spring.scopes.VaadinUIScope$UIStoreWrapper [session (class com.vaadin.flow.server.VaadinSession), sessionDestroyListenerRegistration (interface com.vaadin.flow.shared.Registration), uiStores (interface java.util.Map)]
            class [Ljava.util.Map$Entry; []
              class java.lang.Integer [value (int)]
              class com.vaadin.flow.spring.scopes.BeanStore [destructionCallbacks (interface java.util.Map), objects (interface java.util.Map), session (class com.vaadin.flow.server.VaadinSession)]
                class [Ljava.util.Map$Entry; []
                  class com.vaadin.starter.bakery.ui.dataproviders.OrdersGridDataProvider [defaultSortOrders (interface java.util.List), orderService (class com.vaadin.starter.bakery.backend.service.OrderService), pageObserver (interface java.util.function.Consumer)]
                    class org.vaadin.artur.spring.dataprovider.FilterablePageableDataProvider [filter (class java.lang.Object)]
                    class [Ljava.util.Map$Entry; []
                      class org.vaadin.artur.spring.dataprovider.PageableDataProvider []
                      class com.vaadin.flow.data.provider.DataChangeEvent [unregisterListenerCommand (interface com.vaadin.flow.server.Command)]
                      class java.util.ArrayList [size (int)]
                      class [Ljava.lang.Object; []
                        class com.vaadin.flow.data.provider.AbstractBackEndDataProvider [sortOrders (interface java.util.List)]
                        class java.util.EventObject []
                        class com.vaadin.flow.data.provider.AbstractDataProvider$DataListenerWrapper [listener (interface com.vaadin.flow.function.SerializableConsumer), registration (interface com.vaadin.flow.shared.Registration)]
                          class com.vaadin.flow.data.provider.AbstractDataProvider [listeners (class java.util.HashMap)]
                          class com.vaadin.flow.data.provider.AbstractDataProvider$1 [this$0 (class com.vaadin.flow.data.provider.AbstractDataProvider), val$listener (interface com.vaadin.flow.data.provider.DataProviderListener)]
                            class java.lang.invoke.SerializedLambda [implMethodKind (int), capturedArgs (class [Ljava.lang.Object;), capturingClass (class java.lang.Class), functionalInterfaceClass (class java.lang.String), functionalInterfaceMethodName (class java.lang.String), functionalInterfaceMethodSignature (class java.lang.String), implClass (class java.lang.String), implMethodName (class java.lang.String), implMethodSignature (class java.lang.String), instantiatedMethodType (class java.lang.String)]
                              class [Ljava.lang.Object; []
                              class [Ljava.lang.Object; []
                                class com.vaadin.flow.data.provider.DataCommunicator [activeStart (int), assumeEmptyClient (boolean), assumedSize (int), definedSize (boolean), fetchEnabled (boolean), itemCountEstimate (int), itemCountEstimateIncrease (int), lastSent (int), nextUpdateId (int), pageSize (int), pagingEnabled (boolean), resendEntireRange (boolean), sizeReset (boolean), skipCountIncreaseUntilReset (boolean), activeKeyOrder (interface java.util.List), arrayUpdater (interface com.vaadin.flow.data.provider.ArrayUpdater), backEndSorting (class java.util.ArrayList), confirmedUpdates (class java.util.HashSet), countCallback (interface com.vaadin.flow.data.provider.CallbackDataProvider$CountCallback), dataGenerator (interface com.vaadin.flow.data.provider.DataGenerator), dataProvider (interface com.vaadin.flow.data.provider.DataProvider), dataProviderUpdateRegistration (interface com.vaadin.flow.shared.Registration), dataUpdater (interface com.vaadin.flow.function.SerializableConsumer), filter (class com.vaadin.flow.data.provider.DataCommunicator$Filter), flushRequest (class com.vaadin.flow.data.provider.DataCommunicator$FlushRequest), flushUpdatedDataRequest (class com.vaadin.flow.data.provider.DataCommunicator$FlushRequest), inMemorySorting (interface com.vaadin.flow.function.SerializableComparator), keyMapper (interface com.vaadin.flow.data.provider.DataKeyMapper), passivatedByUpdate (class java.util.HashMap), requestedRange (class com.vaadin.flow.internal.Range), stateNode (class com.vaadin.flow.internal.StateNode), updatedData (class java.util.HashSet)]
                                  class [Ljava.lang.Object; []
                                  class com.vaadin.flow.component.grid.Grid$GridArrayUpdaterImpl [data (class com.vaadin.flow.component.grid.GridArrayUpdater$UpdateQueueData), this$0 (class com.vaadin.flow.component.grid.Grid), updateQueueFactory (interface com.vaadin.flow.function.SerializableBiFunction)]
                                    class com.vaadin.flow.component.grid.GridArrayUpdater$UpdateQueueData [element (class com.vaadin.flow.dom.Element), hasExpandedItems (interface com.vaadin.flow.function.SerializableSupplier), uniqueKeyProperty (class java.lang.String)]
                                      class com.vaadin.flow.dom.Element []
                                        class com.vaadin.flow.dom.Node [node (class com.vaadin.flow.internal.StateNode), stateProvider (interface com.vaadin.flow.dom.ElementStateProvider)]
                                        class com.vaadin.flow.internal.StateNode [enabled (boolean), hasBeenAttached (boolean), hasBeenDetached (boolean), id (int), isInactiveSelf (boolean), isInitialChanges (boolean), wasAttached (boolean), attachListeners (interface java.util.List), beforeClientResponseEntries (class java.util.ArrayList), changes (interface java.util.Map), detachListeners (interface java.util.List), featureSet (class com.vaadin.flow.internal.StateNode$FeatureSet), features (interface java.io.Serializable), owner (interface com.vaadin.flow.internal.NodeOwner), parent (class com.vaadin.flow.internal.StateNode)]
                                          class [Ljava.lang.Object; []
                                          class [Ljava.lang.Object; []
                                          class com.vaadin.flow.internal.StateNode$FeatureSet [mappings (interface java.util.Map), reportedFeatures (interface java.util.Set)]
                                          class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                          class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                              class com.vaadin.flow.internal.nodefeature.NodeMap$HashMapValues []
                                              class [Ljava.util.Map$Entry; []
                                              class [Ljava.lang.Object; []
                                                  class [Ljava.lang.Object; []
                                                  class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                                  class com.vaadin.flow.internal.StateTree [isRootAttached (boolean), nextBeforeClientResponseIndex (int), nextId (int), dirtyNodes (interface java.util.Set), idToNode (interface java.util.Map), pendingExecutionNodes (interface java.util.Set), rootNode (class com.vaadin.flow.internal.StateNode), uiInternals (class com.vaadin.flow.component.internal.UIInternals)]
                                                    class [Ljava.util.Map$Entry; []
                                                        class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                                            class [Ljava.util.Map$Entry; []
                                                            class com.vaadin.flow.component.charts.Chart [changeListener (interface com.vaadin.flow.component.charts.events.internal.ConfigurationChangeListener), configuration (class com.vaadin.flow.component.charts.model.Configuration), configurationUpdateRegistration (interface com.vaadin.flow.shared.Registration), drillCallbackHandler (class com.vaadin.flow.component.charts.Chart$DrillCallbackHandler), drilldownCallback (interface com.vaadin.flow.component.charts.model.DrilldownCallback)]
                                                                class [Ljava.util.Map$Entry; []
                                                                  class com.vaadin.flow.component.charts.events.ChartLoadEvent []
                                                                  class [Ljava.lang.Object; []
                                                                        class com.vaadin.flow.component.ComponentEventBus$$Lambda$925/0x000000080070a040 [arg$1 (class com.vaadin.flow.component.ComponentEventBus), arg$2 (class java.lang.Class), arg$3 (class com.vaadin.flow.component.ComponentEventBus$ListenerWrapper)]
                                                                        class [Ljava.lang.Object; []
                                                                                class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                                                                    class [Ljava.lang.Object; []
                                                                                        class [Lcom.vaadin.flow.internal.nodefeature.NodeFeature; []
                                                                                            class [Ljava.util.Map$Entry; []
                                                                                                class [Ljava.util.Map$Entry; []
                                                                                                  class [Ljava.lang.Object; []
                                                                                                        class com.vaadin.flow.component.ComponentEventBus$$Lambda$925/0x000000080070a040 [arg$1 (class com.vaadin.flow.component.ComponentEventBus), arg$2 (class java.lang.Class), arg$3 (class com.vaadin.flow.component.ComponentEventBus$ListenerWrapper)]


SERIALIZED LAMBDA CLASS CAST EXCEPTION BEST CANDIDATES:
=======================================================
	[capturingClass=com/vaadin/flow/component/grid/AbstractColumn, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/grid/AbstractColumn.lambda$new$553b070$1:(Lcom/vaadin/flow/component/AttachEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/AttachEvent;)V, numCaptured=1]
	[capturingClass=com/vaadin/flow/component/grid/Grid, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/grid/Grid.lambda$addColumn$4f76937c$1:(Lcom/vaadin/flow/component/grid/Grid$Column;Ljava/lang/String;Lcom/vaadin/flow/component/AttachEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/AttachEvent;)V, numCaptured=3]
	[capturingClass=com/vaadin/flow/component/grid/Grid, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/grid/Grid.onDragStart:(Lcom/vaadin/flow/component/grid/dnd/GridDragStartEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/grid/dnd/GridDragStartEvent;)V, numCaptured=1]
	[capturingClass=com/vaadin/flow/component/grid/Grid, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/grid/Grid.onDragEnd:(Lcom/vaadin/flow/component/grid/dnd/GridDragEndEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/grid/dnd/GridDragEndEvent;)V, numCaptured=1]
	[capturingClass=com/vaadin/starter/bakery/ui/views/dashboard/DashboardView, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/starter/bakery/ui/views/dashboard/DashboardView.lambda$measurePageLoadPerformance$387549c5$1:(Ljava/util/concurrent/atomic/AtomicInteger;Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V, numCaptured=2]
	[capturingClass=com/vaadin/starter/bakery/ui/MainView, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/starter/bakery/ui/MainView.lambda$init$9b1b5227$2:(Lcom/vaadin/flow/component/ClickEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/ClickEvent;)V, numCaptured=0]
	[capturingClass=com/vaadin/flow/component/button/Button, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/button/Button.lambda$new$e38dae27$1:(Lcom/vaadin/flow/component/ClickEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/ClickEvent;)V, numCaptured=1]
	[capturingClass=com/vaadin/starter/bakery/ui/MainView, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/starter/bakery/ui/MainView.lambda$init$9b1b5227$1:(Lcom/vaadin/flow/component/tabs/Tabs$SelectedChangeEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/tabs/Tabs$SelectedChangeEvent;)V, numCaptured=0]
	[capturingClass=com/vaadin/flow/component/login/AbstractLogin, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/flow/component/login/AbstractLogin.lambda$new$9b1b5227$1:(Lcom/vaadin/flow/component/login/AbstractLogin$LoginEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/login/AbstractLogin$LoginEvent;)V, numCaptured=1]

SERIALIZED LAMBDA CLASS CAST EXCEPTION ALL DETECTED TARGETS:
============================================================
	[capturingClass=com/vaadin/flow/data/provider/DataCommunicator, functionalInterfaceClass=com/vaadin/flow/data/provider/DataProviderListener, functionalInterfaceMethod=onDataChange:(Lcom/vaadin/flow/data/provider/DataChangeEvent;)V, implementation=com/vaadin/flow/data/provider/DataCommunicator.lambda$handleAttach$425c8a01$1:(Lcom/vaadin/flow/data/provider/DataChangeEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/data/provider/DataChangeEvent;)V, numCaptured=1]
    [ .... omitted for brevity .... ]
----


For example on the above snippet got navigating to the application [classname]`DashboardView`, the process failed to deserialize a lambda expression into [classname]`com.vaadin.flow.component.ComponentEventListener`.

[source,text]
----
DESERIALIZATION_FAILED: cannot assign instance of java.lang.invoke.SerializedLambda to field com.vaadin.flow.component.ComponentEventBus$ListenerWrapper.listener of type com.vaadin.flow.component.ComponentEventListener in instance of com.vaadin.flow.component.ComponentEventBus$ListenerWrapper
----

From the class graph it can be noticed that the failing lambda is a is a [classname]`com.vaadin.flow.component.charts.Chart` listener for the [classname]`CharLoadEvent`

.Deserialization class graph (some frames are omitted for brevity)
[source,text]
----
class com.vaadin.flow.component.charts.Chart [changeListener (interface com.vaadin.flow.component.charts.events.internal.ConfigurationChangeListener), configuration (class com.vaadin.flow.component.charts.model.Configuration), configurationUpdateRegistration (interface com.vaadin.flow.shared.Registration), drillCallbackHandler (class com.vaadin.flow.component.charts.Chart$DrillCallbackHandler), drilldownCallback (interface com.vaadin.flow.component.charts.model.DrilldownCallback)]
        class com.vaadin.flow.component.charts.events.ChartLoadEvent []
            class com.vaadin.flow.component.ComponentEventBus$$Lambda$925/0x000000080070a040 [arg$1 (class com.vaadin.flow.component.ComponentEventBus), arg$2 (class java.lang.Class), arg$3 (class com.vaadin.flow.component.ComponentEventBus$ListenerWrapper)]
                    nodefeature.NodeFeature; []
                        class com.vaadin.flow.component.ComponentEventBus$$Lambda$925/0x000000080070a040 [arg$1 (class com.vaadin.flow.component.ComponentEventBus), arg$2 (class java.lang.Class), arg$3 (class com.vaadin.flow.component.ComponentEventBus$ListenerWrapper)]
----

Checking the `BEST CANDIDATES` section, it is possible to see that there is an entry whose `implementation` attribute mentions a lambda expression defined in [classname]`DashboardView` that captures a [classname]`ChartLoadEvent`.
Furthermore, the method defining the lambda expression can be detected from the `implementation` attribute.
In the example the value is `implementation=com/vaadin/starter/bakery/ui/views/dashboard/DashboardView.lambda$measurePageLoadPerformance$387549c5$1:(Ljava/util/concurrent/atomic/AtomicInteger;Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V`, and it tells that them method is [methodname]`measurePageLoadPerformance` in [classname]
`DashboardView`.

[source,text]
----
SERIALIZED LAMBDA CLASS CAST EXCEPTION BEST CANDIDATES:
=======================================================
    [ .... omitted .... ]
	[capturingClass=com/vaadin/starter/bakery/ui/views/dashboard/DashboardView, functionalInterfaceClass=com/vaadin/flow/component/ComponentEventListener, functionalInterfaceMethod=onComponentEvent:(Lcom/vaadin/flow/component/ComponentEvent;)V, implementation=com/vaadin/starter/bakery/ui/views/dashboard/DashboardView.lambda$measurePageLoadPerformance$387549c5$1:(Ljava/util/concurrent/atomic/AtomicInteger;Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V, instantiatedMethodType=(Lcom/vaadin/flow/component/charts/events/ChartLoadEvent;)V, numCaptured=2]
    [ .... omitted .... ]
----

The mentioned method presents the following code, and it can be deducted that the issue is that the lambda expression is capturing `this` and providing it to other components that probably stores a reference to it.

[source,java]
----
	private void measurePageLoadPerformance() {
		final int nTotal = 5; // the total number of charts on the page
		AtomicInteger nLoaded = new AtomicInteger();
		ComponentEventListener<ChartLoadEvent> chartLoadListener = (event) -> {
			nLoaded.addAndGet(1);
			if (nLoaded.get() == nTotal) {
				UI.getCurrent().getPage().executeJs("$0._chartsLoadedResolve()", this); // (1)
			}
		};

		todayCountChart.addChartLoadListener(chartLoadListener); // (2)
		deliveriesThisMonthChart.addChartLoadListener(chartLoadListener);
		deliveriesThisYearChart.addChartLoadListener(chartLoadListener);
		yearlySalesGraph.addChartLoadListener(chartLoadListener);
		monthlyProductSplit.addChartLoadListener(chartLoadListener);
	}
----

1. Lambda expression captures `this` instance
2. Lambda expression is used as [classname]`ChartLoadListener`


To fix the issue, replace the lambda expression with an anonymous class.

[source,java]
----
ComponentEventListener<ChartLoadEvent> chartLoadListener = new ComponentEventListener<>() {
    @Override
    public void onComponentEvent(ChartLoadEvent event) {
        nLoaded.addAndGet(1);
        if (nLoaded.get() == nTotal) {
            UI.getCurrent().getPage().executeJs("$0._chartsLoadedResolve()", DashboardView.this);
        }
    }
};
----