/**
 * NOTICE: this is an auto-generated file
 *
 * This file has been generated by the `flow:prepare-frontend` maven goal.
 * This file will be overwritten on every run. Any custom changes should be made to vite.config.ts
 */
import path from 'path';
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from 'fs';
import { createHash } from 'crypto';
import * as net from 'net';

import { processThemeResources } from './target/plugins/application-theme-plugin/theme-handle.js';
import { rewriteCssUrls } from './target/plugins/theme-loader/theme-loader-utils.js';
import settings from './target/vaadin-dev-server-settings.json';
import {
  AssetInfo,
  ChunkInfo,
  defineConfig,
  mergeConfig,
  OutputOptions,
  PluginOption,
  ResolvedConfig,
  UserConfigFn
} from 'vite';
import { getManifest } from 'workbox-build';

import * as rollup from 'rollup';
import brotli from 'rollup-plugin-brotli';
import replace from '@rollup/plugin-replace';
import checker from 'vite-plugin-checker';
import postcssLit from './target/plugins/rollup-plugin-postcss-lit-custom/rollup-plugin-postcss-lit.js';

import { createRequire } from 'module';

import { visualizer } from 'rollup-plugin-visualizer';

// Make `require` compatible with ES modules
const require = createRequire(import.meta.url);

const appShellUrl = '.';

const frontendFolder = path.resolve(__dirname, settings.frontendFolder);
const themeFolder = path.resolve(frontendFolder, settings.themeFolder);
const frontendBundleFolder = path.resolve(__dirname, settings.frontendBundleOutput);
const devBundleFolder = path.resolve(__dirname, settings.devBundleOutput);
const devBundle = !!process.env.devBundle;
const jarResourcesFolder = path.resolve(__dirname, settings.jarResourcesFolder);
const themeResourceFolder = path.resolve(__dirname, settings.themeResourceFolder);
const projectPackageJsonFile = path.resolve(__dirname, 'package.json');

const buildOutputFolder = devBundle ? devBundleFolder : frontendBundleFolder;
const statsFolder = path.resolve(__dirname, devBundle ? settings.devBundleStatsOutput : settings.statsOutput);
const statsFile = path.resolve(statsFolder, 'stats.json');
const bundleSizeFile = path.resolve(statsFolder, 'bundle-size.html');
const nodeModulesFolder = path.resolve(__dirname, 'node_modules');
const webComponentTags = 'date-time-picker-range-wc;icon-fonts-wc;date-picker-week-numbers-wc;menu-bar-dividers-wc;date-time-picker-readonly-and-disabled-wc;split-layout-toggle-wc;checkbox-group-styles-wc;grid-rich-content-sorting-wc;text-area-basic-wc;form-layout-colspan-wc;menu-bar-drop-down-wc;grid-multi-sort-wc;checkbox-indeterminate-wc;password-field-styles-wc;grid-drag-rows-between-grids-wc;text-field-readonly-and-disabled-wc;date-time-picker-initial-position-wc;basic-layouts-vertical-layout-horizontal-alignment-wc;grid-pro-basic-wc;app-layout-navbar-placement-side-wc;badge-highlight-wc;upload-file-size-wc;icons-padding-wc;events-lambda-wc;combo-box-readonly-and-disabled-wc;login-overlay-custom-form-area-wc;rich-text-editor-set-get-value-wc;scroller-mobile-wc;side-nav-styling-wc;menu-bar-icon-only-wc;notification-position-wc;events-method-wc;details-filled-wc;checkbox-labeling-wc;cookie-consent-theming-wc;messages-basic-wc;radio-button-group-labels-wc;date-picker-basic-features-wc;password-field-basic-features-wc;password-field-helper-wc;details-basic-wc;context-menu-hierarchical-wc;board-column-wrapping-wc;badge-icons-wc;tree-grid-basic-wc;avatar-group-internationalisation-wc;radio-button-group-styles-wc;spreadsheet-loading-wc;tooltip-manual-wc;button-contrast-wc;time-picker-basic-wc;combo-box-auto-open-wc;spreadsheet-frozen-panes-wc;select-basic-features-wc;button-success-wc;date-picker-readonly-and-disabled-wc;tabs-hide-scroll-buttons-wc;dialog-resizable-wc;number-field-big-decimal-wc;notification-retry-wc;confirm-dialog-basic-wc;upload-labelling-wc;list-box-separators-wc;combo-box-styles-wc;tabs-theme-minimal-wc;avatar-group-bg-color-wc;radio-button-group-basic-features-wc;map-marker-drag-drop-wc;radio-button-horizontal-wc;button-form-wc;multi-select-combo-box-read-only-wc;menu-bar-icons-wc;date-time-picker-minutes-step-wc;number-field-integer-wc;grid-basic-wc;basic-layouts-vertical-layout-individual-alignment-wc;button-dialog-wc;grid-pro-single-click-wc;radio-button-basic-wc;crud-sorting-filtering-wc;spreadsheet-fonts-wc;grid-sorting-wc;grid-column-freezing-wc;grid-cell-focus-wc;spreadsheet-format-wc;text-field-styles-wc;list-box-custom-item-presentation-wc;grid-compact-wc;progress-bar-completion-time-wc;grid-content-wc;events-anon-wc;password-field-reveal-button-hidden-wc;spreadsheet-grouping-wc;tabs-vertical-wc;notification-keyboard-a11y-wc;grid-pro-single-cell-edit-wc;multi-select-combo-box-basic-wc;rich-text-editor-theme-no-border-wc;grid-pro-editor-wc;button-disabled-wc;grid-row-stripes-wc;app-layout-navbar-wc;button-disable-long-action-wc;date-picker-min-max-wc;progress-bar-label-wc;date-picker-custom-format-wc;combo-box-basic-wc;board-column-span-wc;app-layout-drawer-wc;select-disabled-wc;checkbox-basic-wc;crud-localization-wc;map-sources-wc;icons-inside-wc;events-basic-wc;number-field-basic-wc;date-time-picker-basic-wc;app-layout-height-auto-wc;message-list-with-theme-component-wc;button-tertiary-inline-wc;combo-box-basic-features-wc;notification-primary-wc;menu-bar-custom-theme-wc;text-field-basic-features-wc;grid-wrap-cell-content-wc;accordion-reverse-panels-wc;tree-grid-column-wc;time-picker-custom-validation-wc;login-rich-content-wc;details-disabled-wc;message-input-component-wc;accordion-basic-wc;notification-undo-wc;cookie-consent-basic-wc;map-basic-wc;dialog-draggable-wc;login-additional-information-wc;basic-layouts-vertical-layout-wc;date-picker-auto-open-wc;details-summary-wc;dialog-basic-wc;text-area-helper-wc;basic-layouts-padding-wc;grid-column-borders-wc;basic-layouts-horizontal-layout-vertical-alignment-wc;notification-contrast-wc;form-layout-custom-layout-wc;context-menu-dividers-wc;badge-basic-wc;tabs-content-wc;menu-bar-tooltip-wc;select-custom-renderer-label-wc;grid-multi-selection-mode-wc;checkbox-disabled-wc;text-area-basic-features-wc;select-styles-wc;map-markers-wc;select-complex-value-label-wc;multi-select-combo-box-selection-wc;email-field-basic-features-wc;app-layout-basic-wc;time-picker-custom-parser-wc;rich-text-editor-theme-compact-wc;dialog-header-wc;grid-column-filtering-wc;avatar-menu-bar-wc;text-area-styles-wc;tab-sheet-lazy-initialization-wc;rich-text-editor-readonly-wc;date-time-picker-week-numbers-wc;date-time-picker-styles-wc;login-basic-wc;grid-tooltip-generator-wc;spreadsheet-components-wc;progress-bar-determinate-wc;dialog-footer-wc;button-styles-wc;date-time-picker-min-max-wc;split-layout-minimal-theme-variants-wc;message-list-component-wc;text-area-auto-height-wc;basic-layouts-spacing-wc;badge-icons-only-wc;crud-hidden-toolbar-wc;menu-bar-checkable-wc;badge-size-wc;login-overlay-internationalization-wc;grid-column-header-footer-wc;icons-basic-wc;accordion-summary-wc;button-icons-wc;tooltip-basic-wc;number-field-step-wc;multi-select-combo-box-i18n-demo-wc;scroller-basic-wc;dialog-closing-wc;details-small-wc;button-basic-wc;notification-basic-wc;svg-standalone-wc;checkbox-group-basic-wc;tabs-theme-small-wc;number-field-basic-features-wc;date-picker-individual-input-fields-wc;select-readonly-and-disabled-wc;grid-single-selection-mode-wc;email-field-styles-wc;side-nav-suffix-wc;avatar-sizes-wc;map-viewport-wc;grid-context-menu-example-wc;time-picker-basic-features-wc;form-layout-side-wc;email-field-readonly-and-disabled-wc;board-nested-wc;crud-item-initialization-wc;app-layout-height-full-wc;confirm-dialog-confirm-button-wc;combo-box-presentation-wc;password-field-basic-wc;image-class-resource-wc;spreadsheet-filtering-wc;lumo-icons-wc;rich-text-editor-min-max-height-wc;grid-data-provider-wc;date-picker-locale-wc;date-picker-styles-wc;grid-item-details-toggle-wc;grid-column-alignment-wc;badge-interactive-wc;grid-column-width-wc;tabs-basic-wc;details-reverse-wc;split-layout-initial-splitter-position-wc;upload-internationalization-wc;grid-pro-prevent-save-wc;checkbox-vertical-wc;upload-drop-label-wc;tooltip-positioning-wc;map-layers-wc;login-overlay-basic-wc;grid-row-reordering-wc;password-field-constraints-wc;grid-lazy-column-rendering-wc;form-layout-custom-field-wc;spreadsheet-basic-wc;app-layout-bottom-navbar-wc;custom-field-basic-wc;grid-pro-enter-next-row-wc;grid-no-border-wc;side-nav-basic-wc;select-placeholder-wc;crud-columns-wc;date-picker-basic-wc;custom-field-size-variants-wc;basic-layouts-horizontal-layout-wc;number-field-readonly-and-disabled-wc;menu-bar-overflow-wc;select-empty-selection-caption-wc;date-time-picker-seconds-step-wc;spreadsheet-comments-wc;map-events-wc;time-picker-seconds-step-wc;avatar-name-wc;combo-box-constraints-wc;tabs-icons-horizontal-wc;tabs-theme-centered-wc;upload-helper-wc;icons-sizing-wc;map-marker-text-wc;grid-pro-theme-highlight-read-only-cells-wc;date-picker-date-range-wc;image-basic-wc;number-field-styles-wc;progress-bar-custom-range-wc;text-field-constraints-wc;basic-layouts-horizontal-layout-horizontal-alignment-wc;icon-basic-wc;radio-button-presentation-wc;combo-box-filtering2-wc;grid-external-filtering-wc;notification-success-wc;progress-bar-theme-variants-wc;menu-bar-right-aligned-wc;multi-select-combo-box-selection-change-wc;tabs-theme-equal-width-wc;checkbox-adjacent-groups-wc;radio-button-vertical-wc;crud-editor-content-wc;upload-file-format-wc;grid-column-grouping-wc;login-overlay-footer-wc;list-box-multi-selection-wc;app-layout-secondary-navigation-wc;button-labels-wc;grid-pro-edit-column-wc;button-images-wc;list-box-single-selection-wc;radio-button-readonly-wc;date-time-picker-internationalization-wc;split-layout-basic-wc;avatar-group-max-items-wc;select-dividers-wc;date-time-picker-auto-open-wc;select-presentation-wc;accordion-filled-panels-wc;map-theme-borderless-wc;context-menu-best-practices-wc;login-screen-wc;upload-file-count-wc;email-field-constraints-wc;grid-drag-drop-filters-wc;menu-bar-internationalization-wc;login-overlay-header-wc;time-picker-auto-open-wc;icons-color-wc;split-layout-min-max-size-wc;password-field-readonly-and-disabled-wc;grid-buffered-inline-editor-wc;upload-all-files-wc;custom-field-native-input-wc;svg-sprites-wc;tabs-autoselect-wc;split-layout-orientation-wc;button-error-wc;date-picker-custom-validation-wc;button-grid-wc;date-time-picker-input-format-wc;upload-error-messages-wc;tab-sheet-prefix-suffix-wc;text-field-basic-wc;side-nav-hierarchy-wc;date-picker-date-format-indicator-wc;rich-text-editor-basic-wc;board-breakpoints-wc;tabs-icons-vertical-wc;upload-auto-upload-disabled-wc;avatar-image-wc;crud-basic-wc;date-time-picker-basic-features-wc;context-menu-left-click-wc;text-area-readonly-and-disabled-wc;grid-styling-wc;grid-column-reordering-resizing-wc;text-area-constraints-wc;cookie-consent-localization-wc;email-field-basic-wc;upload-button-theme-variant-wc;virtual-list-basic-wc;context-menu-disabled-wc;notification-link-wc;basic-layouts-margin-wc;checkbox-horizontal-wc;grid-no-row-border-wc;combo-box-custom-entry2-wc;side-nav-labelled-wc;spreadsheet-charts-wc;context-menu-basic-wc;basic-layouts-expanding-items-wc;menu-bar-open-on-hover-wc;badge-color-wc;ui-menu-wc;basic-layouts-spacing-variants-wc;tooltip-html-element-wc;grid-unbuffered-inline-editor-wc;details-content-wc;accordion-disabled-panels-wc;avatar-basic-wc;tabs-badges-wc;accordion-content-wc;radio-button-disabled-wc;crud-editor-aside-wc;notification-popup-wc;text-area-height-wc;login-internationalization-wc;accordion-small-panels-wc;confirm-dialog-reject-button-wc;avatar-group-basic-wc;crud-editor-bottom-wc;form-layout-basic-wc;number-field-min-max-wc;tab-sheet-basic-wc;form-layout-native-input-wc;notification-rich-wc;tree-grid-rich-content-wc;time-picker-styles-wc;date-time-picker-custom-validation-wc;menu-bar-basic-wc;password-field-advanced-helper-wc;tabs-states-wc;combo-box-custom-entry1-wc;time-picker-readonly-and-disabled-wc;checkbox-group-basic-features-wc;tab-sheet-theme-bordered-wc;grid-column-visibility-wc;confirm-dialog-cancel-button-wc;login-validation-wc;icons-accessibility-wc;basic-layouts-vertical-layout-vertical-alignment-wc;context-menu-checkable-wc;upload-basic-wc;grid-item-details-wc;list-box-basic-wc;progress-bar-indeterminate-wc;scroller-both-wc;context-menu-presentation-wc;vaadin-icons-wc;crud-grid-replacement-wc;badge-counter-wc;menu-bar-styles-wc;button-sizes-wc;time-picker-min-max-wc;notification-static-helper-wc;notification-warning-wc;crud-open-editor-wc;number-field-step-buttons-wc;select-basic-wc;grid-pro-theme-highlight-editable-cells-wc;combo-box-popup-width-wc;split-layout-theme-variants-wc;date-picker-internationalization-wc;badge-icons-only-table-wc;grid-dynamic-height-wc;dialog-no-padding-wc;tabs-horizontal-wc;menu-bar-combo-buttons-wc;list-box-disabled-items-wc;radio-button-custom-option-wc;select-empty-selection-wc;notification-error-wc;time-picker-minutes-step-wc;date-picker-initial-position-wc;crud-toolbar-wc;basic-layouts-horizontal-layout-individual-alignment-wc;spreadsheet-report-mode-wc;badge-shape-wc;upload-drag-and-drop-wc;progress-bar-basic-wc;board-basic-wc;app-layout-navbar-placement-wc;avatar-abbreviation-wc;menu-bar-disabled-wc;data-binding-wc';

const projectIndexHtml = path.resolve(frontendFolder, 'index.html');

const projectStaticAssetsFolders = [
  path.resolve(__dirname, 'src', 'main', 'resources', 'META-INF', 'resources'),
  path.resolve(__dirname, 'src', 'main', 'resources', 'static'),
  frontendFolder
];

// Folders in the project which can contain application themes
const themeProjectFolders = projectStaticAssetsFolders.map((folder) => path.resolve(folder, settings.themeFolder));

const themeOptions = {
  devMode: false,
  useDevBundle: devBundle,
  // The following matches folder 'frontend/generated/themes/'
  // (not 'frontend/themes') for theme in JAR that is copied there
  themeResourceFolder: path.resolve(themeResourceFolder, settings.themeFolder),
  themeProjectFolders: themeProjectFolders,
  projectStaticAssetsOutputFolder: devBundle
    ? path.resolve(devBundleFolder, '../assets')
    : path.resolve(__dirname, settings.staticOutput),
  frontendGeneratedFolder: path.resolve(frontendFolder, settings.generatedFolder)
};

const hasExportedWebComponents = existsSync(path.resolve(frontendFolder, 'web-component.html'));

// Block debug and trace logs.
console.trace = () => {};
console.debug = () => {};

function injectManifestToSWPlugin(): rollup.Plugin {
  const rewriteManifestIndexHtmlUrl = (manifest) => {
    const indexEntry = manifest.find((entry) => entry.url === 'index.html');
    if (indexEntry) {
      indexEntry.url = appShellUrl;
    }

    return { manifest, warnings: [] };
  };

  return {
    name: 'vaadin:inject-manifest-to-sw',
    async transform(code, id) {
      if (/sw\.(ts|js)$/.test(id)) {
        const { manifestEntries } = await getManifest({
          globDirectory: buildOutputFolder,
          globPatterns: ['**/*'],
          globIgnores: ['**/*.br'],
          manifestTransforms: [rewriteManifestIndexHtmlUrl],
          maximumFileSizeToCacheInBytes: 100 * 1024 * 1024 // 100mb,
        });

        return code.replace('self.__WB_MANIFEST', JSON.stringify(manifestEntries));
      }
    }
  };
}

function buildSWPlugin(opts): PluginOption {
  let config: ResolvedConfig;
  const devMode = opts.devMode;

  const swObj = {};

  async function build(action: 'generate' | 'write', additionalPlugins: rollup.Plugin[] = []) {
    const includedPluginNames = [
      'vite:esbuild',
      'rollup-plugin-dynamic-import-variables',
      'vite:esbuild-transpile',
      'vite:terser'
    ];
    const plugins: rollup.Plugin[] = config.plugins.filter((p) => {
      return includedPluginNames.includes(p.name);
    });
    const resolver = config.createResolver();
    const resolvePlugin: rollup.Plugin = {
      name: 'resolver',
      resolveId(source, importer, _options) {
        return resolver(source, importer);
      }
    };
    plugins.unshift(resolvePlugin); // Put resolve first
    plugins.push(
      replace({
        values: {
          'process.env.NODE_ENV': JSON.stringify(config.mode),
          ...config.define
        },
        preventAssignment: true
      })
    );
    if (additionalPlugins) {
      plugins.push(...additionalPlugins);
    }
    const bundle = await rollup.rollup({
      input: path.resolve(settings.clientServiceWorkerSource),
      plugins
    });

    try {
      return await bundle[action]({
        file: path.resolve(buildOutputFolder, 'sw.js'),
        format: 'es',
        exports: 'none',
        sourcemap: config.command === 'serve' || config.build.sourcemap,
        inlineDynamicImports: true
      });
    } finally {
      await bundle.close();
    }
  }

  return {
    name: 'vaadin:build-sw',
    enforce: 'post',
    async configResolved(resolvedConfig) {
      config = resolvedConfig;
    },
    async buildStart() {
      if (devMode) {
        const { output } = await build('generate');
        swObj.code = output[0].code;
        swObj.map = output[0].map;
      }
    },
    async load(id) {
      if (id.endsWith('sw.js')) {
        return '';
      }
    },
    async transform(_code, id) {
      if (id.endsWith('sw.js')) {
        return swObj;
      }
    },
    async closeBundle() {
      if (!devMode) {
        await build('write', [injectManifestToSWPlugin(), brotli()]);
      }
    }
  };
}

function statsExtracterPlugin(): PluginOption {
  function collectThemeJsonsInFrontend(themeJsonContents: Record<string, string>, themeName: string) {
    const themeJson = path.resolve(frontendFolder, settings.themeFolder, themeName, 'theme.json');
    if (existsSync(themeJson)) {
      const themeJsonContent = readFileSync(themeJson, { encoding: 'utf-8' }).replace(/\r\n/g, '\n');
      themeJsonContents[themeName] = themeJsonContent;
      const themeJsonObject = JSON.parse(themeJsonContent);
      if (themeJsonObject.parent) {
        collectThemeJsonsInFrontend(themeJsonContents, themeJsonObject.parent);
      }
    }
  }

  return {
    name: 'vaadin:stats',
    enforce: 'post',
    async writeBundle(options: OutputOptions, bundle: { [fileName: string]: AssetInfo | ChunkInfo }) {
      const modules = Object.values(bundle).flatMap((b) => (b.modules ? Object.keys(b.modules) : []));
      const nodeModulesFolders = modules
        .map((id) => id.replace(/\\/g, '/'))
        .filter((id) => id.startsWith(nodeModulesFolder.replace(/\\/g, '/')))
        .map((id) => id.substring(nodeModulesFolder.length + 1));
      const npmModules = nodeModulesFolders
        .map((id) => id.replace(/\\/g, '/'))
        .map((id) => {
          const parts = id.split('/');
          if (id.startsWith('@')) {
            return parts[0] + '/' + parts[1];
          } else {
            return parts[0];
          }
        })
        .sort()
        .filter((value, index, self) => self.indexOf(value) === index);
      const npmModuleAndVersion = Object.fromEntries(npmModules.map((module) => [module, getVersion(module)]));
      const cvdls = Object.fromEntries(
        npmModules
          .filter((module) => getCvdlName(module) != null)
          .map((module) => [module, { name: getCvdlName(module), version: getVersion(module) }])
      );

      mkdirSync(path.dirname(statsFile), { recursive: true });
      const projectPackageJson = JSON.parse(readFileSync(projectPackageJsonFile, { encoding: 'utf-8' }));

      const entryScripts = Object.values(bundle)
        .filter((bundle) => bundle.isEntry)
        .map((bundle) => bundle.fileName);

      const generatedIndexHtml = path.resolve(buildOutputFolder, 'index.html');
      const customIndexData: string = readFileSync(projectIndexHtml, { encoding: 'utf-8' });
      const generatedIndexData: string = readFileSync(generatedIndexHtml, {
        encoding: 'utf-8'
      });

      const customIndexRows = new Set(customIndexData.split(/[\r\n]/).filter((row) => row.trim() !== ''));
      const generatedIndexRows = generatedIndexData.split(/[\r\n]/).filter((row) => row.trim() !== '');

      const rowsGenerated: string[] = [];
      generatedIndexRows.forEach((row) => {
        if (!customIndexRows.has(row)) {
          rowsGenerated.push(row);
        }
      });

      //After dev-bundle build add used Flow frontend imports JsModule/JavaScript/CssImport

      const parseImports = (filename: string, result: Set<string>): void => {
        const content: string = readFileSync(filename, { encoding: 'utf-8' });
        const lines = content.split('\n');
        const staticImports = lines
          .filter((line) => line.startsWith('import '))
          .map((line) => line.substring(line.indexOf("'") + 1, line.lastIndexOf("'")))
          .map((line) => (line.includes('?') ? line.substring(0, line.lastIndexOf('?')) : line));
        const dynamicImports = lines
          .filter((line) => line.includes('import('))
          .map((line) => line.replace(/.*import\(/, ''))
          .map((line) => line.split(/'/)[1])
          .map((line) => (line.includes('?') ? line.substring(0, line.lastIndexOf('?')) : line));

        staticImports.forEach((staticImport) => result.add(staticImport));

        dynamicImports.map((dynamicImport) => {
          const importedFile = path.resolve(path.dirname(filename), dynamicImport);
          parseImports(importedFile, result);
        });
      };

      const generatedImportsSet = new Set<string>();
      parseImports(
        path.resolve(themeOptions.frontendGeneratedFolder, 'flow', 'generated-flow-imports.js'),
        generatedImportsSet
      );
      const generatedImports = Array.from(generatedImportsSet).sort();

      const frontendFiles: Record<string, string> = {};

      const projectFileExtensions = ['.js', '.js.map', '.ts', '.ts.map', '.tsx', '.tsx.map', '.css', '.css.map'];

      // collects project's frontend resources in frontend folder, excluding
      // 'generated' sub-folder
      modules
        .map((id) => id.replace(/\\/g, '/'))
        .filter((id) => id.startsWith(frontendFolder.replace(/\\/g, '/')))
        .filter((id) => !id.startsWith(themeOptions.frontendGeneratedFolder.replace(/\\/g, '/')))
        .map((id) => id.substring(frontendFolder.length + 1))
        .map((line: string) => (line.includes('?') ? line.substring(0, line.lastIndexOf('?')) : line))
        .forEach((line: string) => {
          // \r\n from windows made files may be used so change to \n
          const filePath = path.resolve(frontendFolder, line);
          if (projectFileExtensions.includes(path.extname(filePath))) {
            const fileBuffer = readFileSync(filePath, { encoding: 'utf-8' }).replace(/\r\n/g, '\n');
            frontendFiles[line] = createHash('sha256').update(fileBuffer, 'utf8').digest('hex');
          }
        });

      // collects frontend resources from the JARs
      generatedImports
        .filter((line: string) => line.includes('generated/jar-resources'))
        .forEach((line: string) => {
          let filename = line.substring(line.indexOf('generated'));
          // \r\n from windows made files may be used ro remove to be only \n
          const fileBuffer = readFileSync(path.resolve(frontendFolder, filename), { encoding: 'utf-8' }).replace(
            /\r\n/g,
            '\n'
          );
          const hash = createHash('sha256').update(fileBuffer, 'utf8').digest('hex');

          const fileKey = line.substring(line.indexOf('jar-resources/') + 14);
          frontendFiles[fileKey] = hash;
        });
      // If a index.ts exists hash it to be able to see if it changes.
      if (existsSync(path.resolve(frontendFolder, 'index.ts'))) {
        const fileBuffer = readFileSync(path.resolve(frontendFolder, 'index.ts'), { encoding: 'utf-8' }).replace(
          /\r\n/g,
          '\n'
        );
        frontendFiles[`index.ts`] = createHash('sha256').update(fileBuffer, 'utf8').digest('hex');
      }

      const themeJsonContents: Record<string, string> = {};
      const themesFolder = path.resolve(jarResourcesFolder, 'themes');
      if (existsSync(themesFolder)) {
        readdirSync(themesFolder).forEach((themeFolder) => {
          const themeJson = path.resolve(themesFolder, themeFolder, 'theme.json');
          if (existsSync(themeJson)) {
            themeJsonContents[path.basename(themeFolder)] = readFileSync(themeJson, { encoding: 'utf-8' }).replace(
              /\r\n/g,
              '\n'
            );
          }
        });
      }

      collectThemeJsonsInFrontend(themeJsonContents, settings.themeName);

      let webComponents: string[] = [];
      if (webComponentTags) {
        webComponents = webComponentTags.split(';');
      }

      const stats = {
        packageJsonDependencies: projectPackageJson.dependencies,
        npmModules: npmModuleAndVersion,
        bundleImports: generatedImports,
        frontendHashes: frontendFiles,
        themeJsonContents: themeJsonContents,
        entryScripts,
        webComponents,
        cvdlModules: cvdls,
        packageJsonHash: projectPackageJson?.vaadin?.hash,
        indexHtmlGenerated: rowsGenerated
      };
      writeFileSync(statsFile, JSON.stringify(stats, null, 1));
    }
  };
}
function vaadinBundlesPlugin(): PluginOption {
  type ExportInfo =
    | string
    | {
        namespace?: string;
        source: string;
      };

  type ExposeInfo = {
    exports: ExportInfo[];
  };

  type PackageInfo = {
    version: string;
    exposes: Record<string, ExposeInfo>;
  };

  type BundleJson = {
    packages: Record<string, PackageInfo>;
  };

  const disabledMessage = 'Vaadin component dependency bundles are disabled.';

  const modulesDirectory = nodeModulesFolder.replace(/\\/g, '/');

  let vaadinBundleJson: BundleJson;

  function parseModuleId(id: string): { packageName: string; modulePath: string } {
    const [scope, scopedPackageName] = id.split('/', 3);
    const packageName = scope.startsWith('@') ? `${scope}/${scopedPackageName}` : scope;
    const modulePath = `.${id.substring(packageName.length)}`;
    return {
      packageName,
      modulePath
    };
  }

  function getExports(id: string): string[] | undefined {
    const { packageName, modulePath } = parseModuleId(id);
    const packageInfo = vaadinBundleJson.packages[packageName];

    if (!packageInfo) return;

    const exposeInfo: ExposeInfo = packageInfo.exposes[modulePath];
    if (!exposeInfo) return;

    const exportsSet = new Set<string>();
    for (const e of exposeInfo.exports) {
      if (typeof e === 'string') {
        exportsSet.add(e);
      } else {
        const { namespace, source } = e;
        if (namespace) {
          exportsSet.add(namespace);
        } else {
          const sourceExports = getExports(source);
          if (sourceExports) {
            sourceExports.forEach((e) => exportsSet.add(e));
          }
        }
      }
    }
    return Array.from(exportsSet);
  }

  function getExportBinding(binding: string) {
    return binding === 'default' ? '_default as default' : binding;
  }

  function getImportAssigment(binding: string) {
    return binding === 'default' ? 'default: _default' : binding;
  }

  return {
    name: 'vaadin:bundles',
    enforce: 'pre',
    apply(config, { command }) {
      if (command !== 'serve') return false;

      try {
        const vaadinBundleJsonPath = require.resolve('@vaadin/bundles/vaadin-bundle.json');
        vaadinBundleJson = JSON.parse(readFileSync(vaadinBundleJsonPath, { encoding: 'utf8' }));
      } catch (e: unknown) {
        if (typeof e === 'object' && (e as { code: string }).code === 'MODULE_NOT_FOUND') {
          vaadinBundleJson = { packages: {} };
          console.info(`@vaadin/bundles npm package is not found, ${disabledMessage}`);
          return false;
        } else {
          throw e;
        }
      }

      const versionMismatches: Array<{ name: string; bundledVersion: string; installedVersion: string }> = [];
      for (const [name, packageInfo] of Object.entries(vaadinBundleJson.packages)) {
        let installedVersion: string | undefined = undefined;
        try {
          const { version: bundledVersion } = packageInfo;
          const installedPackageJsonFile = path.resolve(modulesDirectory, name, 'package.json');
          const packageJson = JSON.parse(readFileSync(installedPackageJsonFile, { encoding: 'utf8' }));
          installedVersion = packageJson.version;
          if (installedVersion && installedVersion !== bundledVersion) {
            versionMismatches.push({
              name,
              bundledVersion,
              installedVersion
            });
          }
        } catch (_) {
          // ignore package not found
        }
      }
      if (versionMismatches.length) {
        console.info(`@vaadin/bundles has version mismatches with installed packages, ${disabledMessage}`);
        console.info(`Packages with version mismatches: ${JSON.stringify(versionMismatches, undefined, 2)}`);
        vaadinBundleJson = { packages: {} };
        return false;
      }

      return true;
    },
    async config(config) {
      return mergeConfig(
        {
          optimizeDeps: {
            exclude: [
              // Vaadin bundle
              '@vaadin/bundles',
              ...Object.keys(vaadinBundleJson.packages),
              '@vaadin/vaadin-material-styles'
            ]
          }
        },
        config
      );
    },
    load(rawId) {
      const [path, params] = rawId.split('?');
      if (!path.startsWith(modulesDirectory)) return;

      const id = path.substring(modulesDirectory.length + 1);
      const bindings = getExports(id);
      if (bindings === undefined) return;

      const cacheSuffix = params ? `?${params}` : '';
      const bundlePath = `@vaadin/bundles/vaadin.js${cacheSuffix}`;

      return `import { init as VaadinBundleInit, get as VaadinBundleGet } from '${bundlePath}';
await VaadinBundleInit('default');
const { ${bindings.map(getImportAssigment).join(', ')} } = (await VaadinBundleGet('./node_modules/${id}'))();
export { ${bindings.map(getExportBinding).join(', ')} };`;
    }
  };
}

function themePlugin(opts): PluginOption {
  const fullThemeOptions = { ...themeOptions, devMode: opts.devMode };
  return {
    name: 'vaadin:theme',
    config() {
      processThemeResources(fullThemeOptions, console);
    },
    configureServer(server) {
      function handleThemeFileCreateDelete(themeFile, stats) {
        if (themeFile.startsWith(themeFolder)) {
          const changed = path.relative(themeFolder, themeFile);
          console.debug('Theme file ' + (!!stats ? 'created' : 'deleted'), changed);
          processThemeResources(fullThemeOptions, console);
        }
      }
      server.watcher.on('add', handleThemeFileCreateDelete);
      server.watcher.on('unlink', handleThemeFileCreateDelete);
    },
    handleHotUpdate(context) {
      const contextPath = path.resolve(context.file);
      const themePath = path.resolve(themeFolder);
      if (contextPath.startsWith(themePath)) {
        const changed = path.relative(themePath, contextPath);

        console.debug('Theme file changed', changed);

        if (changed.startsWith(settings.themeName)) {
          processThemeResources(fullThemeOptions, console);
        }
      }
    },
    async resolveId(id, importer) {
      // force theme generation if generated theme sources does not yet exist
      // this may happen for example during Java hot reload when updating
      // @Theme annotation value
      if (
        path.resolve(themeOptions.frontendGeneratedFolder, 'theme.js') === importer &&
        !existsSync(path.resolve(themeOptions.frontendGeneratedFolder, id))
      ) {
        console.debug('Generate theme file ' + id + ' not existing. Processing theme resource');
        processThemeResources(fullThemeOptions, console);
        return;
      }
      if (!id.startsWith(settings.themeFolder)) {
        return;
      }

      for (const location of [themeResourceFolder, frontendFolder]) {
        const result = await this.resolve(path.resolve(location, id));
        if (result) {
          return result;
        }
      }
    },
    async transform(raw, id, options) {
      // rewrite urls for the application theme css files
      const [bareId, query] = id.split('?');
      if (
        (!bareId?.startsWith(themeFolder) && !bareId?.startsWith(themeOptions.themeResourceFolder)) ||
        !bareId?.endsWith('.css')
      ) {
        return;
      }
      const [themeName] = bareId.substring(themeFolder.length + 1).split('/');
      return rewriteCssUrls(raw, path.dirname(bareId), path.resolve(themeFolder, themeName), console, opts);
    }
  };
}

function runWatchDog(watchDogPort, watchDogHost) {
  const client = net.Socket();
  client.setEncoding('utf8');
  client.on('error', function (err) {
    console.log('Watchdog connection error. Terminating vite process...', err);
    client.destroy();
    process.exit(0);
  });
  client.on('close', function () {
    client.destroy();
    runWatchDog(watchDogPort, watchDogHost);
  });

  client.connect(watchDogPort, watchDogHost || 'localhost');
}

let spaMiddlewareForceRemoved = false;

const allowedFrontendFolders = [frontendFolder, nodeModulesFolder];

function showRecompileReason(): PluginOption {
  return {
    name: 'vaadin:why-you-compile',
    handleHotUpdate(context) {
      console.log('Recompiling because', context.file, 'changed');
    }
  };
}

const DEV_MODE_START_REGEXP = /\/\*[\*!]\s+vaadin-dev-mode:start/;
const DEV_MODE_CODE_REGEXP = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;

function preserveUsageStats() {
  return {
    name: 'vaadin:preserve-usage-stats',

    transform(src: string, id: string) {
      if (id.includes('vaadin-usage-statistics')) {
        if (src.includes('vaadin-dev-mode:start')) {
          const newSrc = src.replace(DEV_MODE_START_REGEXP, '/*! vaadin-dev-mode:start');
          if (newSrc === src) {
            console.error('Comment replacement failed to change anything');
          } else if (!newSrc.match(DEV_MODE_CODE_REGEXP)) {
            console.error('New comment fails to match original regexp');
          } else {
            return { code: newSrc };
          }
        }
      }

      return { code: src };
    }
  };
}

export const vaadinConfig: UserConfigFn = (env) => {
  const devMode = env.mode === 'development';
  const productionMode = !devMode && !devBundle

  if (devMode && process.env.watchDogPort) {
    // Open a connection with the Java dev-mode handler in order to finish
    // vite when it exits or crashes.
    runWatchDog(process.env.watchDogPort, process.env.watchDogHost);
  }

  return {
    root: frontendFolder,
    base: '',
    resolve: {
      alias: {
        '@vaadin/flow-frontend': jarResourcesFolder,
        Frontend: frontendFolder
      },
      preserveSymlinks: true
    },
    define: {
      OFFLINE_PATH: settings.offlinePath,
      VITE_ENABLED: 'true'
    },
    server: {
      host: '127.0.0.1',
      strictPort: true,
      fs: {
        allow: allowedFrontendFolders
      }
    },
    build: {
      outDir: buildOutputFolder,
      emptyOutDir: devBundle,
      assetsDir: 'VAADIN/build',
      rollupOptions: {
        input: {
          indexhtml: projectIndexHtml,

          ...(hasExportedWebComponents ? { webcomponenthtml: path.resolve(frontendFolder, 'web-component.html') } : {})
        },
        onwarn: (warning: rollup.RollupWarning, defaultHandler: rollup.WarningHandler) => {
          const ignoreEvalWarning = [
            'generated/jar-resources/FlowClient.js',
            'generated/jar-resources/vaadin-spreadsheet/spreadsheet-export.js',
            '@vaadin/charts/src/helpers.js'
          ];
          if (warning.code === 'EVAL' && warning.id && !!ignoreEvalWarning.find((id) => warning.id.endsWith(id))) {
            return;
          }
          defaultHandler(warning);
        }
      }
    },
    optimizeDeps: {
      entries: [
        // Pre-scan entrypoints in Vite to avoid reloading on first open
        'generated/vaadin.ts'
      ],
      exclude: [
        '@vaadin/router',
        '@vaadin/vaadin-license-checker',
        '@vaadin/vaadin-usage-statistics',
        'workbox-core',
        'workbox-precaching',
        'workbox-routing',
        'workbox-strategies'
      ]
    },
    plugins: [
      productionMode && brotli(),
      devMode && vaadinBundlesPlugin(),
      devMode && showRecompileReason(),
      settings.offlineEnabled && buildSWPlugin({ devMode }),
      !devMode && statsExtracterPlugin(),
      devBundle && preserveUsageStats(),
      themePlugin({ devMode }),
      postcssLit({
        include: ['**/*.css', /.*\/.*\.css\?.*/],
        exclude: [
          `${themeFolder}/**/*.css`,
          new RegExp(`${themeFolder}/.*/.*\\.css\\?.*`),
          `${themeResourceFolder}/**/*.css`,
          new RegExp(`${themeResourceFolder}/.*/.*\\.css\\?.*`),
          new RegExp('.*/.*\\?html-proxy.*')
        ]
      }),
      {
        name: 'vaadin:force-remove-html-middleware',
        transformIndexHtml: {
          enforce: 'pre',
          transform(_html, { server }) {
            if (server && !spaMiddlewareForceRemoved) {
              server.middlewares.stack = server.middlewares.stack.filter((mw) => {
                const handleName = '' + mw.handle;
                return !handleName.includes('viteHtmlFallbackMiddleware');
              });
              spaMiddlewareForceRemoved = true;
            }
          }
        }
      },
      hasExportedWebComponents && {
        name: 'vaadin:inject-entrypoints-to-web-component-html',
        transformIndexHtml: {
          enforce: 'pre',
          transform(_html, { path, server }) {
            if (path !== '/web-component.html') {
              return;
            }

            return [
              {
                tag: 'script',
                attrs: { type: 'module', src: `/generated/vaadin-web-component.ts` },
                injectTo: 'head'
              }
            ];
          }
        }
      },
      {
        name: 'vaadin:inject-entrypoints-to-index-html',
        transformIndexHtml: {
          enforce: 'pre',
          transform(_html, { path, server }) {
            if (path !== '/index.html') {
              return;
            }

            const scripts = [];

            if (devMode) {
              scripts.push({
                tag: 'script',
                attrs: { type: 'module', src: `/generated/vite-devmode.ts` },
                injectTo: 'head'
              });
            }
            scripts.push({
              tag: 'script',
              attrs: { type: 'module', src: '/generated/vaadin.ts' },
              injectTo: 'head'
            });
            return scripts;
          }
        }
      },
      checker({
        typescript: true
      }),
      productionMode && visualizer({ brotliSize: true, filename: bundleSizeFile })
    ]
  };
};

export const overrideVaadinConfig = (customConfig: UserConfigFn) => {
  return defineConfig((env) => mergeConfig(vaadinConfig(env), customConfig(env)));
};
function getVersion(module: string): string {
  const packageJson = path.resolve(nodeModulesFolder, module, 'package.json');
  return JSON.parse(readFileSync(packageJson, { encoding: 'utf-8' })).version;
}
function getCvdlName(module: string): string {
  const packageJson = path.resolve(nodeModulesFolder, module, 'package.json');
  return JSON.parse(readFileSync(packageJson, { encoding: 'utf-8' })).cvdlName;
}
